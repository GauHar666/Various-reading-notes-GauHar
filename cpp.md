# cpp

1.hello world 的书写

```c++
\#include<iostream>

using namespace std;

 

int main()

{

​	cout << "hello world" << endl;

​	system("pause");

 

​	return 0;

 

}

 
```



 

2.//单行注释   /*多行注释*/

3.变量 int 整形（int 变量名=变量初始值；）

4.常量：宏常量#define 一般写在main函数前面 常量：const修饰变量 可以写在main函数里面

Const int **=**；

5.变量只能由字母、数字、下划线构成，第一个字符必须为字母或下划线，区分大小写。

6.<<  ****  <<  内部是可以自己定义输出的变量

7.C++编程中一定要注意

8.整型：short（短整型/2字节） int（4字节）  long（4字节）  longlong(8字节)

9.sizeof（数据类型/变量） 用于统计数据类型所占内存大小

10.实型（浮点型）：用于表示小数：float（单精度）7位有效数字、double（双精度）15-16位有效数字。

11.字符型：char ch =‘a’；单引号里面只有一个字母

a-97  A-65

水平制表符\t 一般用于对齐

12.字符串：char 变量名[ ]=”字符串值”  或  string 变量名=“字符串值”，前提是要在头文件定义#include <string>

13.布尔类型bool

bool flag=true/false  true=1  false=0；

14.数据的输入：cin>>变量，相当于定义好了一个数据类型，但是你要给定一个输入值。（注意后面是大于号。）  int num=0； cin>>给定值； 如果想看到给定值再输出。

15.运算符：%表示取余数（10%3=1）  前置递增：a=2；b=++a a=3，b=3

  后置递增：a=2；b=a++  a=3，b=2；

16.幅值运算符：+=、-=、*=、/=  a+=2相当于a=a+2；

17.比较运算符：==（相等于），！=（不等于），输出结果只有可能是0，1即真或者假两种。

18.逻辑运算符：！非，&&与，||或

19.if（条件），同时if后面不要加分号！！   If（条件）{ }  else（）……

If（）  else if（）  ……else（）（然而在python中是需要加分号的）

20.嵌套if语句：if里面再来个if

21.三目运算符  表达式1？表达式2：表达式3 如果表达式1为真，执行表达式2，并输出表达式2的结果。如果表达式1为假，则执行表达式3，并返回表达式3的值。

例如c=（a>b?a:b），同时返回值是变量。

22.选择结构：switch语句

Switch（表达式）

{

Case 1,break;

Case 2:break;

………

Default 表示不符合上面任何一个case。

Case 后面要加冒号！！！同时每个case要加break！！！

 

23.循环结构：

While（循环条件）{循环语句}

满足循环条件 就一直执行循环语句内的东西

退出循环要写个break！！！

 

Do{循环语句}while（循环条件）

与while的区别：会先进行一次循环，然后再判断循环条件。

 

For循环for（起始表达式；条件表达式；末尾循环体）{循环语句；}

For（int i=0;i<100;i++）

{ 你要在循环中做什么

}

24.生成随机数的指令

Rand（）%100 表示生成随机数为0-99的随机数

Int num=rand（）%100+1；表示生成1-100的随机数

Rand生成的是伪随机数，如果要使随机数随时间变化必须添加随机数种子，防止每次随机数每次都一样

Srand（（unsigned int）time（NULL））  同时在一开始要包含一个头文件#include<ctime>

 

 

25.获取一个数字的个位、十位和百位的方法

如153：个位：153%10=3

​		十位153/10=15  15%10=1（先整除，再取模）

​		百位153/100=1

 

26.嵌套循环：

For中for

外层循环（i） 内层（j）

 

27.跳转语句：continue，表示跳过本次循环中未执行的语句，继续下一次循环。

到了continue 后面的循环不执行了，直接执行下一次的代码。

Break是直接退出循环。  如：输出基数的代码

For（int a=0；a<100;a++）

{ if(a%2=0)  {continue;}  cout<<i<<endl;}

28.跳转语句中的：goto  可以无条件的跳转代码

语法：goto 标记；  如果标记的名称存在，执行到goto语句时，会跳转到标记的位置。

标记一般是纯大写，  比如说在第二行代码写了一个goto FLAG; 就会去找FLAG

第五行前面写了FLAG:  则会直接跳到第五行。（一般不用，不好维护代码）

 

29.数组定义的方式

（1）数据类型  数组名[ 数组长度 ]；

（2）数据类型  数组名[ 数组长度 ]={ 值1，值2，…}；

（3）数据类型  数组名[ ]={ 值1，值2，…}；

数组中每个元素都是相同的数据类型

数组中第一个数据a[0],第二个a[1] ……  特别注意：数组元素的下标是从0开始的

 

取址符号&a[0]

 

30.换值 不能直接换，会覆盖，所以要通过一个临时变量，a=c，b=a，c=b；这样的

交换代码示例：

int temp=arr[j+1];

arr[j]=arr[j+1];

arr[j+1]=temp;

 

31.冒泡排序：每一轮把最大的找出来，排序总轮数=元素个数-1

内层每次对比次数：j<元素个数-当前轮数-1

 

32.二维数组

（1）数据类型  数组名[ 行数 ][ 列数 ]；

（2）数据类型  数组名[ 行数 ][ 列数 ]={ {值1，值2}，{值3，值4}…}；

（3）数据类型  数组名[ 行数 ][ 列数 ]={ 值1，值2，值3，值4…}；

（4）数据类型  数组名[ ][ 列数 ]={ 值1，值2，值3，值4…}；

 

String names[ ]={“张三”，”李四”，“王五”}  定义输入名字数组时的写法。

同时头文件要包含include <string>



#### 冒泡排序

**作用：** 最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
3. 重复以上的步骤，每次比较次数-1，直到不需要比较

![1541905327273](C:\Users\高涵\Desktop\yyd宇宙级\语言教学\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541905327273.png)

**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

```C++
int main() {

	int arr[9] = { 4,2,8,0,5,7,1,3,9 };

	for (int i = 0; i < 9 - 1; i++)
	{
		for (int j = 0; j < 9 - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << endl;
	}
    
	system("pause");

	return 0;
}
```



==而且一般for循环中的i变量定义在for中定义比较好一点==

我尝试在外部定义好在放到里面，无法正确运行





## 指针相关：



==作为指针， p代表的意思是地址。
而&a表示的也是a的地址， 二者相同， 所以需要p=&a;
定义的时候
int *p=&a;
这时，*是和int一起，表示p的类型的。
赋值其实还是p=&a；==



指针代表一个变量的地址，地址是十六进制的数字，0x开头

p = &a

- 指针不管是什么类型的指针都占==4个字节==（32位系统下），64位系统下不管什么指针类型都占8个字节

- 定义指针的时候：int *p = &a，虽然星p是取址，但是赋值给一个变量时后面还是要加取地址符号。

  ### 空指针与野指针

  **空指针**：指针变量指向内存中编号为0的空间

  **用途：**初始化指针变量

  **注意：**空指针指向的内存是不可以访问的

==或者可以称之为用来初始化一个指针==，空指针int *p =NULL；，空指针指向的内存不可以被访问，即不可以对他进行解码后重新赋值。



​	**野指针**：指针变量指向非法的内存空间



###  ==const修饰指针==

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量



常量指针，const在前，指针在后，const int*p = &a；特点：==指针的指向可以修改，但是指针指向的值不可以修改。==就相当于可以让p指向b（p=&b），但是不可以修改为星p=20；



指针常量：*在前，const在后，int * const p=&a；特点：==指针的指向不可以改，指针指向的值可以改==，

（const限制了p，没有限制*p）



两个都限制：const int* const p =&a；



如果使用指针函数的话：需要了解的是：

​	swap2(&a, &b); //地址传递会改变实参，调用时需要增加地址符号。

而在定义参数的时候，如果需要输入地址的话，需要

```c++
void maopao(int *a,int len) //需要调用数组时，选取数组的数组名并解码才可以进行使用
```





## 结构体

### 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型



### 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
* 定义结构体时顺便创建变量



> 总结1：定义结构体时的关键字是struct，不可省略

> 总结2：创建结构体变量时，关键字struct可以省略

> 总结3：结构体变量利用操作符 ''.''  访问成员



```c++
struct student //这里的struct不可以省略。
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 
```




```c++
int main() {
//结构体变量创建方式1
struct student stu1; //struct 关键字可以省略

stu1.name = "张三";
stu1.age = 18;
stu1.score = 100;

cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;

    
//结构体变量创建方式2
struct student stu2 = { "李四",19,60 };

cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;
```




```c++
stu3.name = "王五";
stu3.age = 18;
stu3.score = 80;
cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;

system("pause");
return 0;
```
}



结构体变量

结构体数组 arr [3]



- 结构体如何进行指针操作？

- 先前已经定义好struct student{   .....}；的情况下，

  ```c++
  struct student stu = { "张三",18,100, };
  struct student * p = &stu;  //这里的struct是可以省略的，而这里不可以使用int类型的指针原因是以为之前已经定义好了student类型，所以对应的指针类型也要属于student。
  p->score = 80; //指针通过 -> 操作符可以访问成员
  ```

->符号可以进行结构体访问



### 8.5 结构体嵌套结构体

**作用：** 结构体中的成员可以是另一个结构体,就是一个结构体中的属性

见课件中。





结构体中值传递用“.”，指针传递用"->"

cpp中输出方式比较特殊：cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;使用一个对一个的方式；

（python中，则是使用.format（）的形式来进行）



指针的好处：占用的内存比较小（指针作为函数的传入参数，只占4个字节（64位系统占8个字节），不需要去拷贝指针原本参数内的每一个变量）

```c++
srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>

 rand() % 61 + 40;

/s
```





==有一个问题？class和struct的区别是什么？==
