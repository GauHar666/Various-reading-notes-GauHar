

# 0刷题过程中的知识补充

==回文问题再看看==

==二叉树问题再看看==

==背包问题的dp公式==



1. return要在一个方法的内部，返回类型要和定义类型相同

2. 可以直接调用swap（a，b）交换两个vector类型元素，默认地址交换

3. substr（a，b），复制字符串函数，要求从指定位置开始，并具有指定的长度。如果没有指定长度_Count或_Count+_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾

4. string可以直接当作栈数据类型，可以直接pop_back(),也可以push_back()。但是stack中操作是push和pop要注意区分。

5. 最大整数：`INT_MAX `,最小整数：`INT_MIN`

6. 面对多个标签指的类型，建议使用map，这里用unorder_map，表示无序map，不会按键值排序。`unordered_map` 就是哈希表（字典）

7. atoi()函数将数字格式的[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)转换为整数类型。例如，将字符串“12345”转换成数字12345。里面要放一个地址。stol，stoi，stoll。

7. `string strNum = to_string(N);`用to_string可以把整数类型变成字符串

8. string容器做分割的方法：string的find返回的是一个int类型的下标，如果没找到则返回-1；

   ```cpp
   //比如按照：做分割
   pos = str.find(":");
   if(pos!=-1){
       str1=str.substr(0,pos);
       str2=str.substr(pos+1,str.size()-pos-1);
   }
   ```

9. 对于哈希表中的find，返回的则是迭代器，如果没找到，则返回end（）。

10. 不断读文件

    ```cpp
    ifstream ifs;
    ifs.open(filename,ios::in);
    while(ifs>>data && ifs>>interval && ifs>>stuId && ifs>>stuName)//一行一行读入，每行内的东西按照“ ”进行分割
    {
        
    }
    ```

    关于写文件：

    ```cpp
    void test()
    {
    	ofstream ofs;
    	ofs.open("penson.txt", ios::out|ios::binary);
    	Person p = { "小张",22 };
    	ofs.write((const char*)&p, sizeof(Person));//必须两个参数，用write
    	ofs.close();
    }
    
    //遍历写：
    for(int i=0;i<this->m_size;i++0){
        ofs<<"data"<<this->m_orderData[i]<<" ";
    }
    ```

    

11. map类型的容器重新插入内容的写法：要重新创建一个pair对组类型插入

    ```cpp
    m.insert(make_pair(key,value));//用的圆括号不是尖括号。
    ```

12. map中嵌套map怎么取第二个map中的值：

```cpp
for(auto it=map1.begin();it!=map1.end();it++){
    for(auto mit=(*)it.second.begin();mit!=it->second.end();mit++){
        cout<<"key= "<<mit->first<<"value "<<mit->second;
    }
}

```

13. 左移和右移相关：左移动一个整数 x和一个整数 y ( x < < y ) y  等于 x 乘以 y^2

```cpp
/* C++ Program to demonstrate use of left shift  
   operator */
#include<stdio.h> 
int main() 
{ 
    // a = 5(00000101), b = 9(00001001) 
    unsigned char a = 5, b = 9;  
  
    // The result is 00001010  
    printf("a<<1 = %d\n", a<<1); 
    
    // The result is 00010010  
    printf("b<<1 = %d\n", b<<1);   
    return 0; 
} 
a<<1 = 10
b<<1 = 18

```

**右移**：右平移 ( x > > y )  等于x除以 y^2 

```cpp
/* C++ Program to demonstrate use of right 
   shift operator */
#include<stdio.h> 
  
using namespace std; 
int main() 
{ 
    // a = 5(00000101), b = 9(00001001) 
    unsigned char a = 5, b = 9;  
  
    // The result is 00000010  
       
    printf("a>>1 = %d\n", a>>1); 
    
    // The result is 00000100 
    printf("b>>1 = %d\n", b>>1);   
    return 0; 
}
a>>1 = 2
b>>1 = 4

```

**C++位运算：**

任何信息在计算机中都是采用二进制表示的，数据在计算机中是以补码形式存储的，**位运算就是直接对整数在内存中的二进制位进行运算**。由于位运算直接对内存数据进行操作，不需要转换成十进制，因此处理速度非常快

C++ 提供了按位与（&）、按位或（| ）、按位异或（^）、取反（~）、左移（<<）、右移（>>）这 6 种位运算符。  这些运算符只能用于整型操作数，即只能用于带符号或无符号的 char、short、int 与 long 类型。

- &运算规则：0&0=0;  0&1=0;  1&0=0;   1&1=1;   即：两位同时为“1”，结果才为“1”，否则为0
- ^按位异或：：0 ^ 0=0；  0 ^ 1=1；  1^ 0=1；  1^1=0；参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

14. set容器的插入只有insert，删除只有erase，然后默认从小到大排序。
15. C++中拼接两个vector：`v1.insert(v1.end(),v2.begin(),v2.end());`相当于说从尾部插入。

**常见问题：子序列默认不连续，子数组默认连续**

# 1.算法性能分析

- 时间复杂度：时间复杂度就是用来方便开发者估算出程序运行的答题时间
- 比如123456789，你要找2，首先查中间元素5，大于2，所以直接排除掉5右边的6789，然后在1234里继续[二分查找](https://so.csdn.net/so/search?q=二分查找&spm=1001.2101.3001.7020)。每次排除1/2的元素，所以是O(log2n)。==每次去掉多少这种就是log==

- 操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。**大O用来表示的是上界**，表示最坏的情况，快排O（nlogn），插入O（n^2）,冒泡O（n2）.但是快排不是严格上界，而是业内的默认规定。

![image-20221020154352414](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221020154352414.png)

- 插入如果本来有序是O(n)，逆序就是O（n2）.快排如果原本有序就是O（n2）.

- 时间复杂度一般忽略常数项系数。

- 一般来说：O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶
- **但我们统一说 logn，也就是忽略底数的描述**。
- 递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归的时间复杂度**。



空间复杂度：

- 一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)）
- **空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。**
- 空间复杂度是logn的情况确实有些特殊，其实是在**递归的时候，会出现空间复杂度为logn的情况**。
- **递归算法的空间复杂度 = 每次递归的空间复杂度 \* 递归深度**
- ![image-20221020161554437](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221020161554437.png)

为什么会有内存对齐：

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
2. 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。

CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。会占用一些额外空间，但是运行速度会加快。

# 2.数组

##2.1基础知识的补充：

**数组是存放在连续内存空间上的相同类型数据的集合。**

需要两点注意的是

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

**数组的元素是不能删的，只能覆盖。**



对于二维来说：不同编程语言的内存管理是不一样的，以C++为例，在**C++中二维数组是连续分布的**。

寻找左边界的二分查找：（元素会重复时）

```cpp
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;//找到左边界后不立马返回，继续查找，让左边界缩回来
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

```

寻找右边界：

```cpp
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 最后改成返回 left - 1
    if (left - 1 < 0) return -1;
    return nums[left - 1] == target ? (left - 1) : -1;
}
```



##2.2力扣704.二分查找（e）

##二分系列

**这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件.代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。



关键是要使用到区间进行判断，定义好left和right还有middle。使用前闭后闭区间`[left,right]`,right=nums.size()-1;

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right=nums.size()-1;
        while(left<=right){
            int middle = (left+right)/2;
            if(nums[middle]<target){left = middle+1;}
            else if(nums[middle]>target){right=middle-1;}
            else{return middle;}
        }
        return -1;
    }
};
```

版本2：

```cpp
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```





### 力扣35 搜索插入位置/剑指Ⅱ 68 查找插入位置（e）

![image-20221017150046884](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221017150046884.png)



### ==力扣34 在排序数组中查找元素的第一个和最后一个位置==（m）

更详细一点可以看东哥的：[我写了首诗，让你闭着眼睛也能写对二分搜索 :: labuladong的算法小抄](https://labuladong.github.io/algo/2/20/29/)

1,2,3,4,5：递增排列，

9,8,7,6,5：递减排列。

1，2，3，3，4，5，8，8：非递减排列，

9，8，7，7，6，5，5，2，1 : 非递增排列。

==34和53题的关键都在于说：寻找左右边界，寻找左边界的时候找到一样的了固定右边不断缩小左边==



```cpp
class Solution {
public:
    vector<int> searchRange(vector<int> &nums, int target) {
        return {left_bound(nums, target), right_bound(nums, target)};
    }

    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.size() || nums[left] != target) {
            return -1;
        }
        return left;
    }

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 这里改为检查 right 越界的情况，见下图
        if (right < 0 || nums[right] != target) {
            return -1;
        }
        return right;
    }
};

```



###剑指53 [在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)（e）

==只改了return值和函数类型而已相较于力扣34==

```cpp
class Solution {
public:
    int search(vector<int> &nums, int target) {
        if(left_bound(nums, target)==-1){return 0;}
        return right_bound(nums, target)-left_bound(nums, target)+1;
    }

    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.size() || nums[left] != target) {
            return -1;
        }
        return left;
    }

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 这里改为检查 right 越界的情况，见下图
        if (right < 0 || nums[right] != target) {
            return -1;
        }
        return right;
    }
};

```

###力扣69[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)（e）

关键点在于right取一半不然会越界

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        long left=1;
        long right = num/2;
        while(left<=right){
            long mid = left+(right-left)/2;
            if(mid*mid==num) {return true;}
            else if(mid*mid<num){left = mid+1;}
            else if(mid*mid>num){right = mid-1;}
        }
        if(left*left==num){return true;}
        return false;
    }
};
```

###力扣367[有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)（e）

关键点在于right=x/2+1，向上兼容1。

```cpp
class Solution {
public:
    int mySqrt(int x) {
        long left = 1;
        long right = x/2+1;
        long mid;
        while(left<=right){
            mid = left+(right-left)/2;
            if(mid*mid<x) left=mid+1;
            else if(mid*mid>x) right=mid-1;
            else if(mid*mid == x) return mid;
        }
        if(x==0) return 0;
        if(x==1) return 1;
        return right;
    }
};
```

##双指针系列

###2.3力扣27.移除元素（e）

1.暴力：关键在于i也要-1，因为你删掉一个元素之后向前挪动了，i自然也要-1才可以重新递归，不然会报错。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n=nums.size(); 
        for(int i=0;i<n;i++){
            if(nums[i]==val){
                for(int j=i+1;j<n;j++){
                    nums[j-1]=nums[j];
                }
                i--;
                n--;
            }
        }
        return n;
    }
};
```

2. 双指针法（快慢指针）--同向而行：

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int ptr1=0,ptr2=0;
        int n=nums.size();
        while(ptr1<n){
            if(nums[ptr1] != val){
                nums[ptr2] = nums[ptr1];
                ptr2++;
            }
            ptr1++;
        }
        return ptr2;
    }
};
```

3.左右指针法--相向而行：

```cpp
/**
* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素
* 时间复杂度：O(n)
* 空间复杂度：O(1)
*/
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while (leftIndex <= rightIndex) {
            // 找左边等于val的元素
            while (leftIndex <= rightIndex && nums[leftIndex] != val){
                ++leftIndex;
            }
            // 找右边不等于val的元素
            while (leftIndex <= rightIndex && nums[rightIndex] == val) {
                -- rightIndex;
            }
            // 将右边不等于val的元素覆盖左边等于val的元素
            if (leftIndex < rightIndex) {
                nums[leftIndex++] = nums[rightIndex--];
            }
        }
        return leftIndex;   // leftIndex一定指向了最终数组末尾的下一个元素
    }
};
```



###力扣26. [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)(e)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int ptr1=0,ptr2=0;
        int n=nums.size();
        while(ptr1<n){
            if(nums[ptr1]!=nums[ptr2]){
                nums[ptr2+1]=nums[ptr1];
                ptr2++;
            }
            ptr1++;
        }
        return ptr2+1;
    }
};
```

返回长度的时候要加1.

### 力扣283.移动0(e)

还是快慢指针，然后排好之后后面置0：

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left=0,right=0;
        int n=nums.size();
        while(right<n){
            if(nums[right] != 0){
                nums[left]=nums[right];
                left++;
            }
            right++;
        }
        for(left;left<n;left++){
            nums[left]=0;
        }
    }
};
```

###力扣167[两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)（m）

初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

方法1：左右指针

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int low=0,high=numbers.size()-1;
        while(low<high){
            int sum=numbers[low]+numbers[high];
            if(sum==target){return {low+1,high+1};}
            else if(sum<target){
                ++low;
            }
            else{
                --high;
            }
        }
        return{-1,-1};
    }
};
```

### 力扣344 反转字符串(e)

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0,right=s.size()-1;
        int n=s.size()/2;
        for(int i=0;i<n;i++){
            swap(s[left],s[right]);
            left++;
            right--;
        }
    }
};
```

### ==力扣5 最长回文子串（m）==

正着读和反着读结果一样的才叫回文子串：

补充知识：substr（）

**substr()是C++语言函数，主要功能是复制子字符串，要求从指定位置开始，并具有指定的长度，==包括开始位置==。如果没有指定长度_Count或_Count+_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾**

![img](https://img-blog.csdnimg.cn/20191118213446283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0MDY2Nw==,size_16,color_FFFFFF,t_70)

找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是**从中心向两端扩散的双指针技巧**。

中心扩展！！！

```cpp
class Solution {
public:
	string longestPalindrome(string s) 
	{
		if (s.length() < 1)
		{
			return "";
		}
		int start = 0, end = 0;
		for (int i = 0; i < s.length(); i++)
		{
			int len1 = expandAroundCenter(s, i, i);//一个元素为中心
			int len2 = expandAroundCenter(s, i, i + 1);//两个元素为中心
			int len = max(len1, len2);
			if (len > end - start)
			{
				start = i - (len - 1) / 2;//要-1再除2
				end = i + len / 2;
			}
		}
		return s.substr(start, end - start + 1);
	}

	int expandAroundCenter(string s, int left, int right)
	{
		int L = left, R = right;
		while (L >= 0 && R < s.length() && s[L] == s[R])
		{// 计算以left和right为中心的回文串长度
			L--;
			R++;
		}
		return R - L - 1;//再剪掉-1
	}
};
```



### 力扣844 比较退格字符串（e）

双指针太难理解了，推荐使用堆栈

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        int i = S.length() - 1, j = T.length() - 1;
        int skipS = 0, skipT = 0;

        while (i >= 0 || j >= 0) {
            while (i >= 0) {
                if (S[i] == '#') {
                    skipS++, i--;
                } else if (skipS > 0) {
                    skipS--, i--;
                } else {
                    break;
                }
            }
            while (j >= 0) {
                if (T[j] == '#') {
                    skipT++, j--;
                } else if (skipT > 0) {
                    skipT--, j--;
                } else {
                    break;
                }
            }
            if (i >= 0 && j >= 0) {
                if (S[i] != T[j]) {
                    return false;
                }
            } else {
                if (i >= 0 || j >= 0) {
                    return false;
                }
            }
            i--, j--;
        }
        return true;
    }
};
```

栈实现：

string可以直接当成栈来使用！！！

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        return build(S) == build(T);//比较两个字符串是否相同
    }

    string build(string str) {
        string ret;
        for (char ch : str) {
            if (ch != '#') {
                ret.push_back(ch);
            } else if (!ret.empty()) {
                ret.pop_back();
            }
        }
        return ret;
    }
};
```



###力扣[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)（m）

注意点：要新建一个vector。//时间复杂度较高 

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> v;
        for(int i=0;i<nums.size();i++){
            v.push_back(nums[i]*nums[i]);
        }
        sort(v.begin(),v.end());
        return v;
    }
};
```

双指针法：从后往前插，左右指针。

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {
            if (nums[i] * nums[i] > nums[j] * nums[j]) {
                ans[pos] = nums[i] * nums[i];
                ++i;
            }
            else {
                ans[pos] = nums[j] * nums[j];
                --j;
            }
            --pos;
        }
        return ans;
    }
};
```

![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)



##滑动窗口系列

## 2.4力扣209 长度最小的子数组（m）



滑动窗口解法：所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

传统的两个for循环其实就是一个滑动窗口，一个控制起始，一个控制终止。

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

滑动窗口的关键核心在于：==判断出大于之后把一开始窗口那个元素剪掉，就不用反复累加==:`sum = sum-nums[l];`



==while（），里面写的是发生意外情况的处理办法！！！==

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int l=0,n=nums.size();
        int sum=0;
        int result=INT_MAX;
        for(int i=0;i<n;i++){
            sum+=nums[i];
            while(sum>=target){
                result=min(result,i-l+1);
                sum-=nums[l];
                l++;
            }
        }
        return result==INT_MAX?0:result;
    }
};
```

补充知识：最大整数：`INT_MAX `,最小整数：`INT_MIN`

### 力扣904 水果成篮（m）

面对多个标签指的类型，建议使用map，这里用了unorder_map，表示无序map，不会按键值排序。`unordered_map` 就是哈希表（字典）

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int l=0,n=fruits.size(),res=0;
        unordered_map<int,int> mp;
        for(int i=0;i<n;i++){
            mp[fruits[i]]++;
            while(mp.size()>2){
                auto it=mp.find(fruits[l]);
                it->second--;
                if(it->second==0){
                    mp.erase(it);
                }
                l++;
            }
            res=max(res,i-l+1);
        }
        return res;
    }
};
```



滑动窗口模板：

```cpp
/* 滑动窗口算法框架 */
void slidingWindow(string s) {
    unordered_map<char, int> window;
    
    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```



### 力扣76 最小覆盖子串（h）

这个题难点在于要创建两个哈希表。区间设置成`[left, right)` 是左闭右开的。

![image-20221022150014278](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221022150014278.png)

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char,int> need,window;
        for(c:t) need[c]++;

        int left=0,right=0;
        int valid=0;
        int start=0,len=INT_MAX;
        while(right<s.size()){
            char c = s[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c]==need[c])
                    valid++;
            }
        }
        while(valid==need.size()){
            if(right-left<len){
                start=left;
                len=right-left;
            }
            char d = s[left];
            left++;
            if(need.count(d)){
                if(window[d]==need[d])
                    valid--;
                window[d]--;
            }
        }
    }
    return len == INT_MAX ?
        "" : s.substr(start, len);
};
```

###力扣3 无重复字符的最长子串（m）

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> cnt;
        int left=0,right=0;
        int len=0;
        while(right<s.size())
        {
            char c = s[right];
            right++;
            cnt[c]++;
            while(cnt[c]>1){
               char d = s[left];
               left++;
               cnt[d]--;
            }
            len = max(len,right-left);
        }
        return len;
    }
};
```

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //定义两个游标,还有长度,与结果,均初始化为0
        int start(0),end(0),length(0),result(0);//相当于int start = 0 .....
        //只要end<字符串大小
        while(end<s.size())
        {
            //该注释错误		//暂存首个字符char,
            //其实应该是暂存end所指向的那个值,到时候会跟index所指向的值比较
            char tempChar=s[end];
            //定义index,它只用于改变start的指向一般为index+1
            //因为index所处的与end的值相等,则没有统计的必要了
            //for循环只用来判断是否相等
            //
            for(int index=start;index<end;index++)
            {
                //判断是否出现重复字符串
                if(tempChar==s[index])
                {
                    //start++;//这是错误的哦,没有优化呢
                    //如果出现,则将start跳过重复字符index指向的下一字符
                    start=index+1;
                    //保存长度
                    length=end-start;
                    /////////
                    //千万注意,如果相等,则该判断应该结束了
                    break;
                }
            }
            //此时,end向后移动,每一一次,长度+1
            end++;
            length++;
            //返回更新后的length,如果更大,则为它
            result=max(result,length);
        }
        return result;
    }
};
```

### 力扣567 字符串的排序(h)

```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        unordered_map<char, int> needs, windows;
        for(char c : s1) needs[c]++;
        int left = 0, right = 0, valid = 0;
        while(right < s2.size())
        {
            char ch = s2[right];//被加入到窗口的字母
            right++;
            if(needs.count(ch))
            {
                windows[ch]++;
                if(windows[ch] == needs[ch])
                    valid++;
            }
            while(right - left >= s1.size())//收缩条件为长度大于s2  right - left > s1.size()-1
            {
                if(valid == needs.size())
                    return true;
                char ch = s2[left];
                left++;
                if(needs.count(ch))//是目标字母
                {
                    if(windows[ch] == needs[ch])
                        valid--;
                    windows[ch]--;
                }
            }
        }
        return false;
    }
};
```



## 2.5 力扣59.螺旋矩阵Ⅱ（m）

这类题目没有考什么数据结构，也没考什么算法，就是考你算法能力。要注意的是你的每个区间一定要设置好且保证统一性才可以。

设置四个边界点即可。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector <vector<int>> ans(n,vector<int>(n,0));
        int u = 0; //赋值上下左右边界
        int d = n - 1;
        int l = 0;
        int r = n - 1;
        int num=1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans[u][i]=num++; //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans[i][r]=num++; //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans[d][i]=num++; //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans[i][l]=num++; //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};
```

### 力扣54 螺旋矩阵（m）=剑指29

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};
```





##2.6==力扣48.旋转图像（m）==

首先，需要理解基础的对称操作，对于 nxn 的矩阵 matrix，各种对称的转移式如下：

```c
上下对称：matrix[i][j] -> matrix[n-i-1][j]，（列不变）
左右对称：matrix[i][j] -> matrix[i][n-j-1]，（行不变）
主对角线对称：matrix[i][j] -> matrix[j][i]，（行列互换）
副对角线对称：matrix[i][j] -> matrix[n-j-1][n-i-1] （行列均变，且互换）
```

那么，对于顺时针 90° 旋转，即本题，先写出转移式：

`matrix[i][j] -> matrix[j][n-i-1]`

可以观察到，我们希望原来的列`j`不变，且要交换行列位置。
因此可以分解为：`上下对称 + 主对角线对称` 或者 `主对角线对称 + 左右对称`，

![image-20221023152638027](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221023152638027.png)

如果不用原地：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221023144948056.png" alt="image-20221023144948056" style="zoom: 67%;" />

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        auto new_matrix=matrix;
        for(int i=0;i<n;i++){
            for(int j=i,j<n;j++){
                new_matrix[j][n-i-1]=matrix[i][j];
            }
        }
        matrix = new_matrix;
    }
};
```

难点在于要原地修改。



一位力扣大佬的解答：

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        n = matrix.size();

        // 上下对称 + 主对角线对称
        upDownSymmetry(matrix);
        mainDiagSymmetry(matrix);

        // 主对角线对称 + 左右对称
        // mainDiagSymmetry(matrix);
        // leftRightSymmetry(matrix);

        // 左右对称 + 副对角线对称
        // leftRightSymmetry(matrix);
        // subdiagSymmetry(matrix);

        // 副对角线对称 + 上下对称
        // subdiagSymmetry(matrix);
        // upDownSymmetry(matrix);
    }

private:
    int n;

    // 上下对称
    void upDownSymmetry(vector<vector<int>>& matrix) {
        for (int i = 0; i < n/2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n-i-1][j]);
            }
        }
    }

    // 左右对称
    void leftRightSymmetry(vector<vector<int>>& matrix) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n/2; ++j) {
                swap(matrix[i][j], matrix[i][n-j-1]);
            }
        }
    }

    // 主对角线对称
    void mainDiagSymmetry(vector<vector<int>>& matrix) {
        for (int i = 0; i < n-1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }

    // 副对角线对称
    void subdiagSymmetry(vector<vector<int>>& matrix) {
        for (int i = 0; i < n-1; ++i) {
            for (int j = 0; j < n-i-1; ++j) {
                swap(matrix[i][j], matrix[n-j-1][n-i-1]);
            }
        }
    }
};
```



# 3.链表

### 3.1基础知识的补充

链表是通过指针串联在一起的**线性结构**，每个节点有指针域和数据域，data和next，next就是指针域。

==最后一个节点的指针域指向nullptr==，入口节点称为头节点：head。

==上一个节点的next指向下一个节点,比如cur->next,表示的是下一个整个节点，如何cur->next-> val表示想看下一个节点的数据域。==

**链表的类型**

1.单链表中的指针域只能指向节点的下一个节点。

2.双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

3.循环链表：顾名思义，就是链表首尾相连。

**链表的存储方式：**

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

####3.1.2链表节点的定义：

```cpp
struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x): val(x),next(NULL){}//节点构造函数
};
```

也可以不定义节点构造函数，C++会默认生成构造函数。但是会存在以下问题：

通过自己定义构造函数初始化节点：

```cpp
ListNode* head = new ListNode(5);
//可以在初始化的时候就对数据域赋值，指针域还是指向NULL
```

使用默认构造函数初始化节点：

```cpp
ListNode* head=new ListNode();
head->val=5;
//在初始化的时候不可以直接给变量赋值
```

#### 3.1.3链表的删除与插入

**删除D节点，如图所示：**

![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

只要将C节点的next指针 指向E节点就可以了。

那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。

是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。

**添加节点：**

如图所示：

![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)



数组和链表的对比：

![链表-链表与数据性能对比](https://img-blog.csdnimg.cn/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景



#### 3.1.4 遍历链表

```cpp
void printLinkedList() {
     ListNode* cur = _dummyHead;
     while (cur->next != nullptr) {
        cout << cur->next->val << " ";
        cur = cur->next;
     }
     cout << endl;
}
```



### 3.2力扣203 移除链表元素（e）

移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。==其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。==

其实**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

![203_链表删除元素6](https://img-blog.csdnimg.cn/20210316095619221.png)

==关键在于创建虚拟头节点：==

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode* cur = dummyHead;
        while(cur->next != nullptr){
            if(cur->next->val == val){
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
            else{
                cur=cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

###力扣21 合并两个有序链表（e）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* header = new ListNode(-1);
        ListNode* cur = header;
        while(list1 != nullptr && list2 != nullptr){
            if(list1->val <= list2->val){
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next =list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 == NULL ? list2 : list1;

        return header->next;
    }
};
```



### ==力扣707 设计链表（m）==

```cpp
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    void addAtIndex(int index, int val) {
        if (index > _size) {
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```

==获取一个值的时候要<=,插入的时候只需要<即可。==

### 力扣206 反转链表（e）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
		ListNode* cur=head;
        ListNode* pre=nullptr;
        ListNode* temp;
        while(cur){
            temp=cur->next;
            cur->next=pre;
       		pre=cur;
            cur=temp;     
        }
        return pre;
    }
};
```

### 力扣24 两两交换链表中节点(m)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *      ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead=new ListNode(-1);
        dummyHead->next=head;
        ListNode*cur=dummyHead;
        while(cur->next!=nullptr && cur->next->next != nullptr){
            ListNode* tmp=cur->next;
            ListNode*tmp1=cur->next->next->next;
            cur->next=cur->next->next;
            cur->next->next=tmp;
            cur->next->next->next=tmp1;
            cur=cur->next->next;
        }
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

### 力扣19 [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)（m）

对于找到列表中第几个元素，然后做什么操作这类题目，都可以结合双指针，因为不想数组可以直接跳到某个地方，链表找第n个元素的方法是：一个快慢指针都在头，然后比如说快指针向后n+1个，然后快慢一起移到末尾，就可以了，==一般要求只遍历一边。==

遍历两遍

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead=new ListNode(-1);
        dummyHead->next=head;
        ListNode* cur=dummyHead;
        ListNode* cur2=dummyHead;
        int len=0;
        while(cur->next != nullptr){
            cur=cur->next;
            len++;
        }
        if(len==1) {   
            return {};
        }
        for(int i=0;i<(len-n);i++){
            cur2=cur2->next;
        }
        cur2->next=cur2->next->next;
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
```



双指针，一次遍历：

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        while(n-- && fast){
            fast=fast->next;
        }
        fast=fast->next;
        while(fast){
            fast=fast->next;
            slow=slow->next;
        }
        ListNode* tmp=slow->next;
        slow->next=slow->next->next;
        delete tmp;
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

### ==力扣160 [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)（e）==

方法1，把短的那条并到长的的后面：

<img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2" style="zoom:50%;" />

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int len1=0,len2=0;
        ListNode* cur1=headA;
        ListNode* cur2=headB;
        while(cur1 != nullptr){
            cur1=cur1->next;
            len1++;
        }
        while(cur2 != nullptr){
            cur2=cur2->next;
            len2++;
        }
        cur1=headA;
        cur2=headB;
        if(len1<len2){
            swap(len1,len2);
            swap(cur1,cur2);
        }
        int gap= len1-len2;
        while(gap--){
            cur1=cur1->next;
        }
        while(cur1 != nullptr){
            if(cur1==cur2){
                return cur1;
            }
            cur1=cur1->next;
            cur2=cur2->next;
        }
        return nullptr;
    }
};
```



方法2:把两个链表串在一起

<img src="https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/6.jpeg" alt="img" style="zoom:67%;" />

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* cur1=headA;
        ListNode* cur2=headB;
        while(cur1!=cur2){
            if(cur1==nullptr){
                cur1=headB;
            }
            else{
                cur1=cur1->next;
            }
            if(cur2==nullptr){
                cur2=headA;
            }
            else{
                cur2=cur2->next;
            }
        }
        return cur1;
    }
};
```

### 力扣141 [环形链表](https://leetcode.cn/problems/linked-list-cycle/)（e）

经典判断方法了，没做之前肯定想不到，要使用双指针技巧中的快慢指针，每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* cur1=head;
        ListNode* cur2=head;
        while(cur2!=NULL && cur2->next != NULL){
            cur1=cur1->next;
            cur2=cur2->next->next;
            if(cur2==cur1){
                return true;
            }
        }
        return false;
    }
};
```

重点在于while里面要判断快指针是否为null，快指针的下一个指针是否为null。

###力扣142[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)(m)

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027152704598.png" alt="image-20221027152704598" style="zoom: 50%;" />

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow){
                slow=head;
                while(fast!=slow){
                    fast=fast->next;
                    slow=slow->next;
                }
                return fast;
            }
        }
        return nullptr;       
    }
};
```

### 力扣876 [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)（e）

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        return slow;
    }
};
```

### 力扣86[分隔链表](https://leetcode.cn/problems/partition-list/)（m）

==多看看这题的代码==

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummyHead1=new ListNode(-1);
        ListNode* dummyHead2=new ListNode(-1);
        ListNode* cur1=dummyHead1;
        ListNode* cur2=dummyHead2;
        ListNode* cur=head;
        while(cur!=nullptr){
            if(cur->val < x){
                cur1->next=cur;
                cur1=cur1->next;
            }
            else{
                cur2->next=cur;
                cur2=cur2->next;
            }
            ListNode* tmp=cur->next;
            cur->next=nullptr;
            cur=tmp;
        }
        cur1->next=dummyHead2->next;
        return dummyHead1->next;
    }
};
```

链表的总结就是要注意虚拟头节点的使用，



#4.哈希表

### ==4.0本节补充知识==

- unordered_map 和 unordered_set的底层都是哈希表，别的都是红黑树，所以unordered的时候效率最高

- map和set的区别

  - map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
  - ==set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key==。STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。
  - **map支持下标操作，set不支持下标操作。**map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。

  ![image-20221029145625587](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029145625587.png)

- C++ 11对容器的push_back, push_front, [insert](https://so.csdn.net/so/search?q=insert&spm=1001.2101.3001.7020) 增加了新的用法，与之对应的是emplace_back，emplace_front, emplace. 新的emplace的作用是可以在操作容器时调用对应类型的构造数。![img](https://img-blog.csdnimg.cn/20210620211826911.png#pic_center)

- 哈希表的常见操作：

  - `vector<vector<string>> tmp`；  这个是二维字符串数组的创建![image-20221028200736276](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221028200736276.png)

  - `unordered_map<string,vector<string>> map;`这个是哈希表的创建，第一个值为键，键的类型是字符串，第二个为值，值是一维的字符串数组![image-20221028200829319](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221028200829319.png)

  - 遍历二维字符串操作

    ```cpp
    for(auto str:strs){
        for(auto s:str)
    }
    ```

  - 按键插入哈希表中

    ```c++
    map[键名].push_back(s);//emplace_back;
    ```

  - 哈希表中每一个元素的遍历 `for(auto e:map) tmp.push_back(e.second);`每一个元素都包含两个值，first是其键，second是其值。

  - `sort(key.begin(),key.end());`没有返回值，返回的就是原本的key
  
  - map和set相关类的容器都没有push_back(),pop_back()等操作，需要插入都使用的是insert（），删除用的erase（），查找：`find(key);`   //查找key是否存在，若存在，返回该键元素的迭代器(位置)；若不存在，返回set.end（）；
  
- **能用数组做映射尽量用数组。**直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

- map本身是按照key值进行升序排列，对别的值如何排列：要利用一个新容器vector<pair<int,int>>

```cpp

bool cmp1(pair<int, int> a, pair<int, int> b) {
    return a.first < b.first;//对于first的升序
}
bool cmp2(pair<int, int>a, pair<int, int> b) {
    return a.second < b.second;//对于second的升序
}
int main()
{
    map<int, int> hash;
    hash[1] = 4;
    hash[3] = 3;
    hash[2] = 5;
    hash[4] = 1;
    vector<pair<int, int>> vecs;
    for (auto it = hash.begin();it!= hash.end();it++) {
        vecs.push_back(make_pair(it->first, it->second));
   }
     //对于first升序排列
    cout << "对于first升序排列:" << endl;
    sort(vecs.begin(), vecs.end(),cmp1);
    for (auto it = vecs.begin(); it != vecs.end(); it++)
        cout << it->first << ':' << it->second << '\n';
    //对于second升序排列
    cout << "对于second升序排列:" << endl;
    sort(vecs.begin(), vecs.end(), cmp2);
    for (auto it = vecs.begin(); it != vecs.end(); it++)
        cout << it->first << ':' << it->second << '\n';
    return 0;
}
```



###4.1哈希表基础知识

哈希表，（Hash table），也称为散列表。

哈希表是根据关键码的值，直接进行访问的数据结构，类似pair对组，在C++中常用`unordered_map`来表示。

**一般哈希表都是用来快速判断一个元素是否出现集合里。**如果用常规的数组遍历，则需要O（n）的时间复杂度，但是用哈希表就只要O（1）的时间复杂度

哈希函数（hash function）：通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

<img src="https://img-blog.csdnimg.cn/2021010423484818.png" alt="哈希表2" style="zoom:67%;" />

如果hashCode得到的数值大于哈希表大小（tableSize）了，为了保证所有映射出来的索引值都落在哈希表上，将会再次对数值做取模操作，取tableSize的模，保证了所有列表值都在表上有映射。



**哈希碰撞：（也就是散列查找的冲突处理方法）**

线性探测法和拉链法（分离链接法）：

- 线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：<img src="https://img-blog.csdnimg.cn/20210104235109950.png" alt="哈希表5" style="zoom:50%;" />

- 其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。<img src="https://img-blog.csdnimg.cn/20210104235015226.png" alt="哈希表4" style="zoom:50%;" />



**在C++中常见的三种哈希结构：**

- 数组
- set（集合）

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

- map（映射）



| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。



补充一个知识点，unordered_map/set和hash_map/set的关系，实际上是一样的，但是C++11后把unordered_map加入了标准库，而hash_map则是民间大神自己造的轮子，不建议再使用了。



哈希法就是典型的空间换时间的例子。



### 力扣242[有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)（e）

关键是字母的映射可以看成是26个字母,创建一个26字母的数组就可以了

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26]={0};
        for(char c:s){
            record[c-'a']++;
        }
        for(char k:t){
            record[k-'a']--;
        }
        for(int i=0;i<26;i++){
            if(record[i]!=0) return false;
        }
        return true;
    }
};

//排序方法 很无脑，时间复杂度较高
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        if(s==t) return true;
        else return false;
    }
};
```

####==力扣49 [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)（m）==

==注意写法，代码怎么写怎么建立哈希。==



1.利用排序后的单个子串来作为键，建立哈希表

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> tmp;
        unordered_map<string,vector<string>> map;
        for(string& str: strs){
            string key=str;
            sort(key.begin(),key.end());
            map[key].push_back(str);
        }
        for(auto e:map) tmp.push_back(e.second);
        return tmp;
    }
};

```



2.利用计数法来作为键

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> tmp;
        unordered_map<string,vector<string>> map;
        for(string& str: strs){
            string sts=string(26,'0');
            for(char& c:str){
                ++sts[c-'a'];//求键，键用string表示
            }
            map[sts].push_back(str);
        }
        for(auto e:map) tmp.push_back(e.second);
        return tmp;
    }
};
```

####==力扣438[找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)（m）==

垃圾算法（自己写的）：

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> tmp;
        if(s.size()<p.size()) return tmp;
        int slow=0;
        for(int i=0;i<=(s.size()-p.size());i++){
            string cur=s.substr(slow,p.size());
            if(isAnagram(cur,p)) tmp.emplace_back(i);
            slow++;
        }
        return tmp;
    }

    bool isAnagram(string s, string t) {
        int record[26]={0};
        for(char c:s){
            int i=c-'a';
            record[i]+=1;
        }
        for(char c:t){
            int j=c-'a';
            record[j]-=1;
        }
        for(int i=0;i<26;i++){
            if(record[i] !=0){
                return false;
            }
        }
        return true;
    }
};
```



**这种题目就应该滑动窗口,结合两个：**

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0;
    vector<int> res; // 记录结果
    while (right < s.size()) {
        char c = s[right];
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) 
                valid++;
        }
        // 判断左侧窗口是否要收缩
        while (right - left >= t.size()) {
            // 当窗口符合条件时，把起始索引加入 res
            if (valid == need.size())
                res.push_back(left);
            char d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }
        }
    }
    return res;
    }
};
```

####力扣383[赎金信](https://leetcode.cn/problems/ransom-note/)（e）

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map<char,int> mp1,mp2;
        int value=0;
        for(auto c:ransomNote) mp1[c]++;
        for(auto d:magazine){
            mp2[d]++;
        }
        for(auto e:mp1){
            if(e.second<=mp2[e.first])
                value++;
        }
        if(value==mp1.size()) return true;
        return false;
    }
};
```

官方解法：

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        vector<int> cnt(26);
        for (auto & c : magazine) {
            cnt[c - 'a']++;
        }
        for (auto & c : ransomNote) {
            cnt[c - 'a']--;
            if (cnt[c - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```

###力扣349 两个数组的交集（e）

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int>s1,s2;
        vector<int>v;
        for(auto &i:nums1) s1.insert(i);
        for(auto &j:nums2) s2.insert(j);
        
        for(auto &a : s1){
            if(s2.find(a) != s2.end()) v.emplace_back(a);
        }
        return v;
    }
};
```

### 力扣1 两数之和

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```

#### ==力扣15 三数之和（m）==

```cpp
		vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
```

两个重点

1. 去重要用

```cpp
if (nums[i] == nums[i -1]) { // 去重操作
    continue;
}
```

2.对于第二个数和第三个数的去重要在找到一个组之后。！！

####力扣18 四数之和（m）

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            if(nums[i]>target && nums[i]>=0) break;
            if(i>0 && nums[i]==nums[i-1]) continue;
            for(int j=i+1;j<nums.size();j++){
                if(nums[i]+nums[j]>target && nums[i]+nums[j]>=0) break;
                if(j>i+1 && nums[j]==nums[j-1]) continue;
                int left=j+1,right=nums.size()-1;
                while(right>left){
                    if((long)nums[i]+nums[j]+nums[left]+nums[right]>target) right--;
                    else if((long)nums[i]+nums[j]+nums[left]+nums[right]<target) left++;
                    else{
                        result.push_back({nums[i],nums[j],nums[left],nums[right]});
                        while(right>left && nums[right]==nums[right-1]) right--;
                        while(right>left && nums[left]==nums[left+1]) left++;
                        left++;
                        right--;
                    }
                }
            }
        }
        return result;
    }
};
```



### 力扣202 快乐数（e）

**如果某个数出现两次就不会是快乐数了，所有用一个哈希来记录就可以。**

```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_map<int,int>mp;
        while(1){
            ++mp[n];
            if(mp[n]>1) return false;
            int sum=getSum(n);
            if(sum==1) return true;
            n=sum;
        }
    }

    int getSum(int n){
        int sum=0;
        while(n){
            sum+=pow(n%10,2);
            n/=10;
        }
        return sum;
    }
};
```



###力扣454 四数相加II（m）

哈希表，四个数看成两个数，前两个一组的和看成键，出现次数看成值，后两组的和看成另外一个值。

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> mp;
        int n=nums1.size();
        int count=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                mp[nums1[i]+nums2[j]]++;
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(mp[-nums3[i]-nums4[j]]!=0){
                    count+=mp[-nums3[i]-nums4[j]];
                }
            }
        }
        return count;
    }
};
```

**总结**：

1. 数组就是简单的哈希表，但是数组的大小是受限的！题目包含小写字母，那么使用数组来做哈希最合适不过。
2. 不需要key值的一般用set，set最常用的就是find，`if(s2.find(a) != s2.end()) `做判断看看有没有找到。

# 5.字符串

##补充知识：

- string容器的基本操作：

  - reverse（s.begin(),s.end()）;迭代器反转

  - s.erase（起始位置，删除个数）,

  - s.erase()中也可以使用迭代器如：`s.erase(s.begin() + s.size() - 1);`

  - s.insert（起始位置，插入元素）//有空间会自动向后挪

  - s.resize（）；重新命名string的大小。

  - s.replace（*size_t pos, size_t len, const string& str*），

    ```cpp
    string line = "this@ is@ a test string!";  
            line = line.replace(line.find("@"), 1, ""); //从第一个@位置替换第一个@为空  
    ```
  
    

### 力扣344 反转字符串（上面有了）

### 力扣541[反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)（e）

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i=0;i<s.size();i+=2*k){
            if(i+k<=s.size()){
                reverse(s.begin()+i,s.begin()+k+i);
            }
            else{
                reverse(s.begin()+i,s.end());
            }
        }
        return s;
    }
};
```

###剑指05[ 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)（e）

==重点在于要扩容，因为%20占三个字符，所以要扩容==，扩容后 直接插入要用insert

```cpp
class Solution {
public:
    string replaceSpace(string s) {
       for(int i=0;i<s.size();i++){
           if(s[i]==' '){
               	s.resize(s.size() + 3);
				s.erase(i, 1);
				s.insert(i, "%20");
           }
           else continue;
       } 
       return s;
    }
};
```

或者用replace（），不用扩容

```cpp
class Solution {
public:
	string replaceSpace(string s) {
		int index = s.find(' ');
		if (index == -1)
		{
			return s;
		}
		while (true)
		{	
			s.replace(index, 1, "%20");
			index = s.find(' ');
			if (index == -1)
			{
				return s;
			}
		}
		return s;
	}
};

//
class Solution {
public:
    string replaceSpace(string s) {
        int index=s.find(" ");
        if(index==-1) return s;
        while(1){
            s.replace(index,1,"%20");
            index=s.find(" ");
            if(index==-1) break;
        }
        return s;
    }
};
```

### 力扣151[反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)（m）

==重点是中间删了之后，那个i要减掉1==，然后没步判断都要保证s.size（）>0

```cpp
class Solution {
public:
    void removeExtraSpace(string& s){
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==s[i+1] && s[i]==' '){
                s.erase(s.begin()+i);
                i--;
            }
            if(s.size()>0 && s[0]==' ') s.erase(s.begin());
            if(s.size()>0 && s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);
        }
    }
    string reverseWords(string s) {
        removeExtraSpace(s);
        reverse(s.begin(),s.end());
        int start=0;
        for(int i=0;i<s.size();i++){
            if(s[i]==' '){
                reverse(s.begin()+start,s.begin()+i);
                start=i+1;
            }
            if(i==s.size()-1){
                reverse(s.begin()+start,s.begin()+i+1);
            }
        }
        return s;
    }
};
```



对于移除空格的双指针方法：

```cpp
void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
    int slow = 0; 
    for (int i = 0; i < s.size(); ++i) { //
        if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
            if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
            while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                s[slow++] = s[i++];
            }
        }
    }
    s.resize(slow); //slow的大小即为去除多余空格后的大小。
}
```

###剑指Ⅱ58[左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)（e）

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        string a=s.substr(0,n);
        string b=s.substr(n,s.size());
        return b+a;
    }
};
```

空间复杂度为O（1）的算法

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(),s.begin()+n);
        reverse(s.begin()+n,s.end());
        reverse(s.begin(),s.end());
        return s;        
    }
};
```



###==力扣28[找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)（实现substr、KMP）==

确实不太能理解，建议背下来：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回退
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

###力扣187[重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)（m）

```cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> result;
        unordered_map<string,int> mp;
        if(s.size()<=10) return result;
        for(int i=0;i<=s.size()-10;i++){
            string a=s.substr(i,10);
            mp[a]++;
            if(mp[a]==2) result.push_back(a);
        }
        return result;
    }
};
```

### ==力扣459 重复的子字符串==

重要在于定义一个match的指标。

寻找是否匹配，if（s[j]!=s[j-i]）

for(int i=1;i<=n/2;i++)  只要遍历到一般就可以了，以为最少也要两倍。

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int n=s.size();
        for(int i=1;i<=n/2;i++){
            if(n%i==0){
                bool match=true;
                for(int j=i;j<n;j++){
                    if(s[j]!=s[j-i]){
                        match=false;
                        break;
                    }
                }
                if(match) return true;
            }
        }
        return false;
    }
};
```



**总结：**

在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。

而C++中string不用

其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。

# 6.栈和队列

## 基础知识补充：

有关于STL的版本：

1. **HP STL** 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
2. **P.J.Plauger STL** 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
3. **SGI STL** 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。



- 陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。
- 陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。



- 接下来介绍的队列和栈也是SGI STL

- 栈（stack）：先进后出

  - 提供push、pop、top（栈顶）接口（注意不是push_back和pop_back）
  - 不提供迭代器
  - 栈是以底层容器完成其所有工作的，对外提供统一接口，底层容器可以插拔，**所以往往不被归类为容器，而被视为container adapter（容器适配器）**
  - 栈的底层实现可以是vector，deque，list都可以，主要就是数组和链表的底层实现。
  - SGI STL如果没有特意去指定底层的话，默认是以**deque为缺省情况下栈的底层 结构**，堵住一边的deque，特意指定的写法：

  ```cpp
  std::stack<int,std::vector<int>> st;//指定vector为底层。
  ```

- 队列（queue）：是先进先出

  - peek()，pop，push，empty，front（），size，back（）//表示最后一个元素。swap(q1,q2);//交换两个queue中所有元素。
  - 队列的各部分特性和栈类似。队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, **SGI STL中队列一样是以deque为缺省情况下的底部结构。**

​	

###==力扣232 [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)（e）==

用两个栈，逻辑如下：<img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2" style="zoom:50%;" />

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {

    }
    
    void push(int x) {
        stIn.push(x);
    }
    
    int pop() {
        if(stOut.empty()){
            while(!stIn.empty()){
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result=stOut.top();
        stOut.pop();
        return result;
    }
    
    int peek() {
		int res = this->pop(); // 直接使用已有的pop函数
        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去
        return res;	
    }
    
    bool empty() {
        if(stOut.empty() && stIn.empty()){
            return true;
        }
        return false;
    }
};
```



### 力扣225 用队列实现栈

```cpp
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    MyStack() {

    }
    
    void push(int x) {
        q1.push(x);
    }
    
    int pop() {
        int size=q1.size();
        size--;//为了最后留下一个先剪掉1
        while(size--){
            q2.push(q1.front());
            q1.pop();
        }
        int result=q1.front();
        q1.pop();
        q1=q2;//把原本的东西还给q1
        while(!q2.empty()) q2.pop();//清空q2
        return result;
    }
    
    int top() {
        return q1.back();
    }
    
    bool empty() {
         return q1.empty();
    }
};
```



只用一个队列的方法：

```cpp
class MyStack {
public:
    queue<int> q1;
    MyStack() {

    }
    
    void push(int x) {
        q1.push(x);
    }
    
    int pop() {
        int size=q1.size();
        size--;
        while(size--){
            q1.push(q1.front());
            q1.pop();
        }
        int result=q1.front();
        q1.pop();
        return result;
    }
    
    int top() {
        return q1.back();
    }
    
    bool empty() {
        if(q1.empty()) return true;
        return false;
    }
};
```



### 力扣20 有效括号：

括号类题目都是对右括号分析有一个左括号，右括号加1

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' ) st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop();
        }
        return st.empty();
    }
};
```

###力扣921[使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)（m）

```cpp
class Solution {
public:
    int right=0,count=0;
    int minAddToMakeValid(string s) {
        for(auto c:s){
            if(c=='('){
                right++;
            }
            if(c==')'){
                right--;
                if(right==-1){
                    right=0;
                    count++;
                }
            }
        }
        return count+right;
    }
};
```

###力扣1047[删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)（e）

记住怎么把栈内元素拿出来的写法。

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        for(char c:s){
            if(st.empty() || c!=st.top()){
                st.push(c);
            }
            else if(c==st.top()){
                st.pop();
            }
        }
        string result="";
        while(!st.empty()){
            result+=st.top();
            st.pop();
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

或者：==字符串直接做栈==，但是要用push_back()和pop_back()

```cpp
class Solution {
public:
    string removeDuplicates(string S) {
        string result;
        for(char s : S) {
            if(result.empty() || result.back() != s) {
                result.push_back(s);
            }
            else {
                result.pop_back();
            }
        }
        return result;
    }
};
```

###150.[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)(m)

知识补充：如何把字符串类型转换为int，long，long类型：

- atoi（），针对C风格的字符转化为int，老版本了

- stoi（字符），转化为int
- stol（），转化为long
- stoll（），转化为longlong

C++中单引号和双引号区别：

**单引号是char 字符型， 双引号是string 字符串型**

单引号包裹的一个字符实际上代表一个整数。
双引号引起的[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)，代表的是一个指向无名数组起始字符的指针。该数组会被双引号之间的字符以及一个额外的二进制为零的字符 `'\0'` 初始化。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for(int i=0;i<tokens.size();i++){
            if(tokens[i]=="+"||tokens[i]=="-"||tokens[i]=="*"||tokens[i]=="/"){
                int num1=st.top();
                st.pop();
                int num2=st.top();
                st.pop();
                if(tokens[i]=="+") st.push(num2+num1);
                if(tokens[i]=="-") st.push(num2-num1);
                if(tokens[i]=="*") st.push((long)num2*(long)num1);
                if(tokens[i]=="/") st.push(num2/num1);
            }
            else{
                st.push(stoll(tokens[i]));
            }
        }
        return st.top();
    }
};
```

### 347.前K个高频元素

哈希表做法：注意写法。

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        vector<pair<int, int>> v;
        vector<int> v1;
        for(auto i:nums) mp[i]++;
        //把原本的值作为键插入到vector，然后vector进行排序，默认从小到大，再反转，再输出前k个就可以。
        for (auto it = mp.begin();it!= mp.end();it++) {
            v.push_back(make_pair(it->second, it->first));
        }
        sort(v.begin(), v.end());
        reverse(v.begin(),v.end());
        for(auto it = v.begin();it!=v.begin()+k;it++){
            v1.push_back(it->second);
        }
        return v1;
    }
};
```



堆解法：

```cpp
class Solution {
public:
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        for(auto i:nums) mp[i]++;
        priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparison> pri_que;
        for(auto it:mp){
            pri_que.push(it);
            if(pri_que.size()>k){
                pri_que.pop();
            }
        }
        vector<int> res(k);
        for(int i=0;i<k;i++){
            res[i]=pri_que.top().first;
            pri_que.pop();
        }
        return res;
    }
};
```



###大顶堆、小顶堆知识补充（优先队列）

**堆**：通常被称之为**优先队列**，是一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）的大小，而不是按照元素进入队列的先后顺序。优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，**看起来就是一个队列。**

优先级队列内部元素是自动依照元素的权值排列

缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

**堆：就是一棵完全二叉树，树中每个结点值都不小于（不大于）其子树的任意的左右孩子**

在C++中用：`priority_queue<Type, Container, Functional>`,类型、容器（必须用数组实现的容器，vector或者deque），Functional就是比较的方式（最大或最小）

```cpp
//升序队列
priority_queue <int,vector<int>,greater<int> > q;
//降序队列
priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）

```

当数据类型并不是基本数据类型，而是自定义的数据类型时，就不能用greater或less的比较方式了，而是需要自定义比较方式.自定义的方法是重载括号运算符：要用class来定义。

```cpp
//大顶堆
class myComparison
{
	bool operator () (fruit f1,fruit f2)
	{
		return f1.price < f2.price;
	}
};
```

### ==239 滑动窗口的最大值==

**其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。**

那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。**



方法1：最大堆（优先队列的维护）

用一个pair来同时记录下标，若下标不在滑动窗口内，直接把这个最大值pop，

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> ans = {q.top().first};
        for (int i = k; i < n; ++i) {
            q.emplace(nums[i], i);
            while (q.top().second <= i - k) {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```

时间复杂度O（nlogn），空间复杂度O（n）。



方法2：单调队列，双端数组deque实现：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221104204133758.png" alt="image-20221104204133758" style="zoom: 10%;" />

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```



# 7.二叉树

##==基础知识补充（红黑树的补充）==

在做题过程中大概有两种形式的二叉树：满二叉树和完全二叉树。

**满（完美）二叉树**：所有结点塞满，==深度为k，有2^k-1个节点的二叉树。==

**完全二叉树**：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

<img src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img" style="zoom:50%;" />

**堆：**特别注意！！：堆其实实质上就是一个完全二叉树，同时保证父子节点的顺序要有一定关系。

**二叉搜索树**：二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。与堆有所不同，二叉搜索树的左子树上的所有节点值一定小于他的根节点，右子树上所有节点值均大于它的根节点。左右子树也是二叉搜索树。

**平衡二叉搜索树（AVL树）：**又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**C++中map、set、multimap，multiset的底层实现都是红黑树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

**红黑树**：红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过 对任何一条从根到叶子的路径上各个结点着色方式的限制，==红黑树确保没有一条路径会比其他路径长出俩 倍，因而是***接近平衡的***。==

**红黑树的性质**：（==红黑树的插入和左右旋==，待补充）

1. 每个结点不是红色就是黑色

2. ==根节点是黑色的==

3. ==如果一个节点是红色的，则它的两个孩子结点是黑色的==

4. 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）

5. ==每个叶子结点都是黑色的(此处的叶子结点指的是空结点)==，红黑树的叶子节点并非传统的叶子节点，红黑树的叶子节点是null节点（空节点）且为黑色

6. 同一路径，不存在连续的红色节点

   ![img](https://img-blog.csdnimg.cn/20190409222157219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70)



为什么有了AVL还需要红黑树：

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡

- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
- 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
- 红黑树的红黑规则，保证最坏的情况下，也能在O（log2N）



一般都是使用链式存储来实现二叉树，但是也可以用数组（顺序）存储，但是比较占空间就是说。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221105204051248.png" alt="image-20221105204051248" style="zoom:67%;" />

## 二叉树的遍历方式：

二叉树主要有两种遍历方式：（都是图论中的内容）

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

- 深度优先遍历（**常用递归**）
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历（**一般用队列实现**）
  - 层次遍历（迭代法）

**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住 前中后序指的就是中间节点的位置就可以了

## 二叉树的定义：

二叉树节点定义的方式：

```cpp
class TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){};
}
```

和链表很像，多了一个节点指针罢了。



## 二叉树的递归遍历

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

### 力扣144二叉树前序遍历

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> v;
        traversal(root,v);
        return v;
    }
    void traversal(TreeNode * cur,vector<int>& vec){
        if(cur==NULL) return;
        vec.push_back(cur->val);//中
        traversal(cur->left,vec);//左
        traversal(cur->right,vec);//右
    }
};
```

### 力扣145二叉树后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> v;
        traversal(root,v);
        return v;
    }
    void traversal(TreeNode* cur,vector<int>& vec){
        if(cur==nullptr) return;
        traversal(cur->left,vec);//左
        traversal(cur->right,vec);//右
        vec.push_back(cur->val);//中
    }
};
```

###力扣94二叉树中序遍历

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        traversal(root,v);
        return v;
    }
    void traversal(TreeNode* cur,vector<int>& vec){
        if(cur==nullptr) return;
        traversal(cur->left,vec);//左
        vec.push_back(cur->val);//中
        traversal(cur->right,vec);//右
    }
};
```



## 二叉树的迭代遍历

迭代遍历都是使用栈来完成操作

### 前序遍历：

顺序是：中左右，先中间入栈然后出栈，然后先右后左，出栈的时候就是先左后右。

栈内元素是TreeNode* 类型

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root==nullptr) return res;
        st.push(root);
        while(!st.empty()){
            TreeNode* node=st.top();
            st.pop();
            res.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return res;
    }
};
```

###中序遍历：

中序和前后序是有差别的，一开始不要把root，给push近stack，然后创建一个cur，用指针的方法，每次把cur指向左子树，如果左子树为空了，把这个数弹出来存到vector中，然后再去访问右子树。

 ```cpp
 class Solution {
 public: 
     vector<int> inorderTraversal(TreeNode* root) {
         stack<TreeNode*> st;
         vector<int> vec;
         TreeNode* cur = root;
         while(cur!=nullptr || !st.empty()){
             if(cur) {
                 st.push(cur);
                 cur=cur->left;
             }
             else {
                 cur=st.top();
                 st.pop();
                 vec.push_back(cur->val);
                 cur=cur->right;
             }
         }
         return vec;
     }
 };
 ```

### 后序遍历

再来看后序遍历，先序遍历是中左右，后续遍历是左右中。那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root==nullptr) return res;
        st.push(root);
        while(!st.empty()){
            TreeNode* node=st.top();
            st.pop();
            res.push_back(node->val);
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

##==二叉树的层序遍历（m）==

层序遍历和别的遍历都不一样。**需要使用一个辅助的队列来实现**，

非递归实现：

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
       queue<TreeNode*> q;
       if(root!=nullptr) q.push(root);
       vector<vector<int>> result;
       while(!q.empty()){
            int size=q.size();//一定要固定每层的size
            vector<int> v;
            for(int i=0;i<size;i++){
                TreeNode* node=q.front();
                q.pop();
                v.push_back(node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            result.push_back(v);           
       } 
       return result;
    }
};
```

递归实现：

```cpp
class Solution {
public:
        void order(TreeNode* cur,vector<vector<int>>& result,int depth){
            if(cur==nullptr) return;
            if(result.size()==depth) result.push_back(vector<int>());
            result[depth].push_back(cur->val);
            order(cur->left,result,depth+1);
            order(cur->right,result,depth+1);
        }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;  
    }
};
```

###力扣[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)（m）

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> q;
        if(root!=nullptr) q.push(root);
        vector<vector<int>> res;
        while(!q.empty()){
            int size=q.size();
            vector<int> v;
            for(int i=0;i<size;i++){
                TreeNode* cur=q.front();
                q.pop();
                v.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(v);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

###力扣[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)（m）

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == (size - 1)) result.push_back(node->val); // 将每一层的最后元素放入result数组中
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

###力扣[637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)（e）

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> q;
        if(root!=nullptr) q.push(root);
        vector<double> v;
        while(!q.empty()){
            int size=q.size();
            double value=0;
            for(int i=0;i<size;i++){
                TreeNode* node=q.front();
                q.pop();
                value+=node->val;
                if(i==size-1) v.push_back(value/size);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }           
        } 
        return v;
    }
};
```

###力扣[N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)（m）

 注意用children[i],来访问子节点。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> q;
        vector<vector<int>> res;
        if(root!=nullptr) q.push(root);
        while(!q.empty()){
            vector<int> v;
            int size=q.size();
            for(int i=0;i<size;i++){
                Node* cur=q.front();
                q.pop();
                v.push_back(cur->val);
                for(int i=0;i<cur->children.size();i++){
                    if(cur->children[i]) q.push(cur->children[i]);
                }     
            }
            res.push_back(v);
        }
        return res;
    }
};
```

### 力扣515[在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)（m）

```cpp
int maxValue = INT_MIN; 
maxValue = node->val > maxValue ? node->val : maxValue;
```

###力扣116[填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if(root!=nullptr) q.push(root);
        while(!q.empty()){
            int size=q.size();
            for(int i=0;i<size;i++){
                Node* cur=q.front();
                q.pop();
                if(i<size-1) cur->next=q.front();
                if(i==size-1) cur->next=nullptr;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

### ==力扣104 二叉树的最大深度==

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```

上述这种是dfs

还有一种是层序遍历，设定一个depth，每层+1；

### ==力扣111 二叉树的最小深度==

递归：

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        if(root->left==nullptr && root->right==nullptr) return 1;
        int min_depth=INT_MAX;
        if(root->left!=nullptr) min_depth=min(minDepth(root->left),min_depth);
        if(root->right!=nullptr) min_depth=min(minDepth(root->right),min_depth);
        return min_depth+1;
    } 
};



class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```

或者层序遍历的时候：加个判断：

```cpp
if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
return depth;}
```

## 力扣226 翻转二叉树（e）

记住不能用中序遍历就可以，别的都可以

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return root;
        TreeNode* tmp;
        tmp=root->left;
        root->left=root->right;
        //可以直接swap(root->left,root->right);
        root->right=tmp;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};


//迭代：
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* node=st.top();
            st.pop();
            swap(node->left,node->right);
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        return root;
    }
};
```

##[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return compare(root->left,root->right);
    }
    bool compare(TreeNode* left,TreeNode* right){
        if(left==nullptr && right==nullptr) return true;
        else if(left==nullptr && right != nullptr) return false;
        else if(right==nullptr && left != nullptr) return false;
        else if(right->val != left->val) return false;
        bool outside = compare(left->left,right->right);
        bool inside = compare(left->right,right->left);
        return (outside&&inside);
    }
};
```

## 力扣[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

用到了之前有一个判断是否为同一个树的issametree功能。（力扣100相同的树）

```cpp
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root==nullptr){
            return subRoot==nullptr;
        }
        if(isSameTree(root,subRoot)) return true;
        return isSubtree(root->left,subRoot)||isSubtree(root->right,subRoot);
    }

    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr && q==nullptr) return true;
        else if(p==nullptr && q!=nullptr) return false;
        else if(p!=nullptr && q==nullptr) return false;
        else if(p->val != q->val) return false;
        bool l=isSameTree(p->left,q->left);
        bool r=isSameTree(p->right,q->right);
        return (l&&r);
    }
};
```

##力扣[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

N叉树访问子结点的方法要记一下：

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if(root==nullptr) return 0;
        int maxdepth=0;
        for(auto child:root->children){
            maxdepth=max(maxDepth(child),maxdepth);
        }
        return maxdepth+1;
    }
};

//二叉树的
class solution {
public:
    int getdepth(treenode* node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxdepth(treenode* root) {
        return getdepth(root);
    }
};
```



- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）

## 力扣222 完全二叉树结点个数

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root==nullptr) return 0;
        return countNodes(root->left)+countNodes(root->right)+1;
    }
};


//利用完全二叉树特性的方法
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```





- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

![110.平衡二叉树2](https://img-blog.csdnimg.cn/20210203155515650.png)

因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）



## 力扣110 平衡二叉树

```cpp
class Solution {
public:
    bool flag=true;
    int getHeight(TreeNode*cur){
        if(cur==nullptr) return 0;
        int leftHeight=getHeight(cur->left);
        int rightHeight=getHeight(cur->right);
        if(abs(leftHeight-rightHeight)>1){
            flag=false;
        }
        return 1+max(leftHeight,rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        int height=getHeight(root);
        return flag;
    }
};
```



## ==力扣257 二叉树所有路径==

`to_string`函数的功能是将字符常量转化为字符串形式

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> paths;
        string path = "";
        traversal(root,path,paths);
        return paths;
    }
    void traversal(TreeNode* cur,string path,vector<string>& paths){
        if(cur!=nullptr) 
        {
            path += to_string(cur->val);
            if(cur->left==nullptr && cur->right==nullptr){
                paths.push_back(path);
            }
            else{
                path += "->";
                traversal(cur->left,path,paths);
                traversal(cur->right,path,paths);
            }
        }
    }
};
```



## 力扣404 左叶子之和

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int sum=0;
        if(root==nullptr) return 0;
        if(root->left!=nullptr && root->left->left==nullptr &&root->left->right==nullptr){
            sum+=root->left->val;
        }
        return sum+sumOfLeftLeaves(root->left)+sumOfLeftLeaves(root->right);
    }
};
```

## 力扣513 找树的左下角值

层序写法：

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        if(root!=nullptr) q.push(root);
        vector<vector<int>> result;
        while(!q.empty()){
            int size=q.size();
            vector<int> v;
            for(int i=0;i<size;i++){
                auto node=q.front();
                q.pop();
                v.push_back(node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            result.push_back(v);
        }
        return result[result.size()-1][0];
    }
};
```

递归：

```cpp
class Solution {
public:
    int result=0;
    int maxDepth=INT_MIN;
    void traversal(TreeNode* root,int depth){
        if(root->left==nullptr && root->right==nullptr){
            if(depth>maxDepth){
                maxDepth=depth;
                result=root->val;
            }
            return;
        }
        if(root->left) traversal(root->left,depth+1);
        if(root->right) traversal(root->right,depth+1);
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root,0);
        return result;
    }
};

//如果想找最后一个，就再if(depth>maxDepth)中加个等于号。
```

## 力扣112 路径总和

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        traversal(root,targetSum);
        return flag;
    }
    bool flag=false;
    void traversal(TreeNode* cur,int targetSum){
        if(cur==nullptr) return;
        else{
            targetSum-=cur->val;
            if(cur->left==nullptr && cur->right==nullptr && targetSum==0){
                flag=true;
            }
            traversal(cur->left,targetSum);
            traversal(cur->right,targetSum);
        }
    }
};
```

###力扣113 路劲2

```cpp
class Solution {
public:
    void dfs(TreeNode*root, int sum, vector<int> path)//需要回溯就不能加&
    {
        if (!root)
            return;
        sum -= root->val;
        path.push_back(root->val);
        if (!root->left && !root->right && sum == 0)
        {
            res.push_back(path);
            return;
        }
        dfs(root->left, sum, path);
        dfs(root->right, sum, path);
    }

    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {  
        dfs(root,targetSum,path);
        return res;
    }
};
```



路劲问题看这个：[一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析） - 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/)

## ==力扣[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)==

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size()==0 || inorder.size()==0) return nullptr;
        TreeNode* head=new TreeNode(preorder[0]);
        if(preorder.size()==1) return head;
        int index=0;
        for(int i=0;i<inorder.size();i++){
            if(inorder[i]==preorder[0]){
                index=i;
            }
        }
        vector<int> leftInorder (inorder.begin(),inorder.begin()+index);
        vector<int> rightInoder (inorder.begin()+index+1,inorder.end());
        vector<int> leftPreoder (preorder.begin()+1,preorder.begin()+1+leftInorder.size());
        vector<int> rightPreoder (preorder.begin()+1+leftInorder.size(),preorder.end());
        head->left = buildTree(leftPreoder,leftInorder);
        head->right = buildTree(rightPreoder,rightInoder);
        return head;
    }
};
```





## 力扣105[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```cpp
class Solution {
public:
    TreeNode* traversal (vector<int>& inorder, vector<int>& preorder) {
        if(preorder.size()==0||inorder.size()==0) return nullptr;
        int rootValue=preorder[0];
        TreeNode* root=new TreeNode(rootValue);
        if(preorder.size()==1) return root;
        int breakPoint;
        for(breakPoint=0;breakPoint<inorder.size();breakPoint++){
            if(inorder[breakPoint]==rootValue) break;
        }
        vector<int> leftInorder(inorder.begin(),inorder.begin()+breakPoint);
        vector<int> rightInorder(inorder.begin()+breakPoint+1,inorder.end());
        vector<int> leftpreorder(preorder.begin()+1,preorder.begin()+1+leftInorder.size());
        vector<int> rightpreorder(preorder.begin()+1+leftInorder.size(),preorder.end());
        root->left=traversal(leftInorder,leftpreorder);
        root->right=traversal(rightInorder,rightpreorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return traversal(inorder,preorder);
    }
};
```

### 力扣654最大二叉树

```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* node = new TreeNode(0);
        if (nums.size() == 1) {
            node->val = nums[0];
            return node;
        }
        int maxValue = 0;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        node->val = maxValue;
        if (maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
            node->left = constructMaximumBinaryTree(newVec);
        }
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }
        return node;
    }
};
```

### 力扣617 合并二叉树

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == nullptr) return root2;
        if (root2 == nullptr) return root1;
        TreeNode* root = new TreeNode(0);
        root->val = root1->val + root2->val;
        root->left = mergeTrees(root1->left, root2->left);
        root->right = mergeTrees(root1->right, root2->right);
        return root;
    }
};
```

##力扣700[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root==nullptr||root->val==val) return root;
        if(root->val>val) return searchBST(root->left,val);
        if(root->val<val) return searchBST(root->right,val);
        return nullptr;
    }
};
```



### 力扣[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
- 搜索树中不能有重复元素
- **用中序遍历出来的数组必须是递增的！！**

```cpp
class Solution {
public:
    vector<int> v;
    void traversal(TreeNode* root){
        if(root==nullptr) return;
        traversal(root->left);
        v.push_back(root->val);
        traversal(root->right);
    }
    bool isValidBST(TreeNode* root) {
        v.clear();
        traversal(root);
        for(int i=1;i<v.size();i++){
            if(v[i]<=v[i-1]) return false;
        }
        return true;
    }
};
```

###力扣[530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

还是转化为有序数组来做。

```cpp
class Solution {
public:
    vector<int>v;
    void traversal(TreeNode* root){
        if(root==nullptr) return;
        traversal(root->left);
        v.push_back(root->val);
        traversal(root->right);
        
    }
    int getMinimumDifference(TreeNode* root) {
        v.clear();
        traversal(root);
        if(v.size()<2) return 0;
        int result=INT_MAX;
        for(int i=1;i<v.size();i++){
            result=min(result,v[i]-v[i-1]);
        }
        return result;
    }
};


///用前向指针的方法：
class Solution {
public:
    int result=INT_MAX;
    TreeNode* pre=nullptr;
    void traversal(TreeNode* cur){
        if(cur==nullptr) return;
        traversal(cur->left);
        if(pre!=nullptr){
            result=min(result,abs(pre->val-cur->val));
        }
        pre=cur;
        traversal(cur->right);
    }
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```



###力扣501 二叉搜索树中的众数

sort中的比较函数compare要声明为**静态成员**函数或**全局**函数，不能作为普通成员函数，否则会报错。

因为：非静态成员（**non-static**）函数是**依赖于具体对象**的，而std::sort这类函数是全局的，因此无法再sort中调用非静态成员函数。**静态成员函数或者全局函数是不依赖于具体对象的**, 可以独立访问，无须创建任何对象实例就可以访问。

同时静态成员函数不可以调用类的非静态成员（因为非静态成员是依赖于对象的，有可能对象不存在，只有类存在，那就会出现错误）。

正常编译器一般来说就声明为main函数外面的全局函数，==在力扣中就声明为static，和对象无关的。==

这种写法即使不是二叉搜索树也可以这样写。

```cpp
class Solution {
public:
    unordered_map<int,int> mp;
    vector<int> result;
    void traversal(TreeNode* root){
        if(root==nullptr) return;
        traversal(root->left);
        mp[root->val]++;
        traversal(root->right);
    }
    bool static compare(const pair<int,int>&a,const pair<int,int>&b){
        return a.second>b.second;
    }
    vector<int> findMode(TreeNode* root) {
        traversal(root);
        vector<pair<int,int>> v(mp.begin(),mp.end());
        sort(v.begin(),v.end(),compare);
        result.push_back(v[0].first);
        for(int i=1;i<v.size();i++){
            if(v[i].second==v[0].second) result.push_back(v[i].first);
        }
        return result;
    }
};
```

前向指针的办法（针对BFS）

```cpp
class Solution {
public:
    int maxCount=0;
    int count=0;
    TreeNode* pre=nullptr;
    vector<int> result;
    void travesal(TreeNode * cur){
        if(cur==nullptr) return;
        travesal(cur->left);
        if(pre==nullptr) {
            count=1;
            result.push_back(cur->val);
        }
        else if(cur->val==pre->val) count++;
        else count=1;
        pre=cur;
        if(count==maxCount){
            result.push_back(cur->val);
        }
        if(count>maxCount){
            maxCount=count;
            result.clear();
            result.push_back(cur->val);
        }
        travesal(cur->right);
    }
    vector<int> findMode(TreeNode* root) {
        travesal(root);
        return result;
    }
};
```



## ==力扣236 二叉树的最近公共祖先==

![image-20221117162604365](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221117162604365.png)

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==q||root==p||root==nullptr) return root;
        TreeNode* left=lowestCommonAncestor(root->left,p,q);
        TreeNode* right=lowestCommonAncestor(root->right,p,q);
        if(left!=nullptr && right!=nullptr) return root;
        if(left!=nullptr && right==nullptr) return left;
        else if(left==nullptr && right!=nullptr) return right;
        else{
            return nullptr;
        }

    }
};
```

1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。
2. 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

### ==力扣235.二叉搜索树的最近公共祖先==

按照区间就可以

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return root;
        if(p->val>q->val) return lowestCommonAncestor(root,q,p);
        if(root->val>=p->val && root->val<=q->val) return root;
        if(root->val>q->val) return lowestCommonAncestor(root->left,p,q);
        else{
            return lowestCommonAncestor(root->right,p,q);
        } 
    }
};
```

## 力扣701.二叉搜索树中的插入

如果要递归地插入或者删除二叉树节点，递归函数一定要有返回值，而且返回值要被正确的接收

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root==nullptr) {
            TreeNode* node=new TreeNode(val);
            return node;
        }
        if(root->val>val) root->left = insertIntoBST(root->left,val);
        else{
            root->right=insertIntoBST(root->right,val);
        }
        return root;
    }
};
```

### ==力扣450 删除BST中的元素==

删除比插入和搜索都要复杂一些，分三种情况：

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了：



![img](https://labuladong.github.io/algo/images/BST/bst_deletion_case_1.png)



**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置：



![img](https://labuladong.github.io/algo/images/BST/bst_deletion_case_2.png)



**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到左子树中最大的那个节点或者右子树中最小的那个节点来接替自己，我的解法是用右子树中最小节点来替换：



![img](https://labuladong.github.io/algo/images/BST/bst_deletion_case_3.png)

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==nullptr) return nullptr;
        if(root->val==key){
            if(root->left==nullptr&&root->right==nullptr) return nullptr;
            if(root->left==nullptr) return root->right;
            if(root->right==nullptr) return root->left;
            //在右子树里面找最小值当作目前的根结点。
            TreeNode* minNode=root->right;
            while(minNode->left){
                minNode=minNode->left;
            }
            //删掉要挪上来的哪个节点
            root->right=deleteNode(root->right,minNode->val);
            minNode->left=root->left;
            minNode->right=root->right;
            return minNode;
        }

        else if(root->val>key){
            root->left=deleteNode(root->left,key);
        }
        else if(root->val<key){
            root->right=deleteNode(root->right,key);
        }
        return root;
    }
};
```

##力扣669 修减二叉搜索树

完全越界的直接把左/右子树摘掉，符合的就不动它，继续向下。

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root==nullptr) return nullptr;
        if(root->val<low) return trimBST(root->right,low,high);
        if(root->val>high) return trimBST(root->left,low,high);
        root->left=trimBST(root->left,low,high);
        root->right=trimBST(root->right,low,high);
        return root;
    }
};
```

## 力扣108. 将有序数组转换为二叉搜索树

```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& nums,int left, int right){
        if(left>right) return nullptr;
        int mid= (left+right)/2;
        TreeNode* root=new TreeNode(nums[mid]);
        root->left=traversal(nums,left,mid-1);
        root->right=traversal(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root=traversal(nums,0,nums.size()-1);
        return root;
    }
};
```

### 力扣109.[有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

转化为数组，无赖做法。

```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& nums,int left, int right){
        if(left>right) return nullptr;
        int mid= (left+right)/2;
        TreeNode* root=new TreeNode(nums[mid]);
        root->left=traversal(nums,left,mid-1);
        root->right=traversal(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        vector<int> v;
        while(head!=nullptr){
            v.push_back(head->val);
            head=head->next;
        }
        return traversal(v,0,v.size()-1);
    }
};
```

方法2：链表双指针，快慢指针取中间：

```cpp
class Solution {
public:
    TreeNode* buildTree(ListNode* head,ListNode* tail){
        if(head==tail) return nullptr;
        ListNode* slow=head,*fast=head;
        while(fast!=tail && fast->next!=tail){
            slow=slow->next;
            fast=fast->next->next;
        }
        TreeNode* root=new TreeNode(slow->val);
        root->left=buildTree(head,slow);
        root->right=buildTree(slow->next,tail);
        return root;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        return buildTree(head,nullptr);
    }
};
```

## ==力扣538 把二叉搜索树转换为累加树==

**其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，==求从后到前的累加数组==，也就是[20, 18, 13]，是不是感觉这就简单了。**

那么知道如何遍历这个二叉树，也就迎刃而解了，**从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**

反向中序遍历

```cpp
class Solution {
public:
    int pre=0;
    void traversal(TreeNode* cur){
        if(cur==nullptr) return;
        traversal(cur->right);
        cur->val+=pre;//中结点一直累加
        pre=cur->val;
        traversal(cur->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        traversal(root);
        return root;
    }
};
```



## 二叉树的知识点总结：

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png)













#8回溯算法

<img src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲" style="zoom: 33%;" />

## 回溯基础概念：

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。**回溯函数也就是递归函数，指的都是一个函数**。

回溯的本质是：穷举，穷举所有可能性

主要用在：排列、组合、棋盘、子集、切割等问题中。排列与组合的区别：==组合无序，排列有序。==

回溯算法能解决如下问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等

重点在于：**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

回溯函数起名：backtracking，返回值一般为void。

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

<img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础" style="zoom:67%;" />

以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```



## 组合问题：

![image-20221120110950414](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221120110950414.png)

###力扣77.组合

经典的回溯问题，横向是for循环，纵向是递归

<img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1" style="zoom:67%;" />

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n,int k,int start){
        if(path.size()==k){
            result.push_back(path);
            return;
        }
        //优化的：for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)，直接到有可能取满的最后一位为止就行。
        for(int i=start;i<=n;i++){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
};
```

### ==力扣40.组合总和Ⅱ==

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracing(vector<int>& candidates,int target,int start,int sum){
        if(sum>target) return;
        if(sum==target){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i=start;i<candidates.size();i++){
            if(uset.find(candidates[i])!=uset.end()){
                continue;
            }
            uset.insert(candidates[i]);
            sum+=candidates[i];
            path.push_back(candidates[i]);
            backtracing(candidates,target,i+1,sum);
            path.pop_back();
            sum-=candidates[i];
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtracing(candidates,target,0,0);
        return result;
    }
};
```





###==力扣[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)==

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(int k,int n,int start){
        if(n<0) return;
        if(path.size()==k && n==0){
            result.push_back(path);;
            return;
        }
        for(int i=start;i<10;i++){
            n-=i;
            path.push_back(i);
            backtracking(k,n,i+1);
            path.pop_back();
            n+=i;
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k,n,1);
        return result;
    }
};
```



### 力扣17[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

关键在于要创建自己的二维数组。方法要看！！！

```cpp
class Solution {
public:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
    string s;
    vector<string> result;
    void backtracking(string digits,int index){
        if(index==digits.size()) 
        {
            result.push_back(s);
            return;
        }
        int digit=digits[index]-'0';
        string letter=letterMap[digit];
        for(int i=0;i<letter.size();i++){
            s.push_back(letter[i]);
            backtracking(digits,index+1);
            s.pop_back();
        }

    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return result;
        backtracking(digits,0);
        return result;
    }
};
```

### 力扣39 组合总和

因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

**对于组合问题，什么时候需要startIndex呢？**

如果是一个集合来求组合的话，就需要startIndex，类似于77和216

多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，类似于17

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracing(vector<int>& candidates,int start,int target,int sum){
        if(sum>target) return;
        if(sum==target) result.push_back(path);
        for(int i=start;i<candidates.size()&&sum+candidates[i]<=target;i++){
            sum+=candidates[i];
            path.push_back(candidates[i]);
            backtracing(candidates,i,target,sum);
            sum-=candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracing(candidates,0,target,0);
        return result;
    }
};
```

## ==力扣131 分割回文串==

**其实切割问题类似组合问题**。

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。
- <img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串" style="zoom:67%;" />

```cpp
class Solution {
public:
    //x
    bool issamestring(const string s,int start,int end){
        for(int i=start,j=end;i<j;i++,j--){
            if(s[i]!=s[j]) return false;
        }
        return true;
    }
    vector<string> path;
    vector<vector<string>> result;
    void backtracing(string& s,int start){
        if(start>=s.size()){
            result.push_back(path);
            return;
        }
        for(int i=start;i<s.size();i++){
            if(issamestring(s,start,i)){
                string str=s.substr(start,i-start+1);
                path.push_back(str);
            }
            else{
                continue;
            }
            backtracing(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        backtracing(s,0);
        return result;
    }
};
```

1.终止条件是切完了，最后没元素了。

2.判断是时候，是回文子串才push进去，不是就之间continue。

###力扣93 复原IP地址

```cpp
class Solution {
public:
    vector<string> result;
    void backtracing(string& s,int start,int pointNum){
        if(pointNum==3){
            if(isValid(s,start,s.size()-1)){
                result.push_back(s);
            }
            return;
        }
        for(int i=start;i<s.size();i++){
            if(isValid(s,start,i)){
                s.insert(s.begin()+i+1,'.');
                pointNum++;
                backtracing(s,i+2,pointNum);
                pointNum--;
                s.erase(s.begin()+i+1);
            }
            else break;
        } 
    }

    bool isValid(const string&s,int start,int end){
        if(start>end) return false;
        if(s[start]=='0' && start!=end) return false;
        int num=0;
        for(int i=start;i<=end;i++){
            if(s[i]<'0' && s[i]>'9'){
                return false;
            }
            num=num*10+(s[i]-'0');
            if(num>255) return false;
        }
        return true;
    }

    vector<string> restoreIpAddresses(string s) {
        backtracing(s,0,0);
        return result;
    }
};
```

民间一个不错的算法：

```cpp
class Solution {
public:
    vector<string> res;
    vector<string> restoreIpAddresses(string s) {
        if(s.size() > 12) return res;
        
        string a, b, c, d;
        for(int i=1;i<=3;i++){     // 第一个数字 1~3位，下同
            if(i>=s.size()) continue;  
            for(int j=1;j<=3;j++){
                if(i+j>=s.size()) continue;
                for(int k=1;k<=3;k++){
                    if(i+j+k>=s.size()) continue;
                    for(int l=1;l<=3;l++){
                        if(i+j+k+l==s.size()){
                            a = string(s, 0, i);
                            b = string(s, i, j);
                            c = string(s, i+j, k);
                            d = string(s, i+j+k, l);
                            if((a.size() >=3 && a>"255") || (a.size()>1 && a[0]=='0')) continue;
                            if((b.size() >=3 && b>"255") || (b.size()>1 && b[0]=='0')) continue;
                            if((c.size() >=3 && c>"255") || (c.size()>1 && c[0]=='0')) continue;
                            if((d.size() >=3 && d>"255") || (d.size()>1 && d[0]=='0')) continue;
                            res.push_back( a + "." + b + "." + c + "." + d );
                        }

                    }
                }
            }
        }

        return res;
    }
};
```

## 力扣78 子集

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void bracktracking(vector<int>& nums,int start){
        if(start>nums.size()) return;
        for(int i=start;i<nums.size();i++){
            path.push_back(nums[i]);
            bracktracking(nums,i+1);
            path.pop_back();
        }
        result.push_back(path);
    } 
    vector<vector<int>> subsets(vector<int>& nums) {
        bracktracking(nums,0);
        return result;
    }
};
```

### 力扣90 子集Ⅱ

**剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要**。

==子集类的问题都要排序==

用示例中的[1, 2, 2] 来举例，如图所示： （**注意去重需要先对集合排序**）

![90.子集II](https://img-blog.csdnimg.cn/20201124195411977.png)

从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracing(vector<int>& nums,int start){
        result.push_back(path);
        for(int i=start;i<nums.size();i++){
            if(i>start&&nums[i]==nums[i-1]) continue;
            path.push_back(nums[i]);
            backtracing(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backtracing(nums,0);
        return result;
    }
};



//用set去重复，很不错：
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0);
        return result;
    }
};
```

用used数组去重

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
```

## ==力扣491 递增子序列==

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracing(vector<int>& nums,int start){
        if(start>nums.size()) return;
        unordered_set<int> uset;
        for(int i=start;i<nums.size();i++){
            if(uset.find(nums[i])!=uset.end() || !path.empty() && path.back()>nums[i]){
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracing(nums,i+1);
            path.pop_back();
        }
        if(path.size()>1) result.push_back(path);
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        //sort(nums.begin(),nums.end());
        backtracing(nums,0);
        return result;
    }
};
```



## 力扣46 全排列

 排列问题，去重，从0开始，不需要start

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        //.unordered_set<int> uset;
        for(int i=0;i<nums.size();i++){
            //if(uset.find(nums[i])!=uset.end()) continue;
            if(used[i]==true) continue;
            used[i]=true;
            path.push_back(nums[i]);
            backtracking(nums,used);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        backtracking(nums,used);
        return result;
    }
};
```

### ==力扣47 全排列Ⅱ==

**还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

```cpp
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过 
            // 如果同一树层nums[i - 1]使用过则直接跳过
```

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtrackint(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i=0;i<nums.size();i++){
            if(uset.find(nums[i])!=uset.end()) continue;
            if(used[i]==false){
                uset.insert(nums[i]);
                used[i]=true;
                path.push_back(nums[i]);
                backtrackint(nums,used);
                path.pop_back();
                used[i]=false;
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<bool> used(nums.size(),false);
        backtrackint(nums,used);
        return result;
    }
};
```

##有关回溯算法的时间复杂度问题

子集问题分析：

- 时间复杂度：O(n × 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：

- 时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`result.push_back(path)`），该操作的复杂度为O(n)。所以，最终时间复杂度为：n * n!，简化为O(n!)。
- 空间复杂度：O(n)，和子集问题同理。

组合问题分析：

- 时间复杂度：O(n × 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：O(n)，和子集问题同理。

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！**



##使用set去重和used数组去重的效率问题

需要注意的是：**使用set去重的版本相对于used数组的版本效率都要低很多**

主要是因为程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，而且insert的时候其底层的符号表也要做相应的扩充，也是费时的。

组合，子集，排列问题的空间复杂度都是O(n)，但如果使用set去重，空间复杂度就变成了O(n^2)，因为每一层递归都有一个set集合，系统栈空间是n，每一个空间都有set集合。

used数组可是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是O(n + n)，最终空间复杂度还是O(n)。

##力扣332.重新安排行程

两个map之间的嵌套映射，非常难

```cpp
class Solution {
private:
// unordered_map<出发机场, map<到达机场, 航班次数>> targets
unordered_map<string, map<string, int>> targets;
bool backtracking(int ticketNum, vector<string>& result) {
    if (result.size() == ticketNum + 1) {//票数肯定是比总机场数多1d
        return true;
    }
    for (auto& target : targets[result[result.size() - 1]]) {
        if (target.second > 0 ) { // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        }
    }
    return false;
}
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```

## 力扣51 N皇后

```cpp
class Solution {
public:
    bool isValid(int row,int col,vector<string>& chessboard,int n){
        for(int j=0;j<row;j++){
            if(chessboard[j][col]=='Q') return false;
        }
        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--){
            if(chessboard[i][j]=='Q') return false;
        }
        for(int i=row-1,j=col+1;i>=0 && j<=n;i--,j++){
            if(chessboard[i][j]=='Q') return false;
        }
        return true;
    }
    vector<vector<string>> result;
    void backtracing(int n,vector<string>& chessboard,int row){
        if(row==n){
            result.push_back(chessboard);
            return;
        }
        for(int i=0;i<n;i++){
            if(isValid(row,i,chessboard,n)){
                chessboard[row][i]='Q';
                backtracing(n,chessboard,row+1);
                chessboard[row][i]='.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n,string(n,'.'));
        backtracing(n,chessboard,0);
        return result;
    }
};
```

## ==力扣37.解数独==

要用二维遍历的方式求解！！多看看

```cpp
class Solution {
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] == '.') {
                for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;                // 放置k
                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                        board[i][j] = '.';              // 回溯，撤销k
                    }
                }
                return false;  // 9个数都试完了，都不行，那么就返回false 
            }                
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};

```



# 9.贪心算法

##贪心的基本概念

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**说实话贪心算法并没有固定的套路**。

所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

**不好意思，也没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

最好的方法就是举反例，如果反例没有的话，那就可以试试贪心。



贪心算法的解题步骤：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解



## 力扣455 分发饼干

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());//排序之后，从后往前比
        int g_size=g.size()-1;
        int s_size=s.size()-1;
        int count=0;
        while(g_size>=0){
            if(s_size>=0 && s[s_size]>=g[g_size]){
                s_size--;
                count++;
            }
            g_size--;
        }
        return count;
    }
};
```



### ==力扣376.摆动序列==

```cpp
class Solution {
public:
    //后一个减前一个，严格正负交替，为0也不行
    int wiggleMaxLength(vector<int>& nums) {
        int result=1;
        int cur=0;//记录当前差值
        int pre=0;//记录前一个差值
        if(nums.size()==1) return 1;
        for(int i=0;i<nums.size()-1;i++){
            cur=nums[i+1]-nums[i];
            if(cur>0 && pre<=0 || cur<0 && pre>=0){
                result++;
                pre=cur;
            }
        }
        return result;
    }
};
```



## 力扣53.最大子数组和

暴力会超时

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int size=nums.size();
        int max=INT_MIN;
        for(int i=0;i<size;i++){
            int sum=0;
            for(int j=i;j<size;j++){
                sum+=nums[j];
                if(sum>max){
                    max=sum;
                }
            }
        }
        return max;
    }
};
```



贪心

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max=INT_MIN;
        int sum=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
            if(sum>max) max=sum; //这两个if的位置不能调换，调换了会无法判断负数数组 
            if(sum<=0) sum=0;   
        }
        return max;
    }
};

```



## 力扣121.买卖股票的最佳时机

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minprice=INT_MAX;
        int maxprofit=0;
        //最小值不能定死，定死会导致后续有问题，比如[3,2,6,5,0,3]。
        /*for(int i=0;i<prices.size()-1;i++){
                if(prices[i]<minprice){
                    minprice=prices[i];
                    minpriceIndex=i;
                }
        }*/
        for(int price:prices){
            maxprofit=max(maxprofit,price-minprice);
            minprice=min(price,minprice);
        }
        return maxprofit;
    }
};


//暴力 会超时
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max=0;
        int sum=0;
        for(int i=0;i<prices.size();i++){
            for(int j=i+1;j<prices.size();j++){
                sum=prices[j]-prices[i];
                if(sum>max) max=sum;
            }
        }
        return max;
    }
};
```



### 力扣122.买卖股票的最佳时机Ⅱ

**如果想到其实最终利润是可以分解的，那么本题就很容易了！**

假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

把股票序列改成利润序列，那么这道题就是取利润数组中的正数和。

```cpp
class Solution {
public:

    int maxProfit(vector<int>& prices) {
        vector<int> profits;
        for(int i=0;i<prices.size()-1;i++){
            profits.push_back(prices[i+1]-prices[i]);
        }
        int maxprofit=0;
        for(int profit:profits){
            if(profit>=0) maxprofit+=profit;
        }
        return maxprofit;
    }
};
```





### 力扣714 买卖股票的最佳时机含手续费

如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。

此时无非就是要找到两个点，买入日期，和卖出日期。

- 买入日期：其实很好想，遇到更低点就记录一下。
- 卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。

所以我们在做收获利润操作的时候其实有三种情况：

- 情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。
- 情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。
- 情况三：不作操作，保持原有状态（买入，卖出，不买不卖）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int result = 0;
        int minPrice = prices[0]; // 记录最低价格
        for (int i = 1; i < prices.size(); i++) {
            // 情况二：相当于买入
            if (prices[i] < minPrice) minPrice = prices[i];

            // 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）
            if (prices[i] >= minPrice && prices[i] <= minPrice + fee) {
                continue;
            }

            // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
            if (prices[i] > minPrice + fee) {
                result += prices[i] - minPrice - fee;
                minPrice = prices[i] - fee; // 情况一，这一步很关键
            }
        }
        return result;
    }
};
```

从代码中可以看出对情况一的操作，因为如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，**所以要让minPrice = prices[i] - fee;，这样在明天收获利润的时候，才不会多减一次手续费！**







## 力扣55. 跳跃游戏

看覆盖范围

![55.跳跃游戏](https://img-blog.csdnimg.cn/20201124154758229.png)

i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。如果cover大于等于了终点下标，直接return true就可以了。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(find(nums.begin(),nums.end(),0)==nums.end() || nums.size()==1) return true;
        int cover=0;
        for(int i=0;i<=cover;i++){
            cover=max(cover,i+nums[i]);
            if(cover>=nums.size()-1) return true;
        }
        return false;
    }
};
```



### ==力扣45 跳跃游戏Ⅱ==

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点

这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时

- 如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
- 如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int curDistance = 0;    // 当前覆盖最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size(); i++) {
            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标
            if (i == curDistance) {                         // 遇到当前覆盖最远距离下标
                if (curDistance < nums.size() - 1) {       // 如果当前覆盖最远距离下标不是终点
                    ans++;                                  // 需要走下一步
                    curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）
                    if (nextDistance >= nums.size() - 1) break; // 下一步的覆盖范围已经可以达到终点，结束循环
                } else break;                               // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            }
        }
        return ans;
    }
};
```

##力扣1005.K次取反

```cpp
class Solution {
public:
    static bool cmp(int a,int b){
        return abs(a)>abs(b);
    }
    //按绝对值从大
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end(),cmp);
        for(int i=0;i<nums.size();i++){
            if(nums[i]<0 && k>0){
                nums[i] *= -1;
                k--;
            }
        }
        if(k%2==1) nums[nums.size()-1]*=-1;
        int maxSum=0;
        for(int num:nums) maxSum+=num;
        return maxSum;
    }
};
```



## ==力扣134 加油站==

可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。

每个加油站的剩余量rest[i]为gas[i] - cost[i]。

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。

![134.加油站](https://img-blog.csdnimg.cn/20201213162821958.png)

**那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置**。

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```



## ==力扣135 分发糖果==

这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。

**所以确定左孩子大于右孩子的情况一定要从后向前遍历！**

那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```



## 力扣860 柠檬水找零

这里的贪心就在于：面对20元找零时，优先用掉10元面额的

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five=0,ten=0,twenty=0;
        for(int bill:bills){
            if(bill==5) five++;
            if(bill==10) {
                if(five<=0) return false;
                ten++;
                five--;
            }
            if(bill==20){
                if(five>0&&ten>0){
                    five--;
                    ten--;
                    twenty++;
                }
                else if(five>=3){
                    five-=3;
                    twenty++;
                }
                else return false;
            }
        }
        return true;
    }
};
```

## ==406.根据身高建队列==

本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。**如果两个维度一起考虑一定会顾此失彼**。

那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。

**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**



也就是说，你先按照身高从大到小排好，排好之后你按照k的下标进行插入的话，前面的元素肯定都比你大，所以你的k值一定是正确的。

```cpp
class Solution {
public:
    static bool cmp(const vector<int>&a,const vector<int>&b){
        if(a[0]==b[0]) return a[1]<b[1];
        return a[0]>b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),cmp);
        vector<vector<int>> Queue{};
        for(int i=0;i<people.size();i++){
            int position=people[i][1];
            Queue.insert(Queue.begin()+position,people[i]);
        }
        return Queue;
    }
};
```

```cpp
int position=people[i][1];
Queue.insert(Queue.begin()+position,people[i]);
```

上面这两句插入时精髓！！



用链表完成很省时：

```cpp
class Solution {
public:
    static bool cmp(const vector<int>&a,const vector<int>&b){
        if(a[0]==b[0]) return a[1]<b[1];
        return a[0]>b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),cmp);
        list<vector<int>> Queue;
        for(int i=0;i<people.size();i++){
            int position=people[i][1];
            auto it=Queue.begin();
            while(position--){
                it++;
            }
            Queue.insert(it,people[i]);
        }
        return vector<vector<int>>(Queue.begin(),Queue.end());
    }
};
//节约insert的时间。
```



##力扣452用最少数量的箭引爆气球

先按照第一个下标从小到大排列好，然后比较边界

```cpp
class Solution {
public:
    static bool cmp(const vector<int>&a,const vector<int>&b){
        return a[0]<b[0];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),cmp);
        int result=1;
        for(int i=0;i<points.size()-1;i++){
            if(points[i][1]<points[i+1][0]){
                result++;
            }
            else{
                points[i+1][1]=min(points[i][1],points[i+1][1]);//更新重叠气球的最小y
            }
        }
        return result;
    }
};
```



###力扣435 无重叠区间

```cpp
class Solution {
public:
    static bool cmp(const vector<int>&a,const vector<int>&b){
        if(a[0]==b[0]) return a[1]<b[1];
        return a[0]<b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),cmp);
        int remove=0;
        if(intervals.size()==1) return 0;
        for(int i=0;i<intervals.size()-1;i++){
            if(intervals[i][1]>intervals[i+1][0]){
                remove++;
                intervals[i+1][1]=min(intervals[i][1],intervals[i+1][1]);
            }
        }
        return remove;
    }
};
```

右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。

![435.无重叠区间](https://img-blog.csdnimg.cn/20201221201553618.png)

```cpp
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1; 
        int end = intervals[0][1]; 
        for (int i = 1; i < intervals.size(); i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```



## 力扣763.划分字母区间

在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。

可以分为如下两步：

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

![763.划分字母区间](https://img-blog.csdnimg.cn/20201222191924417.png)

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> bound;
        for(int i=0;i<s.size();i++){
            int index=0;
            for(int j=i;j<s.size();j++){
                if(s[j]==s[i]) index=j;
            }
            bound.push_back(index);
        }
        vector<int> result;
        int maxbound=INT_MIN;
        int beginbound=0;
        for(int i=0;i<bound.size();i++){
            maxbound=max(bound[i],maxbound);
            if(i==maxbound){
                result.push_back(i+1-beginbound);
                beginbound=i+1;
                maxbound=INT_MIN;
            }
        }
        return result;
    }
};
```

随想录的写法：

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置
        for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置
            hash[S[i] - 'a'] = i;
        }
        vector<int> result;
        int left = 0;
        int right = 0;
        for (int i = 0; i < S.size(); i++) {
            right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界
            if (i == right) {
                result.push_back(right - left + 1);
                left = i + 1;
            }
        }
        return result;
    }
};
```



## ==力扣56合并区间==

对二维数组也可以sort：

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> tmp;
        for(int i=0;i<intervals.size();){
            int t=intervals[i][1];
            int j=i+1;
            while(j<intervals.size() && t>=intervals[j][0]){
                t=max(t,intervals[j][1]);
                j++;
            }
            tmp.push_back({intervals[i][0],t});
            i=j;
        }
        return tmp;
    }
};
```



最好把排序规则写清楚。

```cpp
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int n = intervals.size();
        vector<vector<int>> ans;

        sort(intervals.begin(),intervals.end(),cm);

        int left = intervals[0][0],right = intervals[0][1];
        for(int i = 1;i < n;i++)
        {
            int x = intervals[i][0],y = intervals[i][1];
            if(intervals[i][0] > right)
            {
                ans.push_back({left,right});
                left = x,right = y;
            }
            else
                left = min(x,left),right = max(y,right);
        }
        ans.push_back({left,right});
        return ans;
    }
};
```



## 力扣738.单调递增的数字

从后向前遍历字符串数字，如果后一位小于前一位，则让前一位-1，后一位变成9.而且从那一位开始后面的数都要变成9.

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum=to_string(n);
        int flag=strNum.size();
        for(int i=strNum.size()-1;i>0;i--){
            if(strNum[i]<strNum[i-1]){
                strNum[i]='9';
                flag=i;
                strNum[i-1]--;
            }
        }
        for(int i=flag;i<strNum.size();i++){
            strNum[i]='9';
        }
        return stoi(strNum);
    }
};
```



##==力扣968监控二叉树==

**所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**



- 0：该节点无覆盖
- 1：本节点有摄像头
- 2：本节点有覆盖



```cpp
// 版本一
class Solution {
private:
    int result;
    int traversal(TreeNode* cur) {

        // 空节点，该节点有覆盖
        if (cur == NULL) return 2;

        int left = traversal(cur->left);    // 左
        int right = traversal(cur->right);  // 右

        // 情况1
        // 左右节点都有覆盖
        if (left == 2 && right == 2) return 0;

        // 情况2
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left == 0 || right == 0) {
            result++;
            return 1;
        }

        // 情况3
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left == 1 || right == 1) return 2;

        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        // 这个 return -1 逻辑不会走到这里。
        return -1;
    }

public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        // 情况4
        if (traversal(root) == 0) { // root 无覆盖
            result++;
        }
        return result;
    }
};
```



# 10.动态规划

## 动态规划理论基础

动态规划，英文：Dynamic Programming，简称DP，==如果某一问题有很多重叠子问题，使用动态规划是最有效的。可以避免重复计算==

动态规划的每一种状态都是由上一个状态推导出来的，与贪心不同，贪心没有状态的推导，而是从局部直接选最优。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题



动态规划最重要的是**状态转移公式（递推公式）**的建立。



==动态规划题型的5个步骤：==

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

对于动态规划中debug最好的方法就是把dp数组打印出来，看看是不是按照自己的思路推导的就知道错在哪里。



## 力扣509 斐波那契数

递归做法：

```cpp
class Solution {
public:
    int fib(int n) {
        if(n==0||n==1) return n;
        return fib(n-1)+fib(n-2);
    }
};
//时间复杂度为O(2^n),空间复杂度为O(n)
```

**dp做法：**

动规五部曲：

这里我们要用一个一维dp数组来保存递归的结果

确定dp数组以及下标的含义

dp[i]的定义为：第i个数的斐波那契数值是dp[i]

确定递推公式

为什么这是一道非常简单的入门题目呢？

**因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

dp数组如何初始化

**题目中把如何初始化也直接给我们了，如下：**

```text
dp[0] = 0;
dp[1] = 1;
```

确定遍历顺序

从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

举例推导dp数组

按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

```cpp
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        vector<int> dp(n+1);
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};
```



## 力扣70 爬楼梯

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n<=2) return n;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};
```

在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

**其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1**。

### 力扣746. 使用最小花费爬楼梯

**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。

**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？

一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1,0);
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=cost.size();i++){
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.size()];
    }
};
```



## 力扣62.不同路径

按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

1. 确定递推公式

想要求dp[i][j]，只能有两个方向来推导出来，即`dp[i - 1][j] 和 dp[i][j - 1]。`

此时在回顾一下` dp[i - 1][j]` 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。

那么很自然，`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，`因为dp[i][j]只有这两个方向过来。

1. dp数组的初始化

如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。

所以初始化代码为：

<img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1" style="zoom:67%;" />

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m,vector<int>(n,0));
        for(int i=0;i<m;i++) dp[i][0]=1;
        for(int j=0;j<n;j++) dp[0][j]=1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

2. 使用数论的方法：

因为从`1*1-m*n`一共需要走m+n-2步。而向下肯定是走m-1步，所以这个问题变成了C（m+n-2） （m-1）的组合问题。



<img src="https://iknow-pic.cdn.bcebos.com/e61190ef76c6a7efd2fafab6f4faaf51f2de6645" alt="img" style="zoom:50%;" />

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return ans;
    }
};
```

![image-20221202095410783](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221202095410783.png)



### 力扣63 不同路径2

62中我们已经详细分析了没有障碍的情况，==有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。==

==对于第一排和第一列的情况，如果中间有一个障碍，那么后面的dp的值应该都为0，所以注意第一排和第一列的初始化。==

![image-20221202100256757](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221202100256757.png)

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        for(int i=0;i<m && obstacleGrid[i][0]==0;i++) dp[i][0]=1;
        for(int j=0;j<n && obstacleGrid[0][j]==0;j++) dp[0][j]=1;
        for(int i=1;i<m;i++) {
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==1) {
                    dp[i][j]=0;
                    continue;
                }
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

## ==力扣343 整数拆分==

这题的dp公式很难想。

动规法主要思想是：每一项都只由前一项决定，有点类似递归

这里的递推公式有点难想，先设dp[i]为分解i能得到的最大积

假如i = 5，可以将5分解为`1*4和2*3`，然后又有一个问题：要不要把`1*4`分解为`1*dp[4]`解决的办法就是两种情况都求，然后取最大值，即`max(1*4,1*dp[4])`

为了遍历到5的每一种分解方式，我们设一个循环，并通过循环把所有分解方式的最大值赋给dp[5]：

`for(j = 1; j < 5; ++j){
    dp[5] = max(dp[5], max(j*(5-j), j*dp[5-j]));
}`
外层的max取当前次循环的dp[5]与上一次循环的dp[5]的较大者，这样一次for下来便可求到所有分解情况下dp[5]的最大值

==有了上述基础，我们将5推广到i
即`dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));`==

i从3到n循环一次，便可一层层往上得到dp[n]

至于答案中的内层循环，条件为j < i-1，是因为j = i-1时对dp[1]分解毫无意义（题目要求k >= 2，而1无法分解为两个正整数相加）

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1,0);
        dp[2]=1;
        for(int i=3;i<=n;i++){
            for(int j=1;j<=i/2;j++){
                dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)));
            }
        }
        return dp[n];
    }
};
```

数学结论法：本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘，**但是这个结论需要数学证明其合理性！**

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n > 4) {
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```

##力扣96不同二叉搜索树

一般求个数就用dp。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int>dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                dp[i]+=dp[j]*dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

### ==力扣95 不同二叉树Ⅱ==

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    vector<TreeNode *> generateTrees(int n) {
        if (n) return generate(1, n);
        else return vector<TreeNode *>{};
    }
    
    vector<TreeNode *> generate(int left, int right) {
        vector<TreeNode *> ans;
        if (left > right) {
            ans.push_back(nullptr);
            return ans;
        }
        for (int i = left; i <= right; i++) {
            vector<TreeNode *> left_nodes = generate(left, i - 1);
            vector<TreeNode *> right_nodes = generate(i + 1, right);
            for (TreeNode *left_node : left_nodes) {
                for (TreeNode *right_node : right_nodes) {
                    TreeNode *t = new TreeNode(i);
                    t->left = left_node;
                    t->right = right_node;
                    ans.push_back(t);
                }
            }
        }
        return ans;
    }
};
```



## 动态规划中背包问题

![image-20221205103504595](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205103504595.png)

### 二维dp数组表示法

主要面试会考的是01背包和完全背包：

![image-20221204100007027](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204100007027.png)

1. 确定dp数组以及下标的含义

对于背包问题，有一种写法， 是使用二维数组，即`dp[i][j] `表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。==所以`dp[i][j]`代表的是价值，[i]代表的是目前放的物品个数（下标数），[j]代表的是目前背包总容量==

再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

那么可以有两个方向推出来dp[i][j]，

- **不放物品i**：`由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)`
- **放物品i**：`由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值`

所以递归公式：==` dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`==

首先从dp[i][j]的定义出发，如果背包容量j为0的话，即`dp[i][0]，`无论是选取哪些物品，背包价值总和一定为0。

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少

![动态规划-背包问题2](https://img-blog.csdnimg.cn/2021011010304192.png)

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

`dp[0][j]，`即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候`，dp[0][j] `应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，`dp[0][j]` 应该是value[0]，因为背包容量放足够放编号0物品。

```cpp
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```



遍历顺序：

先遍历物品在遍历背包重量

```cpp
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
ee
    }
}
```



完整代码：

```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}

```



### 滚动数组表示法

滚动数组了，就是把二维dp降为一维dp，例子还是和上面那个相同

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);**`

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。



新的一维的dp数组的

1. 确定dp数组的定义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

1. 一维dp数组的递推公式

dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

```cpp
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```



遍历顺序：

背包要从达到小遍历，保证物品i制备放入一次，如果一旦正序遍历了，那么物品0就会被重复加入多次！

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```



总测试代码：

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}
```

#背包问题的标准模板

![image-20221204132052771](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204132052771.png)

那么什么样的问题可以被称作为背包问题？换言之，我们拿到题目如何透过题目的不同包装形式看到里面背包问题的不变内核呢？
我对背包问题定义的理解：
给定一个背包容量target，再给定一个数组nums(物品)，能否按一定方式选取nums中的元素得到target
注意：
1、背包容量target和物品nums的类型可能是数，也可能是字符串
2、target可能题目已经给出(显式)，也可能是需要我们从题目的信息中挖掘出来(非显式)(常见的非显式target比如sum/2等)
3、选取方式有常见的一下几种：每个元素选一次/每个元素选多次/选元素进行排列组合
那么对应的背包问题就是下面我们要讲的背包分类

背包问题分类：
常见的背包类型主要有以下几种：
1、0/1背包问题：每个元素最多选取一次
2、完全背包问题：每个元素可以重复选择
3、组合背包问题：背包中的物品要考虑顺序
4、分组背包问题：不止一个背包，需要遍历每个背包

而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：
1、最值问题：要求最大值/最小值
2、存在问题：是否存在…………，满足…………
3、组合问题：求所有满足……的排列组合

因此把背包类型和问题类型结合起来就会出现以下细分的题目类型：
1、0/1背包最值问题
2、0/1背包存在问题
3、0/1背包组合问题
4、完全背包最值问题
5、完全背包存在问题
6、完全背包组合问题
7、分组背包最值问题
8、分组背包存在问题
9、分组背包组合问题
这九类问题我认为几乎可以涵盖力扣上所有的背包问题

**一位数组的解决方法：**

```cpp
void test_1_wei_bag_problem()
{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for (int i = 0; i < weight.size(); i++)
    { // 遍历物品
        for (int j = bagWeight; j >= weight[i]; j--)
        {                                                     // 遍历背包容量(一定要逆序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //不取或者取第i个
        }
    }
    cout << dp[bagWeight] << endl;
}
```

分类解题模板
背包问题大体的解题模板是两层循环，分别遍历物品nums和背包容量target，然后写转移方程，
根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法

首先是背包分类的模板：
1、0/1背包：外循环nums,内循环target,target倒序且target>=nums[i];
2、完全背包：外循环nums,内循环target,target正序且target>=nums[i];

然后是问题分类的模板：
1、最值问题: dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);
2、存在问题(bool)：dp[i]=dp[i]||dp[i-num];
3、组合问题：dp[i]+=dp[i-num];

可以参考模板哥：[一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现） - 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/)

#0-1背包系列问题

## 力扣416.分割等和子集

**给一个可装载重量为 `sum / 2` 的背包和 `N` 个物品，每个物品的重量为 `nums[i]`。现在让你装物品，是否存在一种装法，能够恰好将背包装满**？

这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了

和为奇数的时候就不可以得到两个相等的子集，因为两个集合相加肯定要是偶数。

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        if(sum%2==1) return false;
        int target=sum/2;
        vector<int> dp(target+1,0);
        for(int i=0;i<nums.size();i++){
            for(int j=target;j>=nums[i];j--){
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        if(dp[target]==target) return true;
        return false;
    }
};
```







## 力扣1049. 最后一块石头的重量Ⅱ

**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”

那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum=accumulate(stones.begin(),stones.end(),0);
        int target=sum/2;
        vector<int> dp(target+1,0);
        for(int i=0;i<stones.size();i++){
            for(int j=target;j>=stones[i];j--){
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-2*dp[target];
    }
};
```

### 力扣1049. 最后一块石头的重量

需要一直排序的默认使用大顶堆

```cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> pq;
        for(int stone:stones){
            pq.push(stone);
        }
        while(pq.size()>1){
            int a=pq.top();
            pq.pop();
            int b=pq.top();
            pq.pop();
            if(a>b) pq.push(a-b);
        }
        if(pq.empty()) return 0;
        return pq.top();
    }
};
```



## ==力扣494 目标和==

方法一：回溯，勉强能过

```cpp
class Solution {
public:
    int count=0;
    void backtracing(vector<int>& nums,int start_index,int target,int sum){
        if(start_index==nums.size()){
            if(sum==target){
                count++;
                return;
            }
        }
        else{
            backtracing(nums,start_index+1,target,sum+nums[start_index]);
            backtracing(nums,start_index+1,target,sum-nums[start_index]);
        }

    }
    int findTargetSumWays(vector<int>& nums, int target) {
        backtracing(nums,0,target,0);
        return count;
    }
};
```

方法二：动态规划01背包

如何转化为01背包问题呢。

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target

这里的X就代表的背包容量。

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(abs(target)>sum) return 0;
        if((target+sum)%2==1) return 0;
        int bagSize=(target+sum)/2;
        vector<int> dp(bagSize+1,0);
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=bagSize;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```



## ==力扣474. 1和0==

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int> (n+1,0));
        for(auto str:strs){
            int zeroNums=0, oneNums=0;
            for(auto c:str){
                if(c=='0') zeroNums++;
                else oneNums++;
            } 
            for(int i=m;i>=zeroNums;i--){
                for(int j=n;j>=oneNums;j--){
                    dp[i][j]=max(dp[i][j],dp[i-zeroNums][j-oneNums]+1);
                }
            }
        }
        return dp[m][n];
    }
};
```



# 完全背包系列

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。于0-1背包最主要的区别在于每件物品是不是可以无限次的拿取。

01背包和完全背包唯一不同就是体现在遍历顺序上

已知0-1背包的内层物品重量的循环是从后向前的，为了就是保证每个物品仅被添加一次，而完全背包的物品可以多次添加，所以内存要从小到大去遍历。**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

```cpp
for(int i=0;i<weight.size();i++){
    for(int j=weight[i];j<=bagweight;j++){
        dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
    }
}
```

对于纯的完全背包问题，两个for循环谁在前在后无所谓

先背包容量再物品的适合一定要做一个`j-weight[i]>0`的判断。

```cpp
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}
```

==但是具体问题中，要具体分析那个在前哪个在后==

##力扣518.零钱兑换Ⅱ

因为本题问的是组合数的总和的问题，不是单纯的和背包一样的总价值问题，所以遍历的内外层顺序是有所考究的。

如果先背包容量，再硬币值的话，每次两个硬币都会被拿出来，成了排列问题。

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1,0);
        dp[0]=1;
        for(int i=0;i<coins.size(3);i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
```

### 力扣322 零钱兑换

一般最小值的问题dp数组的初始化都要定义成一个比较大的值，判断条件`if (dp[j - coins[i]] != INT_MAX)`

考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<coins.size();i++){
            for(int j=coins[i];j<=amount;j++){
                if (dp[j - coins[i]] != INT_MAX){
                    dp[j]=min(dp[j],dp[j-coins[i]]+1);
                }
            }
        }
        if(dp[amount]==INT_MAX) return -1;
        return dp[amount];
    }
};
```



## ==力扣377.组合的总和Ⅳ（结合回溯1-3看看）==

本题是一个排列问题，排列问题的话先容量

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { 
            for (int j = 0; j < nums.size(); j++) { 
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```



## 力扣279 完全平方数

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, n+1);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) { 
            for (int j = i * i; j <= n; j++) { 
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```



## ==力扣139.单词拆分==

存在问题：一般都是定义成bool数组类型的dp

**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size()+1);
        dp[0]=true;
        for(int i=1;i<=s.size();i++){//先背包
            for(auto &word:wordDict){//后物体
                int sz=word.size();
                if(i-sz>=0 && s.substr(i-sz,sz)==word){
                    dp[i]=dp[i]||dp[i-sz];
                }
            }
        }
        return dp[s.size()];
    }
};
```



# 多重背包理论

多重背包，力扣上没有相应题目

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

其实多重背包就是0-1背包的一种扩充，每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

例如：

背包最大重量为10。

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

问背包能背的物品最大价值是多少？

和如下情况有区别么？

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。

多了一个for循环，把对应nums[i]的内容都push_back回去。

```cpp
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    for (int i = 0; i < nums.size(); i++) {
        while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }

    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;

}
int main() {
    test_multi_pack();
}
```



#背包问题总结：

![image-20221208084755921](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208084755921.png)



##力扣198.打家劫舍

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房。

递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        vector<int> dp(nums.size());
        dp[0]=nums[0];
        dp[1]=max(nums[0],nums[1]);
        //cout<<dp[0]<<dp[1]<<' ';
        for(int i=2;i<nums.size();i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.size()-1];
    }
};
```



### 力扣213 打家劫舍Ⅱ

对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

![213.打家劫舍II](https://img-blog.csdnimg.cn/20210129160748643.jpg)

- 情况二：考虑包含首元素，不包含尾元素

![213.打家劫舍II1](https://img-blog.csdnimg.cn/20210129160821374.jpg)

- 情况三：考虑包含尾元素，不包含首元素

![213.打家劫舍II2](https://img-blog.csdnimg.cn/20210129160842491.jpg)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int result1=robRange(nums,0,nums.size()-2);
        int result2=robRange(nums,1,nums.size()-1);
        //int result3=robRange(nums,1,nums.size()-2);
        //int maxresult=max(result1,result2);
       //maxresult=max(maxresult,result3);
        return max(result1,result2);
    }
    int robRange(vector<int>&nums,int l,int r){
        if(l==r) return nums[l];
        vector<int> dp(nums.size());
        dp[l]=nums[l];
        dp[l+1]=max(nums[l],nums[l+1]);
        for(int i=l+2;i<=r;i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[r];
    }
};
```



### ==力扣337 打家劫舍Ⅲ==

**本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算**

如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（**注意这里说的是“考虑”**）

利用树+哈希表的方法来做

```cpp
class Solution {
public:
    unordered_map<TreeNode* , int> umap;
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        if (umap[root]) return umap[root];
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); 
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); 
        int val2 = rob(root->left) + rob(root->right); 
        umap[root] = max(val1, val2); 
        return max(val1, val2);
    }
};
```



利用动态规划：

所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

**所以本题dp数组就是一个长度为2的数组！**

**在递归的过程中，系统栈会保存每一层递归的参数**。

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

#股票系列问题

## 力扣121 买卖股票的最佳时机

方法一：贪心

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minprice=INT_MAX;
        int maxprofit=0;
        for(auto price:prices){
            maxprofit=max(maxprofit,price-minprice);
            minprice=min(minprice,price);
        }
        return maxprofit;
    }
};
```



方法二：动态规划

`dp[i][0] `表示第i天持有股票所得最多现金 ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？**

其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。

`dp[i][1]` 表示第i天不持有股票所得最多现金

**注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态，持有不一定是当天买入**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.size();i++){
            dp[i][0]=max(dp[i-1][0],-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```

##力扣122 买卖股票的最佳时机Ⅱ

==个人而言这道题我还是最喜欢贪心==

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<int> profit;
        for(int i=1;i<prices.size();i++){
            profit.push_back(prices[i]-prices[i-1]);
        }
        int maxprofit=0;
        for(int i:profit){
            if(i>0) maxprofit+=i;
        }
        return maxprofit;
    }
};
```



dp公式的不同：

`dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]);
 dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);`

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.size();i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```



##力扣123 买卖股票的最佳时机Ⅲ

1. 确定dp数组以及下标的含义

一天一共就有五个状态，

1. 没有操作
2. 第一次买入
3. 第一次卖出
4. 第二次买入
5. 第二次卖出

`dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。`

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(5,0));
        //int choice=2;
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[0][2]=0;
        dp[0][3]=-prices[0];
        dp[0][4]=0;
        for(int i=1;i<prices.size();i++){
            dp[i][0]=dp[i-1][0];
            dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1]);
            dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2]);
            dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3]);
            dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4]);  
        }
        return dp[prices.size()-1][4];
    }
};
```



或者另外一种思路：

使用三维数组![image-20221211113604948](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211113604948.png)

![image-20221211113746184](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211113746184.png)

三维数组好绕：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][3][2];
        //把一开始的先定义好，第一天的，有没有交易的都可以确定
        for (int k = 0; k <= 2; k++) {
            dp[0][k][0] = 0;
            dp[0][k][1] = -prices[0];
        }
        for (int i = 1; i < n; i++) {
            dp[i][0][0] = 0;
            dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][0][0] - prices[i]);
            for (int k = 1; k <= 2; k++) {
                dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k - 1][1] + prices[i]);
                dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k][0] - prices[i]);
            }
        }
        return dp[n - 1][2][0];
    }
};
```



## 力扣188 买卖股票的最佳时机Ⅳ

使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

## 力扣309 买卖股票的最佳时机含冷冻期

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len=prices.size();
        vector<vector<int>> dp(len,vector<int>(2,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<len;i++){
            dp[i][0]=max(dp[i-1][0],((i-2)<0 ? 0 : dp[i-2][1])-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[len-1][1];
    }
};
```

## 力扣714 买卖股票的最佳时机含手续费

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n=prices.size();
        vector<vector<int>> dp(n,vector<int>(2,0));
        dp[0][0]=-prices[0]-fee;
        dp[0][1]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]-fee);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[n-1][1];
    }
};
```



# 子列问题

## ==力扣300 最长递增子序列==

**dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度**

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

**注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值**

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int result=0;
        if(nums.size()==1) return 1;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
            if(dp[i]>result) result=dp[i];
        }
        return result;
    }
};
```

## 力扣674. 最长连续递增序列

双指针：

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int len = nums.size();
        int res = 1;
        for (int i = 1, j = 0; i < len; i++){
            if (nums[i - 1] < nums[i] ){
                res = max(res,i - j + 1);   
            }else{
                j = i;
            }     
        }
        return res;
    }
};
```

动态规划：

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size()==1) return 1;
        vector<int> dp(nums.size(),1);
        int result=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]){
                dp[i]=dp[i-1]+1;
            }
            if(dp[i]>result) result=dp[i];
        }
        return result;
    }
};
```



## ==力扣718 最长重复子数组==（前缀数组）

本题的动态规划很难想：**关键在于找前置数组，从后往前比**

A 、B数组各抽出一个前缀数组，单看它们的末尾项，如果它们俩不一样，则公共子数组肯定不包括它们俩。
如果它们俩一样，则要考虑它们俩前面的子数组「能为它们俩提供多大的公共长度」。
如果它们俩的前缀数组的「末尾项」不相同，由于子数组的连续性，前缀数组不能为它们俩提供公共长度
如果它们俩的前缀数组的「末尾项」相同，则可以为它们俩提供公共长度：
至于提供多长的公共长度？这又取决于前缀数组的末尾项是否相同……
加上注释再讲一遍

![image-20221212112110344](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212112110344.png)

![image.png](https://pic.leetcode-cn.com/af2654586483ed87c39c123a1a4b68130f89581d13c46759a7207aae12429fdc-image.png)

![image-20221212112150750](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212112150750.png)

```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp (A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```



方法2：滑动窗口：



##==力扣1143. 最长公共子序列==（前缀数组）

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size()+1,vector<int>(text2.size()+1,0));
        int result=0;
        for(int i=1;i<=text1.size();i++){
            for(int j=1;j<=text2.size();j++){
                if(text1[i-1]==text2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
                if(dp[i][j]>result) result=dp[i][j];
            }
        }
        return result;
        //return dp[text1.size()][text2.size()];
    }
};
```

![image-20221213124359469](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213124359469.png)

## 力扣1035 不相交的线

绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且直线不能相交！

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。

其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）

这么分析完之后，大家可以发现：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1,0));
        int result=0;
        for(int i=1;i<=nums1.size();i++){
            for(int j=1;j<=nums2.size();j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
                if(dp[i][j]>result) result=dp[i][j];
            }
        }
        return  result;
    }
};
```

##力扣53 最大子数组和

这道题贪心可以做，也可以动态规划

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size()+1,0);
        dp[0]=nums[0];
        int result=dp[0];
        for(int i=1;i<nums.size();i++){
            dp[i]=max(dp[i-1]+nums[i],nums[i]);
            if(dp[i]>result) result=dp[i];
        }
        return result;
    }
};
```

## 力扣392.判断子序列

双指针法：

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i=0;
        int j=0;
        for(;i<s.size()&&j<t.size();){
            if(s[i]==t[j]) {
                i++;
            }
            j++;
        }
        return i==s.size();
    }
};
```

dp

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size()+1,vector<int>(t.size()+1,0));
        for(int i=1;i<=s.size();i++){
            for(int j=1;j<=t.size();j++){
                if(s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=dp[i][j-1];
            }
        }
        if(dp[s.size()][t.size()]==s.size()) return true;
        return false;
    }
};
```

## ==力扣115. 不同的子序列==(删除类问题)

**初始化**：

`从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][0] 和dp[0][j]是一定要初始化的。`

`dp[i`][0]表示什么呢？

`dp[i`][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

`那么dp[i][0]一定都是1`，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

`再来看dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。`

`那么dp[0][j]一定都是0，s如论如何也变成不了t。`

最后就要看一个特殊位置了，即：`dp[0][0] 应该是多少。`

`dp[0][0]应该是1，`空字符串s，可以删除0个元素，变成空字符串t。

**递推公式**：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221214142155045.png" alt="image-20221214142155045" style="zoom:50%;" />

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size()+1,vector<uint64_t>(t.size()+1,0));
        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;
        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;
        for(int i=1;i<=s.size();i++){
            for(int j=1;j<=t.size();j++){
                if(s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

![image-20221214142421043](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221214142421043.png)

所以：`uint64_t`相当于是longlongint的意思。



## 力扣583 两个字符串的删除操作

 ```cpp
 class Solution {
 public:
     int minDistance(string word1, string word2) {
         vector<vector<int>> dp(word1.size()+1,vector<int>(word2.size()+1,0));
         for(int i=0;i<=word1.size();i++) dp[i][0]=i;
         for(int j=0;j<=word2.size();j++) dp[0][j]=j;
         for(int i=1;i<=word1.size();i++){
             for(int j=1;j<=word2.size();j++){
                 if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                 else{
                     dp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+2});
                 }
             }
         }
         return dp[word1.size()][word2.size()];
     }
 };
 ```

或者和1143的反面，用总值-最长公共子序列的值

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1, vector<int>(word2.size()+1, 0));
        for (int i=1; i<=word1.size(); i++){
            for (int j=1; j<=word2.size(); j++){
                if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return word1.size()+word2.size()-dp[word1.size()][word2.size()]*2;
    }
};
```

##==力扣72 编辑距离==



![image-20221216171546821](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221216171546821.png)

![image-20221216171608437](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221216171608437.png)

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1,vector<int>(word2.size()+1,0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for(int i=1;i<=word1.size();i++){
            for(int j=1;j<=word2.size();j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```





## ==力扣647 回文子串==(动态规划方法看看)

回文子串问题都可以使用从中心向两端扩展的双指针解法：

==回文子串的复习：==

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int result=0;
        for(int i=0;i<s.size();i++){
            result+=count(s,i,i,s.size());
            result+=count(s,i,i+1,s.size());
        }
        return result;
    }
    int count(const string&s, int i,int j,int len){
        int result=0;
        while(i>=0 && j<len && s[i]==s[j]){
            i--;
            j++;
            result++;
        }
        return result;
    }
};
```



动态规划做法：

**所以一定要从下到上，从左到右遍历，这样保证`dp[i + 1][j - 1]`都是经过计算的**。

在确定递推公式时，就要分析如下几种情况。

整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。

当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

- 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
- 情况二：下标i 与 j相差为1，例如aa，也是回文子串
- 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {  
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { 
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { 
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```

![image-20221216165515317](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221216165515317.png)

### ==力扣516 最长回文子序列==

**回文子串是要连续的，回文子序列可不是连续的！** 回文子串，回文子序列都是动态规划经典题目。

**`dp[i][j]`：字符串s在[i, j]范围内最长的回文子序列的长度为`dp[i][j]`**。

![516.最长回文子序列](https://img-blog.csdnimg.cn/20210127151350563.jpg)

![516.最长回文子序列1](https://img-blog.csdnimg.cn/20210127151420476.jpg)

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i+1;j<s.size();j++){
                if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2;
                else{
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][s.size()-1];
    }
};
```

![image-20221216165802537](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221216165802537.png)

==回文子串类型的遍历都需要从下到上，从左到右==

![image-20221216165944500](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221216165944500.png)

![516.最长回文子序列2](https://img-blog.csdnimg.cn/20210127151452993.jpg)



# 11 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。

==一维数组，找左边或者右边第一个比自己大或小的元素。时间复杂度为O(n)。==

单调栈的**本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，**优点是只需要遍历一次**。

单调栈里面存放的是元素的下标i，

**按照栈头到栈底的顺序**：递增.因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。

使用单调栈主要有三个判断条件。

- 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

## 力扣739 每日温度

暴力：会超时

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> answer;
        for(int i=0;i<temperatures.size();i++){
            int count=0;
            for(int j=i+1;j<temperatures.size();j++){
                if(temperatures[j]<=temperatures[i]){
                    count++;
                    if(j==temperatures.size()-1){ 
                        count=0;
                        break;
                    }
                }
                else{
                    count++;
                    break;
                }
            }
            answer.push_back(count);
        }
        return answer;
    }
};
```

单调栈做法：

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> answer(temperatures.size(),0);
        stack<int> st;
        st.push(0);
        for(int i=1;i<temperatures.size();i++){
            if(temperatures[i]<=temperatures[st.top()]) st.push(i);
            else{
                while(!st.empty() && temperatures[i]>temperatures[st.top()]){
                    answer[st.top()]=i-st.top();
                    st.pop();
                }
            }
            st.push(i);
        }
        return answer;
    }
};

//精简版：
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        stack<int> st; 
        vector<int> result(T.size(), 0);
        for (int i = 0; i < T.size(); i++) {
            while (!st.empty() && T[i] > T[st.top()]) { 
                result[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);

        }
        return result;
    }
};
```

## ==力扣496.下一个更大元素Ⅰ==

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下标元素，value：下标
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 力扣503. 下一个更大元素Ⅱ

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(),-1);
        stack<int> st;
        if(nums.size()==1) return result;
        st.push(0);
        for(int i=0;i<nums.size()*2;i++){
            if(nums[i % nums.size()]<=nums[st.top()]) st.push(i%nums.size());
            else{
                while(!st.empty() && nums[i%nums.size()]>nums[st.top()]){
                    result[st.top()]=nums[i%nums.size()];
                    st.pop();
                }
                st.push(i%nums.size());
            }
        }
        return result;
    }
};
```



两个数组拼接方法：

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> nums1(nums.begin(),nums.end());
        nums.insert(nums.end(),nums1.begin(),nums1.end());
        vector<int> result(nums.size(),-1);
        stack <int> st;
        st.push(0);
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[st.top()]) st.push(i);
            else{
                while(!st.empty() && nums[i]>nums[st.top()]){
                    result[st.top()]=nums[i];
                    st.pop();
                }
            }
            st.push(i);
        }
        vector<int> result1(result.begin(),result.begin()+nums1.size());
        return result1;
    }
};
```

## ==力扣42 接雨水==

方法1.双指针：

**每一列的雨水数目=左右最高列中的小值-自身的列高(力扣会超时)**

时间复杂度为O(n^2)。 空间复杂度为O(1)。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int result=0;
        for(int i=0;i<height.size();i++){
            if (i == 0 || i == height.size() - 1) continue;
            int lHeight=height[i];
            int rHeight=height[i];
            for(int j=i-1;j>=0;j--){
                if(height[j]>lHeight) lHeight=height[j];
            }
            for(int k=i+1;k<height.size();k++){
                if(height[k]>rHeight) rHeight=height[k];
            }
            int h=min(lHeight,rHeight)-height[i];
            if(h>0) result+=h;
        }
        return result;
    }
};
```

方法2：动态规划

为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。

当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。

即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

这样就找到递推公式。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()<=2) return 0;
        int result=0;
        vector<int> left(height.size(),0);
        vector<int> right(height.size(),0);
        left[0]=height[0];
        for(int i=1;i<height.size();i++){
            left[i]=max(height[i],left[i-1]);
        }
        //从右往左初始化
        right[height.size()-1]=height[height.size()-1];
        for(int j=height.size()-2;j>=0;j--){
            right[j]=max(height[j],right[j+1]);
        }
        for(int i = 0; i < height.size(); i++){
            int h=min(left[i],right[i])-height[i];
            if(h>0) result+=h;
        }
        return result;
    }
};
```

方法三.单调栈

1. 首先单调栈是按照行方向来计算雨水，如图：

![42.接雨水2](https://img-blog.csdnimg.cn/20210223092629946.png)

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()<=2) return 0;
        stack<int> st;
        st.push(0);
        int result=0;
        for(int i=1;i<height.size();i++){
            if(height[i]<height[st.top()]) st.push(i);
            else if(height[i]==height[st.top()]){
                st.pop();
                st.push(i);
            }
            else{
                while(!st.empty() && height[i]>height[st.top()]){
                    int mid=height[st.top()];
                    st.pop();
                    if(!st.empty()){
                        int h=min(height[st.top()],height[i])-mid;
                        int w=i-st.top()-1;
                        result+=h*w;
                    }
                }
            }
            st.push(i);
        }
        return result;
    }
};
```

### ==力扣84. 柱状图中的最大矩形（要从小到大排）==

核心思路就是找到向左向右的

**这里就涉及到了单调栈很重要的性质，就是单调栈里的顺序，是从小到大还是从大到小**。

在题解[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)中我讲解了接雨水的单调栈从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。

那么因为本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！

我来举一个例子，如图：

![84.柱状图中最大的矩形](https://img-blog.csdnimg.cn/20210223155303971.jpg)

只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。

所以本题单调栈的顺序正好与接雨水反过来。

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        heights.insert(heights.begin(), 0); 
        heights.push_back(0); 
        st.push(0);
        int result = 0;
        for (int i = 1; i < heights.size(); i++) {
            if (heights[i] > heights[st.top()]) {
                st.push(i);
            } else if (heights[i] == heights[st.top()]) {
                st.pop(); 
                st.push(i);
            } else {
                while (!st.empty() &&heights[i] < heights[st.top()]) { 
                    int mid = st.top();
                    st.pop();
                    int left = st.top();
                    int right = i;
                    int w = right - left - 1;
                    int h = heights[mid];
                    result = max(result, w * h);
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

**但是如果输入是递增的话，这个代码最后都无法弹出计算面积。需要在Heights数组的后面再加上一个0，**所以递增的最后要加个0



==接雨水和柱状图分别是两题单调递增栈和单调递减栈的典型，要多看看==



# 12.补充题目

## 数组

###==力扣1365 有多少小于当前数字的数字==

为了覆盖相同的数，要从后向前创建哈希表。

==排序之后如何再建立映射关系的经典题目==

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        vector<int> result=nums;
        sort(result.begin(),result.end());
        unordered_map<int,int> mp;
        for(int i=result.size()-1;i>=0;i--){
            mp[result[i]]=i;
        }
        for(int i=0;i<nums.size();i++){
            result[i]=mp[nums[i]];
        }
        return result;
    }
};
```

###力扣941. 有效山脉数组

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if(arr.size()<=2) return false;
        int maxValue=0;
        int index=0;
        for(int i=0;i<arr.size();i++){
            if(arr[i]>maxValue) {
                maxValue=arr[i];
                index=i;
            }
        }
        if(index==arr.size()-1 || index==0) return false;
        for(int i=1;i<=index;i++){
            if(arr[i]<=arr[i-1]) return false;
        }
        for(int j=index+1;j<arr.size();j++){
            if(arr[j]>=arr[j-1]) return false;
        }
        return true;
    }
};


//双指针法：
class Solution {
public:
    bool validMountainArray(vector<int>& A) {
        if (A.size() < 3) return false;
        int left = 0;
        int right = A.size() - 1;
        while (left < A.size() - 1 && A[left] < A[left + 1]) left++;
        while (right > 0 && A[right] < A[right - 1]) right--;
        if (left == right && left != 0 && right != A.size() - 1) return true;
        return false;
    }
};
```



### 力扣1207.独一无二的出现次数

![image-20221220104302126](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220104302126.png)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int,int> mp;
        for(auto &i:arr) mp[i]++;
        unordered_set<int> time;
        for(const auto &p:mp){
            time.insert(p.second);
        }
        return time.size()==mp.size();
    }
};
```

### 力扣 283.移动零

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left=0,right=0;
        while(right<nums.size()){
            if(nums[right]!=0){
                nums[left]=nums[right];
                left++;
            }
            right++;
        }
        for(int j=left;j<nums.size();j++){
            nums[j]=0;
        }
    }
};
```

### 力扣189.轮状数组

空间复杂度为O（n）

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(nums.size()==1) nums=nums;
        else{
            k=k%nums.size();
            int n=nums.size()-k;
            vector<int>result(nums.begin()+n,nums.end());
            for(int i=0;i<n;i++){
                result.push_back(nums[i]);
            }
            nums=result;
        }
    }
};
```

空间复杂度为O（1）：

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());

    }
};
```

![image-20221221110458239](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221221110458239.png)

### 力扣724.寻找数组的中心下标

1. 遍历一遍求出总和sum
2. 遍历第二遍求中心索引左半和leftSum
   - 同时根据sum和leftSum 计算中心索引右半和rightSum
   - 判断leftSum和rightSum是否相同

不能i从1开始0.0

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) sum += num; 
        int leftSum = 0; 
        int rightSum = 0; 
        for (int i = 0; i < nums.size(); i++) {
            leftSum += nums[i];
            rightSum = sum - leftSum + nums[i];
            if (leftSum == rightSum) return i;
        }
        return -1;
    }
};
```

###==力扣34 在排序数组中查找元素的第一个和最后一个位置==

 二分的左右边界问题

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        return {leftBound(nums,target),rightBound(nums,target)};
    }
    int leftBound(vector<int>& nums, int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int middle=left+(right-left)/2;
            if(nums[middle]<target) left=middle+1;
            else if(nums[middle]>=target) right=middle-1;
        }
        if(left>=nums.size() || nums[left]!=target){
            return -1;
        }
        return left;
    }
    int rightBound(vector<int>& nums, int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int middle=left+(right-left)/2;
            if(nums[middle]<=target) left=middle+1;
            else if(nums[middle]>target) right=middle-1;
        }
        if(right<0 || nums[right]!=target){
            return -1;
        }
        return right;
    }
};
```

###力扣922 按奇偶排序的数组

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        vector<int> even(A.size() / 2); 
        vector<int> odd(A.size() / 2);
        vector<int> result(A.size());
        int evenIndex = 0;
        int oddIndex = 0;
        int resultIndex = 0;
        for (int i = 0; i < A.size(); i++) {
            if (A[i] % 2 == 0) even[evenIndex++] = A[i];
            else odd[oddIndex++] = A[i];
        }
        for (int i = 0; i < evenIndex; i++) {
            result[resultIndex++] = even[i];
            result[resultIndex++] = odd[i];
        }
        return result;
    }
};
```

空间复杂度为1的算法：

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int k=0;
        vector<int> result(nums.size(),0);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                result[k]=nums[i];
                k+=2;
            }
        }
        int m=1;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==1){
                result[m]=nums[i];
                m+=2;
            }
        }
        return result;
    }
};
```



## 链表

### 力扣24 两两交换链表中节点

1.先设置虚拟头节点

2.在while循环内部定义两个预先变量

3. ListNode* dummyHead=new ListNode(-1);

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead=new ListNode(-1);
        dummyHead->next=head;
        ListNode* cur=dummyHead;
        while(cur->next!=nullptr && cur->next->next!=nullptr){
            ListNode* tmp1=cur->next;
            ListNode* tmp2=cur->next->next->next;
            cur->next=cur->next->next;
            cur->next->next=tmp1;
            cur->next->next->next=tmp2;
            cur=cur->next->next;
        }
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```



### ==力扣234 回文链表==

方法1.把链表转化为数组，然后对数组进行双指针判断

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> v;
        ListNode* cur=head;
        while(cur){
            v.push_back(cur->val);
            cur=cur->next;
        }
        for(int i=0,j=v.size()-1;i<j;i++,j--){
            if(v[i]!=v[j]) return false;
        }
        return true;
    }
};
```

方法2.反转后半部分链表

![img](https://code-thinking.cdn.bcebos.com/pics/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.png)

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head==nullptr || head->next==nullptr) return true;
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* pre = head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast=fast->next->next;
            pre=slow;
            slow=slow->next;
        }
        pre->next=nullptr;
        ListNode* cur1=head;
        ListNode* cur2=reverseList(slow);
        while(cur1){
            if(cur1->val!=cur2->val) return false;
            cur1=cur1->next;
            cur2=cur2->next;
        }
        return true;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* temp; 
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while(cur) {
            temp = cur->next;  
            cur->next = pre; 
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```

### ==力扣143 重排链表==

感觉转化成数组都好一点

方法1.变成数组

直接把结点放到数组中，然后奇数取前面，偶数取后面

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* cur = head;
        if (cur == nullptr) return;
        while(cur != nullptr) {
            vec.push_back(cur);
            cur = cur->next;
        }
        cur = head;
        int i = 1;
        int j = vec.size() - 1;  
        int count = 0; 
        while (i <= j) {
            if (count % 2 == 0) {
                cur->next = vec[j];
                j--;
            } else {
                cur->next = vec[i];
                i++;
            }
            cur = cur->next;
            count++;
        }
        cur->next = nullptr; 
    }
};
```



方法二：链表一分为二，然后两个链表拼成一个链表，细节很多，难度较大

```cpp
class Solution {
private:
    // 反转链表
    ListNode* reverseList(ListNode* head) {
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) {
            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur->next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        }
        return pre;
    }

public:
    void reorderList(ListNode* head) {
        if (head == nullptr) return;
        // 使用快慢指针法，将链表分成长度均等的两个链表head1和head2
        // 如果总链表长度为奇数，则head1相对head2多一个节点
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        ListNode* head1 = head;
        ListNode* head2;
        head2 = slow->next;
        slow->next = nullptr;

        // 对head2进行翻转
        head2 = reverseList(head2);

        // 将head1和head2交替生成新的链表head
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        ListNode* cur = head;
        cur1 = cur1->next;
        int count = 0; // 偶数取head2的元素，奇数取head1的元素
        while (cur1 && cur2) {
            if (count % 2 == 0) {
                cur->next = cur2;
                cur2 = cur2->next;
            } else {
                cur->next = cur1;
                cur1 = cur1->next;
            }
            count++;
            cur = cur->next;
        }
        if (cur2 != nullptr) { // 处理结尾
            cur->next = cur2;
        }
        if (cur1 != nullptr) {
            cur->next = cur1;
        }
    }
};
```



### 力扣141 环形链表

环形链表的判断主要就是利用快慢指针，如果指针相遇了，就说明有环

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(slow==fast){
                return true;
            }
        }   
        return false; 
    }
};
```

### 力扣142 环形链表Ⅱ

结论：==从头节点和相遇结点出发，没步一个指针，那么两个指针相遇时就是环的入口结点。==

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        ListNode* cur=head;
        while(fast!=nullptr && fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next->next;
            if(fast==slow){
                while(fast!=cur){
                    fast=fast->next;
                    cur=cur->next;
                }
                return cur;
            }
        }
        return nullptr;
    }
};
```

![image-20221223204016164](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221223204016164.png)

### 力扣160. 相交链表

两种方法，让不同长度的链表同一时间到达相交链表

1.把两条链表拼在一起![img](https://labuladong.github.io/algo/images/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/6.jpeg)

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* cur1=headA;
        ListNode* cur2=headB;
        while(cur1!=cur2){
            if(cur1==nullptr) cur1=headB;
            else cur1=cur1->next;
            if(cur2==nullptr) cur2=headA;
            else cur2=cur2->next;
        }
        return cur1;
    }
};
```

##哈希表

### ==力扣205 同构字符串==

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char,char> map1;
        unordered_map<char,char> map2;
        for (int i = 0, j = 0; i < s.size(); i++, j++) {
            if (map1.find(s[i]) == map1.end()) { 
                map1[s[i]] = t[j];
            }
            if (map2.find(t[j]) == map2.end()) {
                map2[t[j]] = s[i];
            }
            if (map1[s[i]] != t[j] || map2[t[j]] != s[i]) {
                return false;
            }
        }
        return true;
    }
};
```

### ==力扣1002 查找共用字符==

```cpp
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        int count[26];//记录出现最小次数
        for(int i=0;i<26;i++) count[i]=101;
        for(int i=0;i<words.size();i++){
            int tmp[26]={0};
            for(int j=0;j<words[i].size();j++){
                tmp[words[i][j]-'a']++;
            }
            for(int k=0;k<26;k++){
                count[k]=min(tmp[k],count[k]);
            }
        }
        vector<string> result;
        for(int i=0;i<26;i++){
            if(count[i]){
                for(int j=0;j<count[i];j++){
                    string str;
                    str.push_back('a'+i);
                    result.push_back(str);
                }
            }
        }
        return result;
    }
};
```



## 字符串

### 力扣925. 长按键入

- name[i] 和 typed[j]相同，则i++，j++ （继续向后对比）
- name[i] 和 typed[j]不相同
  - 看是不是第一位就不相同了，也就是j如果等于0，那么直接返回false
  - 不是第一位不相同，就让j跨越重复项，移动到重复项之后的位置，再次比较name[i] 和typed[j]
    - 如果 name[i] 和 typed[j]相同，则i++，j++ （继续向后对比）
    - 不相同，返回false
- 对比完之后有两种情况
  - name没有匹配完，例如name:"pyplrzzzzdsfa" type:"ppyypllr"
  - type没有匹配完，例如name:"alex" type:"alexxrrrrssda"

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i=0,j=0;
        while(i<name.size() && j<typed.size()){
            if(name[i]==typed[j]) {
                i++;
                j++;
            }
            else{
                if(j==0) return false;
                while(j<typed.size() && typed[j]==typed[j-1]) j++;
                if(name[i]==typed[j]){
                    i++;
                    j++;
                }
                else{
                    return false;
                }
            }
        }
        if(i<name.size()) return false;
        while(j<typed.size()){
            if(typed[j]==typed[j-1]) j++;
            else return false;
        }
        return true;
    }
};
```

### 力扣844. 比较含退格的字符串

字符串本身就可以当成是一个vector，可以push_back()，也可以pop_back()

```cpp
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        string s1,t1;
        for(auto i:s){
            if(i!='#') s1.push_back(i);
            else{
                if(!s1.empty()){
                    s1.pop_back();
                }
            }
        }
        for(auto i:t){
            if(i!='#') t1.push_back(i);
            else{
                if(!t1.empty()){
                    t1.pop_back();
                }
            }
        }
        return s1==t1;
    }
};
```



## 二叉树

### 力扣129. 求根节点到叶节点数字之和

```cpp
class Solution {
public:
    int result=0;
    vector<int> path;
    int vectorToInt(vector<int>& vec){
        int sum=0;
        for(int i=0;i<vec.size();i++){
            sum=sum*10+vec[i];
        }
        return sum;
    }
    void traversal(TreeNode* cur){
        if(cur->left==nullptr && cur->right==nullptr){
            result+=vectorToInt(path);
            return;
        }
        if(cur->left){
            path.push_back(cur->left->val);
            traversal(cur->left);
            path.pop_back();
        }
        if(cur->right){
            path.push_back(cur->right->val);
            traversal(cur->right);
            path.pop_back();
        }
        return;
    }
    int sumNumbers(TreeNode* root) {
        if (root==nullptr) return 0;
        path.push_back(root->val);
        traversal(root);
        return result;
    }
};




//方法2
class Solution {
public:
    int ans = 0;
    int sumNumbers(TreeNode* root) {
        dfs(root,0);
        return ans;
    }
    void dfs(TreeNode *root,int path){
        path = path * 10 + root->val;
        if(!root->left && !root->right) ans += path;
        if(root->right) dfs(root->right,path);
        if(root->left) dfs(root->left,path);
    }
};
```



### 力扣1382 将二叉树变为平衡

这道题目，可以中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。

```cpp
class Solution {
public:
    vector<int> vec;
    void traversal(TreeNode* cur){
        if(cur==nullptr) return;
        traversal(cur->left);
        vec.push_back(cur->val);
        traversal(cur->right);
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size()==0) return nullptr;
        int left=0,right=nums.size()-1;
        int mid=(left+right)/2;
        TreeNode* root=new TreeNode(nums[mid]);
        vector<int>leftTree (nums.begin(),nums.begin()+mid);
        vector<int>rightTree (nums.begin()+mid+1,nums.end());
        root->left=sortedArrayToBST(leftTree);
        root->right=sortedArrayToBST(rightTree);
        return root;
    }
    TreeNode* balanceBST(TreeNode* root) {
        traversal(root);
        return sortedArrayToBST(vec);
    }
};
```



### 力扣100 相同的树

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr && q==nullptr) return true;
        else if(p==nullptr && q!=nullptr) return false;
        else if(p!=nullptr && q==nullptr) return false;
        else if(p->val!=q->val) return false;

        bool leftTree=isSameTree(p->left,q->left);
        bool rightTree=isSameTree(p->right,q->right);
        return leftTree&&rightTree;
    }
};
```

### ==力扣101 对称二叉树==

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return compare(root->left,root->right);
    }
    bool compare(TreeNode* left,TreeNode* right){
        if(left==nullptr && right==nullptr) return true;
        else if(left==nullptr && right != nullptr) return false;
        else if(right==nullptr && left != nullptr) return false;
        else if(right->val != left->val) return false;
        bool outside = compare(left->left,right->right);
        bool inside = compare(left->right,right->left);
        return (outside&&inside);
    }
};
```



### 二叉树的层序遍历

两个注意点：

- 要用一个队列实现
- size每次都要固定

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            vector<int> v;
            for(int i=0;i<size;i++){
                TreeNode* cur=que.front();
                que.pop();
                v.push_back(cur->val);
                if(cur->left!=nullptr) que.push(cur->left);
                if(cur->right!=nullptr) que.push(cur->right);
            }
            result.push_back(v);
        }
        return result;
    }
};
```



###力扣116填充每个节点的下一个右侧节点指针

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if(root!=nullptr) q.push(root);
        while(!q.empty()){
            int size=q.size();
            for(int i=0;i<size;i++){
                Node* cur=q.front();
                q.pop();
                if(i!=size-1) cur->next=q.front();
                else{
                    cur->next=nullptr;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

## 回溯

###力扣51.N皇后

```cpp
class Solution {
public:
    bool isValid(int row,int col,vector<string>& chessboard,int n){
        for(int j=0;j<row;j++){
            if(chessboard[j][col]=='Q') return false;
        }
        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--){
            if(chessboard[i][j]=='Q') return false;
        }
        for(int i=row-1,j=col+1;i>=0 && j<=n;i--,j++){
            if(chessboard[i][j]=='Q') return false;
        }
        return true;
    }
    vector<vector<string>> result;
    void backtracing(int n,vector<string>& chessboard,int row){
        if(row==n){
            result.push_back(chessboard);
            return;
        }
        for(int i=0;i<n;i++){
            if(isValid(row,i,chessboard,n)){
                chessboard[row][i]='Q';
                backtracing(n,chessboard,row+1);
                chessboard[row][i]='.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n,string(n,'.'));
        backtracing(n,chessboard,0);
        return result;
    }
};
```



### 力扣52.N皇后Ⅱ

```cpp
class Solution {
public:
    bool isValid(int row,int col,vector<string>&chessboard,int n){
        for(int i=0;i<row;i++){
            if(chessboard[i][col]=='Q') return false;
        }
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
            if(chessboard[i][j]=='Q') return false;
        }
        for(int i=row-1,j=col+1;i>=0&&j>=0;i--,j++){
            if(chessboard[i][j]=='Q') return false;
        }
        return true;
    }
    int result=0;
    void backtracing(int row,int n,vector<string>& chessboard){
        if(row==n){
            result++;
            return;
        }
        for(int col=0;col<n;col++){
            if(isValid(row,col,chessboard,n)){
                chessboard[row][col]='Q';
                backtracing(row+1,n,chessboard);
                chessboard[row][col]='.';
            }
        }
    }
    int totalNQueens(int n) {
        vector<string> chessboard(n,string(n,'.'));
        backtracing(0,n,chessboard);
        return result;
    }
};
```

## 贪心

### 力扣1221. 分割平衡字符串

```cpp
class Solution {
public:
    int balancedStringSplit(string s) {
        int result=0;
        int Rsize=0;
        int Lsize=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='R') Rsize++;
            else Lsize++;
            if(Rsize==Lsize && Rsize!=0){
                result++;
                Rsize=0;
                Lsize=0;
            }
        }
        return result;
    }
};
```



## 动态规划

###回文子串系列

![image-20221228145416441](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221228145416441.png)



力扣5 力扣131 647 516 234

### 力扣5 最长回文子串

```cpp
//双指针
class Solution {
public:
    string longestPalindrome(string s) {
        int len=0;
        int start=0,end=0;
        if(s.size()==1) return s;
        for(int i=0;i<s.size();i++){
            int len1=extend(i,i,s);
            int len2=extend(i,i+1,s);
            len=max(len1,len2);
            if (len > end - start)
			{
				start = i - (len - 1) / 2;
				end = i + len / 2;
			}
        }
        return s.substr(start,end-start+1);
    }
    int extend(int left,int right,const string& s){
        while(left>=0 && right<s.size() && s[left]==s[right]){
            left--;
            right++;
        }
        return right-left-1;
    }
};

//动态规划
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false));
        int maxlenghth=0;
        int left=0,right=0;
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i;j<s.size();j++){
                if(s[i]==s[j]){
                    if(j-i<=1) dp[i][j]=true;
                    else if(dp[i+1][j-1]) dp[i][j]=true;
                }
                if(dp[i][j] && j-i+1>maxlenghth){
                    maxlenghth=j-i+1;
                    left=i;
                    right=j;
                }
            }
        }
        return s.substr(left,maxlenghth);
    }
};
```



### ==力扣673. 最长递增子序列的个数==

dp[i]：i之前（包括i）最长递增子序列的长度为dp[i]

count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]

```cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        if(nums.size()==1) return 1;
        int result=0;
        vector<int> dp(nums.size(),1);
        vector<int> count(nums.size(), 1);
        int maxCount=0;
        for(int i=1;i<nums.size();i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    if(dp[j]+1>dp[i]){
                        count[i]=count[j];
                    }
                    else if(dp[j]+1==dp[i]){
                        count[i]+=count[j];
                    }
                    dp[i]=max(dp[i],dp[j]+1);
                }
                if(dp[i]>maxCount) maxCount=dp[i];
            }
        }
        for(int i=0;i<nums.size();i++){
            if(maxCount==dp[i]) result+=count[i];
        }
        return result;
    }
};
```



###力扣132.分割回文串Ⅱ

力扣131分割回文串使用回溯

这题使用动态规划，需要用到第五题里面的判断回文子串

```cpp
class Solution {
public:
    int minCut(string s) {
        vector<vector<bool>> isPalindromic(s.size(), vector<bool>(s.size(), false));
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j] && (j - i <= 1 || isPalindromic[i + 1][j - 1])) {
                    isPalindromic[i][j] = true;
                }
            }
        }
        // 初始化
        vector<int> dp(s.size(), 0);
        for (int i = 0; i < s.size(); i++) dp[i] = i;

        for (int i = 1; i < s.size(); i++) {
            if (isPalindromic[0][i]) {
                dp[i] = 0;
                continue;
            }
            for (int j = 0; j < i; j++) {
                if (isPalindromic[j + 1][i]) {
                    dp[i] = min(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[s.size() - 1];
    }
};
```

## 图论并查集模拟位运算

![image-20230111103015017](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230111103015017.png)

## 图论知识补充

dfs和bfs

先给大家说一下两者大概的区别：

- dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，在换方向（换方向的过程就涉及到了回溯）。
  - 搜索方向，是认准一个方向搜，直到碰壁之后在换方向
  - 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。
- bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。



所以dfs需要回溯，所以需要搭配递归的方式来实现,和回溯很像。

```cpp
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

