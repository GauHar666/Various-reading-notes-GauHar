# Java学习笔记

## 语法

- 判断是否相等的==和!=的优先级比其他关系运算符低，连续的关系运算是从左到右进行的

- 浮点数运算与Python一样有误差

  比较两个浮点数是否相等：

  ```java
  System.out.println(Math.abs(a - b) < 1e-6)
  ```

- else总和最近的if匹配

- do-while语句循环体至少执行一次

- for循环里三个部分中都可以添加多个表达式，其间用逗号隔开，如：

``` java
for(int i = 1; i <= n; i++, sign = -sign)
```

- break只跳出当前循环，若要跳出指定循环，可在循环前加一行标号，如：

``` java
OUT:
for(int one = 0; one <= amount; ++one)
{
    for(int five = 0; five <= amount / 5; ++five)
    {
        for(int ten = 0; ten <= amount / 10; ++ten)
        {
            for(int twenty = 0; twenty <= amount / 20; ++twenty)
            {
                if(one + five * 5 + ten * 10 + twenty * 20 == amount)
                {
                    System.out.println(one + "张1元，" +five+ "张5元，" +ten+ "张10元，" +twenty+ "张20元");
                    break OUT;
                }
            }
        }
    }
}
```

- 运算优先级逻辑非(!)>逻辑与(&&)>逻辑或(||)

- 数组定义时必须给出类型和元素个数，且之后不能改变，但元素个数可以是变量，索引（下标）从0开始编号（与C一样）

``` java
<类型>[] <名字> = new <类型>[元素个数];
int[] grades = new int[100];
double[] averages = new double[20];
```

new创建的数组得到默认0值，也可以直接用大括号给出数组所有元素的初始值，此时可以不给出数组的大小，如：

``` java
int[] scores = {87, 98, 69, 54, 65, 76, 87, 99};
```

- Java中数组变量是管理者而不是所有者，普通变量是所有者

- 数组变量之间的赋值是管理权限的赋于

  ``` java
  int[] a = new int[10];
  a[0] = 5;
  int[] b = a;
  System.out.println(a[0]); //输出为5
  b[0] = 16;
  System.out.println(a[0]); //输出也跟着变为16
  ```

- 数组变量之间的比较是判断是否管理同一个数组

  ``` java
  int[] a = {1, 2, 3};
  int[] b = {1, 2, 3};
  //a == b为false
  ```

- 复制数组需要循环遍历其中每一个元素来赋值：

  ``` java
  int[] a = {1, 2, 3};
  int[] b = new int[a.length];
  for(int i = 0; i < b.length; i++)
  {
      b[i] = a[i];
  }
  ```

- for-each循环：

  ``` java
  for(int k : data)
  ```

  对于数组data里的每一个元素。k在不断变化，循环第一次的时候为data[0]，第二次为data[1]，以此类推，k是这个数组里每一个元素的==复制品==，==不可以被赋值或改变==

  - 适合数组的遍历
  - 不包含索引（下标）信息
  - 不可以用于改变数组的值，可以理解为只读

  ``` java
  for(int k : data)
  {
      System.out.print(k);
  }
  //输出数组中全部的值
  ```


- 一个字符的常量（char）是用单引号包围起来的一个字符，如'a'、'*'、'好'。一个汉字也是Unicode的一个字符，所以也是Java的一个字符。

- 逃逸字符：\b 回退一格；\t 到下一个表格位；\n 换行；\r 回车；\“ 双引号；\\\反斜杠本身

- 对于基本数据类型，Java提供了对应的包裹(wrap)类型。这些包裹类型将一个基本数据类型的数据转换成对象的形式，从而使得它们可以像对象一样参与运算和传递。
  - 除了int和char以外，包裹类型就是把基本类型的名字的第一个字母大写
  - 在Java的系统类库中，所有第一个字母大写的，都是类的名字

- 字符串变量和数组变量类似，它并不存放字符串，不是字符串的所有者，它是字符串的管理者

- Java的字符串还是一种特殊的“不可变”对象，所有的字符串操作都是==产生一个新的字符串==，而==不是对原来的字符串的修改==

  ``` java
  String s = new String("a string"); //创建了一个String的对象---用"a string"初始化这个对象---创建管理这个对象的变量s---让s管理这个对象
  String s = "hello"; //同上，编译器创建一个String类的对象交给s来管理
  ```

  String是一个类，String的变量是对象的管理者而非所有者

  ``` java
  "hello" + "world"; //helloworld
  "I'm" + 18; //I'm 18
  1 + 2 + "age"; //3age
  "age" + 1 + 2; //age12
  ```

  字符串的连接，当"+"一边不是字符串时会将其转换为字符串再做连接

  ``` java
  Scanner in = new Scanner(System.in);
  String s;
  s = in.next(); //This is a test.---This
  s = in.nextLine(); //This is a test.---This is a test.
  ```

  in.next()读入一个单词，单词的标志是空格（不局限于空格，换行和制表位也算）

  in.nextLine()读入一整行

  ``` java
  Scanner in = new Scanner(System.in);
  String input;
  input = in.next();
  input == "bye"; //bye---false
  input.equals("bye"); //bye---true
  ```

  "=="比较的是是否同一个字符串，.equals()比较字符串内容是否相同

- 字符串是对象，其所有操作通过"."这个运算符来进行（字符串.操作）

- 字符串无法作for-each循环

- 字符串操作中的字符串修改不会修改字符串本身，而是根据原有字符串创造一个新字符串，需要用另一个字符串变量管理

- s1.compareTo(s2)：字符串大小比较

  - s1比s2小，结果为负；相等结果为0；s1比s2大，结果为正
  - s1.compareToIgnoreCase()可以不区分大小写来比较

- s.length()：获取字符串的长度，注意有一对小括号，与数组的操作不同

- s.charAt(index)：返回在index上的单个字符

  - index的范围是0到length() - 1，第一个字符的index为0，与数组一样

- s.substring()：获取字串

  - s.substring(n)：得到从n号位置到末尾的全部内容
  - s.substring(b, e)：得到从b号位置到e号位置==之前==的内容

- s.indexOf()：寻找字符

  - s.indexOf(c)：得到c代表的字符所在的位置，-1表示不存在
  - s.indexOf(c, n)：从n号位置开始寻找c字符
  - s.indexOf(t)：得到t代表的字符串所在的位置
  - s.lastIndexOf(c)、s.lastIndexOf(c, n)、s.lastIndexOf(t)：从右侧开始找

- 在switch-case中也可以使用字符串，但要求Java版本高于1.7

  ``` java
  switch (s){
      case "this":
          <...>;
      case "that":
          <...>;
  }
  ```

- 当函数期望的参数类型比调用函数时给的值的类型==宽==的时候，编译器可以将类型转换（如定义传递参数为double，输入int值可以转换为double），反之则不可
  
  - char<int<double
  
- 当函数期望的参数类型比调用函数时给的值的类型==窄==的时候，需要自行进行强制类型转换

- 当函数期望的参数类型比调用函数时给的值的类型之间无法转换的时候即报错

- 本地变量不会被自动初始化，但参数进入函数的时候就被初始化了

---

## 面向对象

### 对象与类

#### 概念

- 对象是实体，需要被创建，可以用来做事情
  - 表达东西或事件
  - 运行时的响应消息（提供服务）
- 类是规范，根据类的定义来创建对象
  - 定义所有的属性
  - Java中的类型
  - 可以用来定义变量
- 对象=属性+服务
  - 数据：属性或状态
  - 操作：函数
  - 封装：把数据和对数据的操作放在一起
- 类=表示对象==有什么==的==成员变量==和表示对象==能做什么==的==成员函数==

#### 成员变量与成员函数

- 类定义了对象中所具有的变量，这些变量被称作成员变量
- 每个对象有自己的变量，和同一个类的其他对象是分开的
- 在函数中可以直接写成员变量的名字来访问成员变量
- this为成员函数的一个特殊的固有的本地变量，表达了调用这个函数的对象
  - 在一个成员函数==内部==调用另一个成员函数只需要直接调用函数即可
  - 在成员函数外部调用成员函数必须要加上对象名和'.'

#### 本地变量与成员变量

- 定义在==函数内部==的变量是本地变量
- 本地变量的生存期和作用域都是函数内部
- 成员变量的生存期是==对象的生存期==，作用域是==类内部的成员函数==

#### 成员变量的初始化

- 成员变量在定义的地方就可以给出初始值
- 没有给出初始值的成员变量会==自动获得==0、null或false值
  - 对象变量的0值表示没有管理任何对象，也可以主动给null值
- 定义初始化可以调用函数，甚至可以使用已经定义的成员变量

#### 构造函数与重载

- 如果有一个==成员函数==的名字和==类==的名字==完全相同==，则在创建这个类的==每一个对象==的时候会==自动调用==这个函数

- 这个函数==没有返回类型==

- 一个类可以有==多个==构造函数，只要它们的==参数表不同==

- 创建对象的时候给出不同的参数值，就会调用不同的构造函数

- 通过this()还可以调用其他构造函数

  - 只能在构造函数本体里出现
  - 必须在那个构造函数代码块里的第一句
  - 只能使用一次

  ``` java
  VendingMachine() //构造函数
  {
      total = 0;
  }
  
  VendingMachine(int price) //重载
  {
      this(); //调用上面那个没有参数的构造函数
      this.price = price;
  }
  ```

- 一个类里==同名==但==参数表不同==的函数构成了==重载关系==

---

### 对象交互

#### 访问属性

private：只能用于修饰成员变量或成员函数，不可用于成员函数内部的定义

- 只有这个类内部可以访问，属于==同一个类==的==不同对象==可以互相访问对方的private变量或函数
  - 类内部指类的成员函数和定义初始化
  - 这个限制是对类而不是对对象的，即使在其他类中新建了该类的对象，依然无法访问该类中private修饰的成员

public：

- 任何人都可以访问
  - 任何人指的是在任何类的函数或定义初始化
  - 使用指调用、访问或定义变量

未定义public或private的成员变量/函数即为friendly，在==同一个包(package)内==可以相互访问

一个编译单元可以包含很多个类，但==只能有一个public的类==

#### 包

- 访问==其他包==内的内容时要用==import+包名称==命令

  ``` java
  import <包名>.<类名>;
  import display.Display;
  ```

- 可以引入包的全部内容，但可能存在==包过大==或有==同名的类==等问题，不推荐使用

  ``` java
  import <包名>.*;
  import display.*;
  ```

- 包内还能再建立子包，包的名字里面的点（不是包名和类名之间的点）代表了包文件夹的层次

  ``` java
  import <包名>.<二级包名>.<...>.<类名>；
  import java.util.Scanner;
  ```

#### 类变量

类变量(static)只属于那个类，可以直接用类访问，不属于其中任何一个对象，但任何一个对象可以访问这个类变量，如：

``` java
private static int step = 0;
public static void f()
{
    
}
```

在类函数(static函数)中不能访问非static的成员变量/函数，类函数由于不属于任何对象，因此也没有办法建立与调用它们的对象的关系，就不能访问任何非static的成员变量和成员函数了

在类函数(static函数)可以直接调用其他类函数(static函数)，也可以用对象来调用其他类函数

类变量只有在类的装载时才会初始化，和对象的创建没有关系

类函数中不能使用this, super等用于实例的关键字

---

### 对象容器

#### 顺序容器

``` java
private ArrayList<String> notes = new ArrayList<String>(); //新建一个String类型的ArrayList对象，由notes管理
notes.add(String s, int location); //将s添加到notes的location位置上，notes中位于location后面的元素相应后移
```

#### 对象数组

一个对象数组中的==每个元素==都是对象的==管理者==而不是对象本身，创建完一个对象数组后，还需要==再创建对象==来分配给对象数组中相应的管理者

``` java
Value[] a = new Value[10];
for(int i = 0; i < a.length; i++)
{
    a[i] = new Value();
    a[i].set(i);
}

for(Value v : a) //第一轮循环时v指向a[0]管理的对象，即v与a[0]共同管理那个对象；第二轮循环时v指向a[1]管理的对象，以此类推
{
    System.out.println(v.get());
    v.set(0); //获取当前循环数组元素管理的对象，并对该对象进行set操作
} //循环结束后Value类型的对象数组中的每一个元素的值属性都变为0
```

==对象数组==和==容器==都可以用for-each循环来遍历，可以在循环中获取相应的对象并进行相关的操作

#### 集合容器(Set)

元素唯一性、无序性，与数学概念的集合类似

``` java
public String toString() {return "" + i;} //有toString函数就可以主动在System.out里将return的字符串输出
```

#### 散列表(Hash)

对于Hash表来说，==键一定是唯一的==，如果同一个键被多次赋予了值，留下的只能是==最后一个==

遍历Hash表不能直接用for-each循环，但可以针对==keySet()==用for-each循环来==遍历Hash表的每一个键==，再用==get()==取出该键对应的值

``` java
private HashMap<Integer, String> coinnames = new Hashmap<Integer, String>();

for(Integer k : coinnames.keySet())
{
    String s = coinnames.get(k);
    System.out.println(s);
}
```

---

### 继承与多态

#### 继承

用于做基础==派生其他类的那个类==称作父类、基类或者超类，而派生出来的==新类==称作子类，用关键字extends表示这种继承/派生关系

``` java
class ThisClass extends SuperClass
{
}
```

- 子类的对象可以被看作是父类的对象，可以被当作父类的对象来使用，反之则不行

  - 赋值给父类的对象

  ``` java
  Vehicle v1 = new Vehicle();
  Vehicle v2 = new Car();
  Vehicle v3 = new Bicycle();
  ```

  - 传递给需要父类对象的函数
  - 放进存放父类对象的容器里
    - 父类对象的容器里可能存放着==各不同的子类==

- 继承只允许单继承，即一个类只能有==一个父类==

- 子类从父类继承了==所有的成员变量和成员函数==

  - public的成员直接成为子类public的成员
  - protected成员直接成为子类protected的成员
  - 缺省成员在==父类所在的包内==可见，若子类不属于父类的包，那么在子类里这些缺省属性的成员和private的成员是一样不可见的
  - private的成员在子类中==仍然存在==，只是子类不能==直接访问==
  - 不可以在子类中重新定义继承得到的成员的访问属性

- 如果试图重新定义一个在父类中已经存在的成员变量，其实是在定义一个与父类的成员变量==完全无关==的变量，在子类中可以访问这个定义在子类的变量，在父类中则是访问定义在父类中的那个，==两者重名但互不影响==

- ==构造方法==不可以被继承，因为它们的名字就是类的名字

当父类的成员为private时，若在子类中需要访问该成员而不需要使用（可理解为只读无需写），可以在子类构造器中用==super==命令将此private成员传入，super命令在一个构造函数里只能==被调用一次==且必须写在==构造函数的第一行==

``` java
public class Item
{
    private String title;
    
    public Item(String title)
    {
        super();
        this.title = title;
    }
}

public class CD extends Item
{
    public CD(String title)
    {
        super(title);
    }
}
```

若子类没有通过super命令传递参数给父类，那么编译器会首先寻找父类中==不带参数的构造器==；若子类拥有super命令，那么编译器会根据传入的参数选择父类中能够匹配的构造器

在构造子类对象时，父类的构造方法会在==子类之前==被调用，先初始化父类的定义初始化，再初始化父类的构造器，之后才轮到子类的定义初始化和构造器

在子类中调用父类中private的函数/方法时，要用==super.==命令，不到万不得已尽量不要把父类中的private改成其他访问属性

#### 多态

- Java的对象变量是多态的，它们能保存==不止一种类型==的==对象==
- 它们可以保存的是声明类型的对象，或==声明类型子类==的对象
- 当把==子类的对象==赋值给==父类的变量==的时候，就发生了==向上造型==

#### 造型

- 子类的对象可以赋值给父类的变量

  - 不存在==对象对对象==的赋值

- 父类的对象==不能==赋值给子类的变量

- 可以用造型（类似强制类型转换）：

  ``` java
  c = (Car) v; //只有当v这个变量实际管理的是Car类型才行，否则会产生类造型错误
  ```

- 向上造型：拿一个子类的对象，当作父类的对象来用

  - 向上造型是默认的，==不需要运算符==
  - 向上造型总是安全的

### 设计原则

#### 消除代码复制

代码复制是不良设计的一种表现

#### 封装

- 增加可扩展性
  - 可以运行的代码不等于良好的代码
  - 对代码做维护的时候最能看出代码的质量
- 用封装来降低耦合
  - 类和类之间的关系称作耦合
  - 耦合==越低越好==，保持距离是形成良好代码的关键
  - 成员变量==尽量私有==，万不得已才使用public

#### 可扩展性

- 用接口来实现聚合
- 用容器来实现灵活性

#### 框架加数据

从程序中识别出框架和数据，以代码实现框架，将部分功能以数据的方式加载，这样能在很大程度上实现可扩展性

- 命令的解析是否可以==脱离if-else==
- 定义一个Handler来处理命令
- 用Hash表来保存命令和Handler之间的关系