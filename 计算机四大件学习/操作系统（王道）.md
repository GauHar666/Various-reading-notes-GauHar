#操作系统（王道）

## 1.1.1操作系统基本概念

####操作系统的概念：

Operating System，简称OS，是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的**系统软件**。

计算机系统的层次结构：用户和操作系统也是可以直接有交互的。

![image-20221027203306478](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027203306478.png)

作用：

1. 负责协调硬件，软件等计算机资源工作
2. 为上层的应用程序、用户等提供简单易用的服务
3. **操作系统是软件，不是硬件**



补充知识：==进程是一个程序的执行过程。执行前需要将该程序放到内存中==，才可以被CPU处理。



####操作系统的功能和目标：

- 作为系统资源的管理者：

![image-20221027204051808](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027204051808.png)

需要提供四个功能：==文件管理、存储器管理、处理机管理（CPU管理）、设备管理。==

- 作为用户和计算机硬件之间的接口：

有命令接口、程序接口、GUI（图形用户接口）

![image-20221027204441724](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027204441724.png)

 联机命令接口：交互式命令接口，cmd中的那个，写一行做一行。

脱机命令接口：批处理命令接口

![image-20221027205202280](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027205202280.png)

程序接口（系统调用）：常见的就是.dll文件，改调用过程为**系统调用**，即可以创建窗口等功能，只能通过用户程序间接使用。

- GUI图形用户界面

![image-20221027205503853](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027205503853.png)





**从上往下看，和硬件的关系：**

裸机上安装操作系统，对资源进行管理，方便用户的服务功能

把覆盖了软件的机器称为：**扩充机器**或**虚拟机**

![image-20221027205819791](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221027205819791.png)



## 1.1.2操作系统的特征

四个特征：

- **并发**：指两个或多个事件在同一时间间隔内发生。宏观上同时发生，微观上交替发生，任何一个时刻只进行一个任务。
  - 与并行容易混淆，并行：两个或多个事件在同一时刻同时发生
  - 操作系统的并发性指计算机系统中，同时存在着多个运行着的程序

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029191652128.png" alt="image-20221029191652128" style="zoom:67%;" />

- **共享**：即指资源共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用。 

  - 互斥共享方式：一个时间段只允许一个进程访问该资源（类似你的摄像头）
  - 允许一个时间段内由多个进程同时对他们进行访问（微信和QQ的发文件 ）

  ==并发和共享互为存在条件，失去其中一个另外一个也失去意义==

- **虚拟**：是指把一个物理上的实体变成若干个逻辑上的对应物。物理实体实际存在，二逻辑对应物是用户感受到的。类似电脑上用的虚拟存储器。

  - 空分复用技术
  - 时分复用技术：在微观上处理及在各个微小的时间段内交替为各个进程服务。

  显然，没有并发性就谈不上虚拟性。

- **异步**：在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，是走走停停的，以不可预知的速度向前推进。

  - 只有拥有了并发性，才有可能导致异步性。

**并发**--**共享**，是两个最基本的特征，二者互为存在条件。没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统最基本的两个特征。



## 1.1.3 操作系统的发展与分类

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029193739883.png" alt="image-20221029193739883" style="zoom:67%;" />

**手工操作和单道批阶段**：内存中仅能有一道程序运行，CPU有大量的时间是在空闲等待I/O完成的，资源利用率依然很低。

 **多道批处理系统**：==操作系统正式诞生==，引入了中断技术，可以并行执行程序。多道程序并发执行，共享计算机资源，资源利用率大幅度提升。用户响应时间长，但是没有人机交互功能。

![image-20221029195057262](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029195057262.png)

输入，CPU,输出其实是串行的只能同时有一个空闲，然后错位并行。

**分时操作系统：**以时间片为单位轮流为各个用户/作业服务，可以通过终端与计算机进行交互。不能优先处理一些紧急任务

**实时操作系统**：可以优先响应一些紧急任务，某些紧急任务不需要时间片排队。 在严格的时间限制内处理完事件，主要特点是：==及时性和可靠性==。

又分为硬实时系统（必须在严格的规定时间内完成）和软实时系统（偶尔接受违反时间规定），

##1.1.4操作系统的运行机制与体系结构

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029203216669.png" alt="image-20221029203216669" style="zoom:67%;" />

- 指令和代码的区别：写的代码都会被翻译成机器的语言指令（一条高级语言可能对应多条指令），这些指令都是二进制的（因为机器硬件只能识别二进制数。），讲的具体一点就是==让CPU直接干事情。==
  - 非特权指令
  - 特权指令：不允许用户程序使用

- 两种处理器状态
  - 用户态（目态）：CPU处于用户态，只能执行非特权指令
  - 核心态（管态）：CPU在这时可以执行特权指令
- 两种程序
  - 内核程序：是系统的管理者，特权非特权指令都可以执行，运行在核心态
  - 应用程序：普通程序只能执行非特权指令，运行在用户态。





**操作系统的内核**：

对于第一章所讲的操作系统，其实还可以进一步细分：

操作系统

- 非内核功能

- 内核

  - 时钟管理
  - 中断处理
  - 原语（设备驱动、CPU切换）：是一种特殊的程序，是最接近硬件的部分，这种程序运行具有**原子性**，开始就一直要运行到结束，不能停。
  - 系统资源管理：进程管理、存储器管理、设备管理等。==这一块不同操作系统不一定包括不包括它==

  ![image-20221029205508779](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029205508779.png)

分成大内核和微内核，就是包不包括系统资源管理：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029205607092.png" alt="image-20221029205607092" style="zoom:50%;" />

## 1.1.5中断和异常

中断和异常相当于说是用户态进入核心态的一些门，当中断和异常发生的时候，CPU会马上进入核心态，这是通过硬件实现的。

1. 中断的机制：本质：发生中断就意味着需要操作系统介入，开展管理工作。

   1.1==当中断发生时，CPU立即进入核心态==

   1.2当中断发生之后，当前的运行进程会暂停，并由操作系统内核对中断进行处理。

   1.3对于不同的中断信号，会进行不同的处理

   ![image-20221029211543408](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029211543408.png)

这也是用户态——》核心态之间如何切换的实现：**利用中断，并且中断是唯一途径。**

而核心态——》用户态，则通过执行应该特权指令，将用户状态字（PSW）的标志设置为“用户态”。



2.中断的分类：

- **内中断（异常）**：信号来源CPU内部，与当前指令有关。（自愿中断（指令中断）、强迫中断（硬件故障、软件中断））
- **外中断（异常）**：来源CPU外部（外设请求、人为干预）

![image-20221029212206487](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029212206487.png)



另外一种分类：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029212247062.png" alt="image-20221029212247062" style="zoom:67%;" />

外中断处理过程：1.执行完每个指令后，CPU都检查当前是否有外部中断信号 2.如果有则需要保护被中断进程的CPU环境（相当于存档）3.根据中断信号类型转入相应的中断处理程序4.恢复原进程的CPU环境并退出中断，返回原进程继续执行。

##1.1.6系统调用（有一个陷入指令，只能在用户态执行）

1. 什么是系统调用：==也就是操作系统和用户直接相连的，程序接口，又一组系统调用组成。==![image-20221029213907575](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029213907575.png)

程序接口（系统调用），是直接和应用程序对接的。是操作系统提供给应用程序使用的接口，可供应用程序调用的特殊函数。



**操作系统提供：系统调用功能，用户进程想要使用系统资源，只能提供系统调用向操作系统发出请求，操作系统会对各个请求进行协调管理。**

![image-20221029214307461](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029214307461.png)

系统调用的相关处理，必须在核心态下进行才可以。



2.系统调用与库函数的区别：

![image-20221029214547209](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029214547209.png)



3.系统调用的背后的过程：

高级语言--（编译）--汇编语言----传递系统调用参数--执行陷入指令（用户态）---执行系统调用相应服务程序（核心态）---返回用户程序。

==陷入指令在用户态，==执行陷入之后立刻发生内中断，然后CPU进入核心态。

==陷入指令也是唯一一个只能在用户态执行的指令，而不能在核心态执行的==

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221029215201865.png" alt="image-20221029215201865" style="zoom:67%;" />

 

==系统调用会使处理器从用户态进入核心态，实质是有一个int指令，即执行了陷入指令，产生内中断==

==系统调用发生的用户态，对系统调用的处理发生在核心态。==

什么时候会用系统调用：与资源有关的、直接影响其他进程的。



## 2.1.1进程的定义

1. 进程的定义

   - 也是因为进程（Process）的引入和提出，实现了操作系统的并发性和共享性两个最基本特性。

   - ==进程说简单点就是程序执行的一次过程。==真正定义：**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。**
   - 程序：就是一个指令序列
   - 在多道程序技术引入之后，内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同，所以需要**进程和进程实体**。
   - 系统为每个程序配置一个数据结构，**称为进程控制块（PCB）**，用来描述进程的各种信息。用来控制和管理进程。
   - 进程实体（进程映像）的组成：**PCB、程序段、数据段**
   
   ==进程映像是静态的，进程是动态的。==
   
   进程实体（进程映像）简称为进程，所以所谓的进程的创建，就是创建进程实体中的PCB的过程；撤销进程就是撤销PCB。**PCB是进程存在的唯一标志**。

![image-20221031200308457](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031200308457.png)

**严格上来说进程实体和进程不一样，进程实体是静态的，进程是动态的。**

2.进程的组成：

进程=进程实体（进程映像）的组成：PCB、程序段、数据段

程序段：程序的代码存放的位置，也是指令序列的位置。

数据段：程序运行时使用，产生的运算数据，比如全局变量、局部变量、宏定义等。

PCB：用来管理进程，包含操作系统对其进行管理所需的各种信息。

![image-20221031200857113](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031200857113.png)

只要记住：和进程管理相关的数据肯定都存放在PCB中。

3.进程的组织：

多个进程之间的组织方式，PCB于PCB之间如何组织问题。

- 链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针

  <img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031201756750.png" alt="image-20221031201756750" style="zoom:67%;" />

- 索引方式：根据进程状态不同，建立几张索引表，操作系统有指向索引表的指针

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031201826000.png" alt="image-20221031201826000" style="zoom:67%;" />

4.进程的特征：

进程和程序是两个截然不同的概念，进程的特征

- 动态性：进程是程序一次执行过程，是动态的产生、变化和消亡的
- 并发性：多个进程，存在内存中，能在一段时间内同时运行
- 独立性：能够独立运行，独立获得资源，独立接受调度==（进程是资源分配、接受调度的基本单位）==
- 异步性：各进程以不可预知的速度向前推进，但是运行结果不确定。
- 结构性：每个进程都有PCB、数据段、程序段。

## 2.1.2进程的状态与转换

进程状态：==就绪态、运行态、阻塞态、创建态、终止态==

进程说简单点就是程序执行的一次过程。

进程的三种基本状态：

1. **运行态**：已经在CPU上运行（单核就一个，多核就多个进程同时运行）
2. **就绪态**：具备运行条件，等待空闲CPU
3. **阻塞态**（**等待态**）：因为等待某一事件而暂时不能运行

另外两种状态：

1. **创建态**：进程正在被创建的状态，分配资源、初始化PCB
2. **终止态**：进程正在被撤销的状态，操作系统会回收进程拥有的资源，撤销PCB

![image-20221031204920868](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031204920868.png)

就绪态不可以变成阻塞态，阻塞态也不可以直接变成运行态。

**运行态变为阻塞态是主动行为，申请了系统调用。**

## 2.1.3进程控制

进程控制：实现进程状态之间的转换：创建、撤销、转换状态等。

过程就是修改PCB的内容（修改进程状态标志、将运行环境保存等等），并把其转换到相应的队列中去，分配回收资源。

==具体的控制是通过原语==：中间不能中断，只能一气呵成 。采用关中断和开中断指令来实现：

 <img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031205950447.png" alt="image-20221031205950447" style="zoom:67%;" />

关开中断权限很大，只允许在核心态运行。

进程的创建：

![image-20221031210257674](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031210257674.png)

进程的终止：

![image-20221031210334604](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221031210334604.png)

还包括：**阻塞原语**（从运行态->阻塞态）和**唤醒原语**（阻塞态->就绪态），这两个应该成对使用

还有切换原语。

##2.1.4进程通信

进程通信：指进程之间的信息交换

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**。所以一个进程不可以直接访问另一个进程的地址空间。为了能安全的进行进程之间的信息交换：提供了一些方法：

- 共享存储：

  <img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101200802342.png" alt="image-20221101200802342" style="zoom:50%;" />

  - 基于数据结构的共享：共享空间里只能放固定长度数据，速度慢、限制多，是一种低级通信方式。
  - 基于存储区的共享：在内存中划出一块空间即可，速度快，是一种高级通信

- 消息传递：以格式化消息为单位交换数据。提供操作系统收发消息两个原语进行数据交换。

  **![image-20221101201607762](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101201607762.png)**

- 管道通信：

  - 管道：一种特殊的共享文件，用于连接读写进程。又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区。（在linux中是4kb）。
  - 管道只能采用**半双工通信**，在同一个时间只能单向传输。要是想同时双向通信，则需要设置两个管道。
  - 各个进程之间也要互斥访问管道。（就是只能有一个在写或读）
  - 数据以字符流形式写入，当写满的时候，write（）这个系统调用会被阻塞，等待管道中所有数据被取走后，管道空了，此时read（）系统调用阻塞，继续执行right。
  - 读进程最多只能有一个。



## 2.1.5线程的概念和多线程模型

1. 什么是线程：对于原本的进程来说，进程是程序的一次执行，但是一次程序不可以同时实现那么多功能。为了增强系统的并发度：引入了线程的概念：

![image-20221101202943155](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101202943155.png)

进程中包含了线程，引入线程之后，线程成为了程序执行流的最小单位。每个线程有不同的代码，并发的被执行。可以把线程理解为：轻量级的进程。

==线程是一个基本的CPU执行单元，也是程序执行流的最小单元==

在引入线程之后，进程只作为除CPU之外的系统资源的分配单元（例如打印机、内存地址空间等）

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101203445836.png" alt="image-20221101203445836" style="zoom:50%;" />

2.线程的属性：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101203840508.png" alt="image-20221101203840508" style="zoom:67%;" />

3.线程的实现方式：

- 用户级线程：

用户级线程由应用程序通过线程库实现。在用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

对于用户不透明，对于操作系统来说透明。用户的视角可以看到的线程。

- 内核级线程（Kernel-Level Thread）：

线程管理由内核完成，在核心态完成。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101204524823.png" alt="image-20221101204524823" style="zoom:67%;" />

因为操作系统只看得见内核级线程，==所以只有内核级线程才是处理及分配的单位。==

4.多线程模型

- 多对一：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程。
  - 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，开销小，效率高。
  - 缺点：当一个用户级线程阻塞后，整个进程都被阻塞，并发度不高。

- 一对一模型：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101205414745.png" alt="image-20221101205414745" style="zoom:50%;" />

- 多对多模型：（最好的）

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221101205452387.png" alt="image-20221101205452387" style="zoom:50%;" />



总结一句话：==线程是处理机的调度单位，进程是资源分配的单位。==



## 2.2.1处理机调度的概念、层次

调度：有很多任务需要实现，没办法同时处理，需要某种规则来决定处理任务的顺序，这就是调度研究的问题。

**处理机调度：**==就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，实现各个进程的并发执行。==

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221102204215683.png" alt="image-20221102204215683" style="zoom:50%;" />

从一个作业提交开始知道完成，要经历以下三级调度。

**作业调度**：主要指调入的问题，给后备队列的作业中挑选一个，给其分配内存，建立相应的进程（建立PCB），以使它们获得竞争处理机的权利。效率低，通常几分钟一次

**内存调度**：暂时调到外存等待的进程状态会变为**挂起状态**，PCB不会一起调到外存，而是会常驻内存，被挂起的进程的PCB会被放到挂起队列中。目的在于：**提高内存利用率和系统吞吐量**

![image-20221102212013328](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221102212013328.png)

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221102212351943.png" alt="image-20221102212351943" style="zoom:67%;" />

**进程调度**：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度频率很高，最基本调度，一般操作系统都要有，一般几十毫秒一次。

![image-20221102213052845](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221102213052845.png)

## 2.2.2进程调度的时机、切换与过程、方式

进程调度：也就是低级调度：就是按照某种算法从就绪队列中选择有个进程为其分配处理机

1. 进程调度的时机：

![image-20221104210459286](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221104210459286.png)

细说一下进程在操作系统**内核程序临界区**中不能进行调度与切换：

内核临界区内访问的资源长时间不释放，影响其他工作，临界区又普通临界区和内核临界区，普通临界区可以进行进程调度和切换，因为切换不影响内核工作。

**临界资源**：一个时间段内只允许一个进程使用的资源，各个进程需要互斥地访问临界资源。

**临界区**：访问临界资源的那段代码

2. 进程调度的方式

- 剥夺调度方式（抢占式）
  - 如果又更重要、更紧迫的进程需要使用处理机，则立即暂停正在执行的进程
- 非剥夺调度方式（非抢占式）
  - 只允许进程主动放弃处理机，

3. 进程调度和进程切换的区别

![image-20221104212639662](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221104212639662.png)

进程的切换、调度是有代价的。

##2.2.3调度算法的评价指标

- CPU利用率：CPU处于忙碌的时间占总时间的比例
- 系统吞吐量：单位时间内完成的作业数量。=总共完成了多少道作业/总共花了多少时间。
- 周转时间：指作业被提交给系统开始，知道作业完成为止，这段时间的间隔。完成时间-提交时间
  - 平均周转时间=总作业周转时间和/作业数
  - 带权周转时间： 作业的周转时间/作业实际运行的时间。这个值肯定大于1
- 等待时间：指进程/作业处于等待处理机状态时间之和

![image-20221104215524887](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221104215524887.png)

- 响应时间：输入命令到响应的时间

##2.2.4三种调度算法（书P53）适合批处理系统

- **先来先服务**（FCFS）：处于公平的角度考虑，按照作业/进程大大的先后顺序进行服务，一般是一种非抢占式的算法。优点：算法简单、公平。缺点：排在长作业后的短作业需要等待很长时间，带权周转时间很大，对长作业有利，对短作业不利。不会导致饥饿
- **短作业优先**（SJF）：追求更少的平均等待时间，最少的平均周转时间....。每次调度时选择当前已经到大且运行时间最短的作业/进程。最短的作业/进程先得到服务 ，一般是非抢占式的。==基本是平均响应时间和周转时间最短的调度算法==。

​	抢占式的短作业优先（要优于非抢占式的）：在这个调度算法之中，这些进程的执行可能是断断续续的，不是连续完成的![image-20221204162531158](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204162531158.png)

缺点：对短作业有利，对长作业不利，可能会产生饥饿的现象



- **高响应比优先**（HRRN）：综合考虑作业/进程的等待时间和要求服务的时间（非抢占式）

每次调度是先计算各个作业的响应比，响应比高的作业优先服务。不会造成饥饿

![image-20221204163428898](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204163428898.png)







饥饿：某进程/作业长期得不到服务

周转时间=完成时间-到达时间

![image-20221204161525866](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204161525866.png)



##2.2.5适用于交互式系统的三种调度算法

- **时间片轮转调度算法**（RR）：适用于分时操作系统。在一定时间间隔内都可以响应，按照先来后到的顺序轮流执行一个时间片，没执行完就到就绪队列尾重新排序，是一种抢占式的算法，由时钟装置（硬件）来通知CPU时间片已经到了。没用完的时间片会自动放弃

  - 如果时间片太大，使得每一个进程都可以在一个时间片内完成，就退化成了先来先服务，会增大程序的响应时间。
  - 太小，进程切换过于频繁，导致实际用于进程执行的时间比例会减小。

  

- **优先级调度算法**：对作业和进程设置自身的优先级，调度是选择优先级高的。有抢占和非抢占的版本。 一般系统进程的优先级高于用户进程，前台进程优先级高于后台进程，更加偏向于I/O繁忙型进程（尽早让I/O设备投入工作）。可能导致饥饿。

-  **多级反馈队列调度算法**：

![image-20221204170739080](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204170739080.png)

集合了前集中算法的优点

具体运行的方法见视频

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204171104804.png" alt="image-20221204171104804" style="zoom:67%;" />

有可能会导致饥饿。



作业与进程的区别在于：作业是用户提交的，进程是由系统自动生成的，前者以用户任务为单位，后者以操作系统控制为单位。



##2.3.1进程同步进程互斥

**由于程序具有异步性**，系统在并发执行的进程中各自独立，以不可预知的速度向前推进。

这样导致了程序的推进是不可预知的，为了导致我们的程序按照我们想要的执行顺序执行，所以提出了**进程同步的概念**。

**同步**：也被称为**直接制约关系**，要让两个及以上的进程在某些位置上协调他们的工作次序，传递信息所产生的制约关系。

**临界资源：**一个时间段内只允许一个进程使用的资源称为临界资源，很多物理设备都属于临界资源。对于临界资源的访问必须互斥进行

**互斥：**间接制约关系

![image-20221204210541754](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221204210541754.png)

## 2.3.2进程互斥的软件实现方法

1. **单标志法：**每个进程在访问完临界区后，会把临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205161229399.png" alt="image-20221205161229399" style="zoom:50%;" />

分为四个区

一开始将turn标志设为0，表示当前运训进入临界区的进程号。只有当允许进入临界区的进程访问了临界区之后，才会修改turn的值。但是只能P0-P1-P0-P1这题轮流访问。违背了空闲让进。



2. **双标志先检查法**：设置一个布尔类型数组flag[]，数组中的各个元素用来标记各个进程想进入临界区的意愿。可以交替进入，连续使用。true想进入，flase不想进入。但是由于进程的异步性，导致了检查和修改操作有可能在进程调度的过程中被改变了发生次序。导致了有可能多个进程同时访问临界区，违背了忙则等待的原则。

![image-20221205162020199](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205162020199.png)

3. **双标志后检查法：**

![image-20221205162632531](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205162632531.png)

还是会受异步性的影响，虽然解决了忙则等待的问题，但是违背了空闲让进和有限等待的原则。容易让两个进程饥饿。

4. **Peterson**算法:

同时设定flag数组和turn两个标志，turn标志是用来互相谦让的。

![image-20221205163034606](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205163034606.png)

遵循了空闲让进，忙则等待，有限等待。但是没遵循让权等待。

## 2.3.3进程互斥的硬件实现方法

![img](https://img-blog.csdnimg.cn/20200318150037360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

1. **中断屏蔽方法**：

![img](https://img-blog.csdnimg.cn/20200318150904821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

2.**TestAndSet指令**

底层是由硬件逻辑直接实现的，不会被中断。执行TSL指令时，它的内部运转逻辑：
假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等
假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。
<img src="https://img-blog.csdnimg.cn/20200318153206214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

3.**swap指令**：

也成exchange、XCHG指令

交换两个字的值。

old是每个进程都要进行的一步，都必须将old=true
分析一下这样做的原因：
因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。
![img](https://img-blog.csdnimg.cn/20200318164026883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

## 2.3.4信号量机制

信号量机制的引入目的：为了更好的解决进程互斥于同步的问题。

![img](https://img-blog.csdnimg.cn/20200318190256836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

可以把双标志先检查法的上锁和进入临界区两个操作放到一个原语里面，就可以解决异步性这个问题。wait和signal原语。也简称P和V原语。

1.**整型信号量：**

补充：**让权等待**：当进程不能进入临界区的时候，应该立即释放处理器，防止进程忙等待。

用一个整数型变量作为信号量，表示系统在某种资源的数量。问题在于不满足让权等待原则。

![image-20221205202428755](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205202428755.png)  

2.**记录型信号量：**

除了应该用于代表资源数目的整型变量之外，还需要一个进程链表L，同时包含block和wakeup原语，遵循了让权等待

![img](https://img-blog.csdnimg.cn/20200318194110945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##2.3.5用信号量实现进程互斥、同步、进程的前驱关系

1. **实现进程互斥**：

- 分析并发进程的关键活动，划定临界区
- 设置互斥信号量mutex，初值为1
- 在临界区之前执行P（mutex）//也就是wait
- 在临界区之后执行V（mutex）//也就是signal

不同的临界资源需要设置不同的互斥信号量

2. **实现进程同步**：

同步就是要让并发进程按照有序地推进。让本来一步并发的进程相互配合，有序推进。

为了保证以前一后执行两个操作，设置同步信号量S，初始设为0.

在前操作之后执行V（S），在后操作之前执行P(S)。（==前V后P==）

![image-20221205205717916](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205205717916.png)

3. **实现进程的前驱关系**：

![image-20221205210321956](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221205210321956.png)

##2.3.6生产者-消费者问题（典型互斥问题）

互斥信号量的初值一般设为1，同步信号量的初值一般看初始资源的数目由多少个。

- 系统中有`一组生产者进程`和`一组消费者进程`，生产者进程每次`生产一个`产品放入缓冲区，消费者进程每次从缓冲区中`取出一个`产品并使用。(注: 这里的“产品”理解为某种数据)

- 生产者、消费者`共享`一个初始为空、大小为n的`缓冲区`。
- 只有缓冲区`没满`时，`生产者`才能把产品`放入`缓冲区，否则必须等待。==同步==
- 只有缓冲区`不空`时，`消费者`才能从中`取出`产品，否则必须等待。==同步==
- 缓冲区是临界资源，各进程必须`互斥`地访问。（防止覆盖到同一块区域上）==互斥==

互斥的操作是在同一个进程之间进行一对PV操作

![img](https://img-blog.csdnimg.cn/20200326162426621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**实现互斥的P操作一定要在实现同步的P操作之后，V操作可以交换**

如果先直接互斥，那么此时mutex变为0，到第二个进程之后，mutex因为是0无法进行进程2，导致产生死锁的现象。

![image-20221206191043964](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221206191043964.png)

##2.3.7多生产者多消费者

应该是多类生产者和多累消费者，生产者和消费者生产和消费的东西是不一样的，但是只有一个大小为1的缓冲区，需要轮换使用。

![img](https://img-blog.csdnimg.cn/2020032619533967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**为什么有mutex和没有mutex一样呢？**

- 原因在于:本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…

- `总结`:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，`这不是绝对的`，要具体问题具体分析。
- `建议`:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·`实现互斥的P操作一定要在实现同步的P操作之后`·，否则可能引起·`“死锁”`·。

![image-20221206192832882](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221206192832882.png)



##2.3.11管程

在管程引入之前，进程的同步和互斥主要是通过信号量机制来完成的，但是信号量机制主要存在：编写程序困难、易出错（比如PV的顺序很容易出现问题）。

管程有点像一个类，类内成员变量是私有的，需要公有的成员函数去访问。

管程也是用来实现进程的同步和互斥的，而进程的同步和互斥就是由于进程要共享某一个资源导致的。

**管程：**

![image-20221207195541392](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221207195541392.png)

管程的基本特征：

1.局部域管程的数据这能被局部与管程的过程所访问。

2.一个进程只允许调用管程内的过程才能进入管程访问共享数据

3.**每次仅允许一个进程在管程内执行某个内部过程（相当于每次只有一个进程可以范围缓冲区）**

![img](https://img-blog.csdnimg.cn/20200409220031588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

用通俗一点的话来说：

互斥特性是编译器负责实现的

![image-20221207200631208](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221207200631208.png)

管程相当于应用了一个封装的思想，把需要的东西包装起来，对外只提供一个接口。



##2.4.1死锁的概念

**死锁：**在并发环境下，各个进程因为竞争资源而造成一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进** 的现象，发生死锁后如果没有外力干涉，这些进程都将无法向前推进。死锁肯定是两个及两个以上的进程发生死锁，同时不可能处于运行态。

三个容易混淆的概念：死锁、进程饥饿、死循环

![image-20221208195320984](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208195320984.png)



死锁产生的四个必要条件：

- **互斥条件**：必须对互斥使用的资源争抢
- **不可剥夺条件**：进程获得资源在未使用完前，不能由欠他进程强行剥夺，智能主动释放

- **请求和保持条件**：进程至少已经保持了一个资源，但是又提出了新的资源请求，而该资源又被其他进程占有，请求的进程被阻塞，自己又的资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程以获得的资源同时被下一个进程所请求

发生死锁一定有循环等待，但是循环等待未必死锁。



什么时候会导致发生死锁：==对与不可剥夺的资源的不合理分配，有可能会导致死锁==

![image-20221208200958974](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208200958974.png)

## 2.4.2死锁处理策略——预防死锁

破坏死锁产生的四个必要条件之一。

- 把独占使用的资源改造为运行共享使用的资源：SPOOLing技术
- 破坏不剥夺条件，让它被别的进程需要的时候，马上释放。容易导致前一阶段的工作失效，只适用于易保存和恢复状态的资源，比如CPU
- 破坏请求和保持：采用静态分配方法。![image-20221208201837791](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208201837791.png)
- 破坏循环等待：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208202132976.png" alt="image-20221208202132976" style="zoom:67%;" />

## 2.4.3死锁处理策略——避免死锁

动态策略：**安全序列和银行家算法**

**安全序列：**指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要找到一个安全序列，系统技术安全状态，当然安全序列可以有很多个（以BAT企业借钱为例）

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安去状态，如果有进程提前归还了一些资源，那么系统有可能重新回到安全状态。

如果处于安全状态就一定不会发生死锁，如果在不安去状态，就有可能发生死锁。

**银行家算法**：![image-20221208205015035](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208205015035.png)

![image-20221208205132365](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208205132365.png)



算法流程：

![image-20221208205645104](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208205645104.png)

```cpp
int Max[MAX][MAX]; // 最大需求矩阵max
int Allocation[MAX][MAX]; // 分配矩阵
int Need[MAX][MAX]; // 最多还需要资源矩阵
int Available[MAX]; // 可用资源向量
//安全性检查函数 
bool check() {
    int safeSeq[totalProcess];
    int work[totalResource];
    int count = 0; // 安全序列Cursor;
    bool finish[totalProcess];
    for(int i=0; i<totalProcess; i++) {
        safeSeq[i] = 0;
        finish[i] = false;
    }

    for(int i=0; i<totalResource; i++) {
        work[i] = Available[i];
    }
    int unfinished = totalProcess;
    bool flag;
    do {
        for(int i=0; i<totalProcess; i++) {
            if(finish[i] == false) {
                flag = true;
                for(int j=0; j<totalResource; j++) {
                    if(Need[i][j] > work[j]) {
                        flag = false;
                        break;
                    }
                }
                if(flag) {
                    finish[i] = true;
                    safeSeq[count++] = i;
                    for(int j=0; j<totalResource; j++) {
                        work[j] += Allocation[i][j];
                    }
                }
            }

        }
        unfinished--;

    } while(unfinished>0);
    flag = true;
    // 判断是否所有进程都完成
    for(int i=0; i<totalProcess; i++) {
        if(finish[i]==false) {
            flag=false;
            break;
        }
    }
    // 判断是否安全
    if(flag==false) {
        cout << "系统处于不安全状态！" << endl;
    } else {
        cout << "系统当前为安全状态，安全序列为：" << endl;
        for(int i=0; i<totalProcess; i++) {
            cout << safeSeq[i] << " ";
        }
        cout << endl;
    }
    return flag;
}
```

![img](https://img-blog.csdnimg.cn/42d8cd35e35242f0ab2a6931cf8b35be.png)

==主要是用来判断资源分配是否安全==



## 2.4.4死锁处理策略——检测和解除

这种策略允许死锁的发生，但是要在死锁发生之后及时检测到同时解除死锁。

**死锁检测：**

![image-20221208210817258](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208210817258.png)

如果：系统中剩余的可用资源数足够满足进程的需求，那么进程不会被阻塞会顺利执行下去。

![image-20221208211148842](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208211148842.png)

总结就是：一次消除与不阻塞进程相连的边，直到无边可消。



**死锁的解除：**

并不是系统中所有的进程都百分比是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程

![image-20221208211722351](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221208211722351.png)

进程回退不太容易实现



对谁动手？：

1. 进程优先级
2. 已经执行多长的时间（时间少的先噶了）
3. 还要多久能完成的
4. 进程资源的占用率（把更多资源的噶了）
5. 交互式的还是批处理式的（交互式对用户体验不好）



##3.1.1内存基础知识

**内存**：内存是用来存放数据的**硬件**

==程序执行前需要先放到内存中，才能被CPU处理。==

内存中也有一个一个的小房间，每个小房间就是一个“**存储单元**”，给每个存储单元编号，就可以区分程序在的数据具体是放在内存中的哪个位置。

而存储单元的编号称之为：**内存地址**

-  如果计算机按照“字节编址”则每个存储单元的大小为1字节，1B，即8个二进制位。
- 如果字长位16位的计算机，按字编址，则每个存储单元大小位1个字，每个字的大小位16个二进制位（2字节，现在都是64位，8字节）。

![image-20221209155457993](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209155457993.png)



**内存在进程运行过程中**：

指令，高级的编程语言------编译----》指令（本质是二进制语言）传递给CPU。

==指令一般放在程序段，内存的数据一般放在数据段==

![image-20221209160040307](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209160040307.png)



**什么是逻辑地址**，**什么是物理地址**？

![image-20221209160232174](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209160232174.png)

指令的地址也采取了这种思想，编译时产生的指令只关心“相对地址”，实际存放到内存中的时候在想办法根据其实位置得到“绝对地址”。

相对地址又称**逻辑地址**，绝对地址又称**物理地址**。

![image-20221209160559898](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209160559898.png)

==编辑---编译---链接---装入==

从逻辑地址到物理地址的转换主要是在**装入***这一部分要解决的问题。

装入模块中的指令地址是指“逻辑地址”，也就是相对于开始地址而言的，如果直接装到内存中，可能会有错：![image-20221209161027119](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209161027119.png)

三种装入的方式：

- **绝对装入**：在编译的时候就直到程序降放到内存中的哪个位置，编译程序将产生绝对地址的目标代码----》只适用于单道环境
- **静态重定位**：![image-20221209161304999](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209161304999.png)

是由装入程序推算的地址，静态重定位的特点是：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

- **动态重定位：**需要设置重定位寄存器。

![image-20221209161841784](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209161841784.png)



链接也有三种：

![image-20221209161939305](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221209161939305.png)

==链接完成后会形成完整的逻辑地址，装入之后会形成物理地址。==



## 3.1.2内存管理

操作系统在进行内存管理的时候做什么事情？

1. **内存空间的分配与回收**  
2. 提供（虚拟性技术）**从逻辑上对内存空间进行扩充**
3. 实现地址转换：负责程序的**逻辑地址与物理地址的转换**
   - 绝对装入：编译时产生绝对地址
   - 可重定位装入：装入时将逻辑地址转换位物理地址
   - 动态运行时装入：运行时将逻辑地址转换为物理地址，需要重定位寄存器（用的最多）
4. **内存保护**：需要保护操作系统不受用户进程影响，同时保护用户进程不受其他用户进程影响。（内存中分为分配给操作系统的，和其他用户进程的内存）：说简单点就是：让自己的进程只能访问自己对应的那块内存。
   - 设置上、下限寄存器，防止越界访问
   - 设置重定位寄存器和界地址寄存器（限长寄存器）



## 3.1.3覆盖于交换

覆盖与转换是**属于内存空间扩充**的技术：都是多道程序环境下用来扩充内存的两种方法。

**覆盖**：将程序分为多个段（也就是多个模块），常用的段就常驻内存，不常用的仅再需要的时候调入内存。

内存分：固定区和若干个覆盖区，需要常驻内存的段放在固定区，调入后就不再调出。

![image-20221211152044372](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211152044372.png)

缺点：必须由程序原声明覆盖结构，操作系统完成自动覆盖。缺点就是对用户不透明，增加了用户编程的负担。

基本不用了。



**交换（对换）技术**：当内存空间紧张的时候，系统将内存中某些进程暂时换出到辅存（外存）中，把外存中某些已经具备运行条件的内存换入到内存中（进程再内存与磁盘间的动态调度）

```c
补充内存条和硬盘的区别：1、首先是它们的作用，在电脑里面，系统和软件的运行空间是由内存条提供的。那么硬盘的作用是什么？硬盘则是负责为系统和软件提供储存空间的设备，在这点上这两者有着本质的区别。

3、在定义方面它们也有本质的区别，硬盘属于“只读存储器”，而内存属于“随机存取存储器”。对于数据读取来说，在电脑运行时，同样两个设备读取到了数据，一旦你给电脑断开电源，硬盘里的数据是保存着的，而内存条里读取的数据就没有了。

 1、外存：外储存器是指除计算机内存及CPU缓存以外的储存器，此类储存器断电后仍然能保存数据。

2、内存：也被称为内存储器和主存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。
```

而之前说的中级调度，就是一种交换技术。==PCB一般是常驻内存的==，为了找到对应的在外存中的程序

![image-20221211152913140](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211152913140.png)

详见2.2.2节。



有交换功能的操作系统通常回把磁盘分为文件区和对换区。

![image-20221211153540017](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211153540017.png)

但是==PCB是常驻内存的，不会被换出外存==

交换技术主要是在不同进程之间进行，而覆盖技术则主要是在一个程序或进程中实现的。



## 3.1.4连续分配管理方式

实现内存空间的分配与回收的工作：

- **连续分配管理方式**：指为用户进程分配的必须是一个连续的内存空间

  - 单一连续分配：不支持多道程序，系统中只会有一个用户程序。内存被分为：系统区和用户区，用户程序独占整个用户区的空间。![image-20221211155636473](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211155636473.png)

  - 固定分区分配：适用于多道程序系统，其实就是单一连续分配的一种进阶版，将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。![image-20221211160022005](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211160022005.png)

    系统中如何记录每个分区是否用过呢？建立一个分区说明表的数据结构

    优点：实现简单、无外部碎片

    缺点：当程序太大的时候，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，会降低性能；会产生内部碎片，使得内存利用率降低。

  - 动态分区分配：也被称之为可变分区分配，不会预先划分内存分区，进程装入内存的时候根据进程的大小动态建立分区。

    那么同时带来了三个问题：![image-20221211161045762](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211161045762.png)

    Q1:空闲分区表或空闲分区链

    Q2：动态分区分配算法，***

    Q3：对空闲分区表做一些操作就可以，比如删除结点。如果两个空闲分区相邻的话，将两个空闲分区合并成一个

  **关于内部碎片和外部碎片的问题**：![image-20221211162019563](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211162019563.png)

  可以通过**紧凑**技术来解决外部碎片。紧凑需要配合动态重定位寄存器，而且相对比较费时。

- 非连续分配管理方式：不一定连续，内存可能是离散的

 

## 3.1.5动态分区分配算法

**动态分区分配算法**：在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配的算法

- 首次适应算法(First Fit):从低地址开始查找，**找到第一个能满足大小的空闲分区**。空闲分区以地址**递增的次序排列**。每次分配内存时顺序查找空闲你分区表/链，找到大小能满足要求的第一个空闲分区。开销比较小，不需要分配完都对链表进行重新排列。

- 最佳适应算法(Best Fit)：为了让大进程到来的时候能有连续的大片空间，可以尽可能多留下大片空闲区域，所以**有限使用更小的空闲区**.按照容量递增的次序链接，顺序查找空闲分区表/链。缺点：每次都选最小的分配，会留下越来越多很小的，产生很多外部碎片。

- 最坏适应算法(Worst Fit):和最佳适应相反，**每次有限使用最大的连续空闲区**。按照递减排序。

- 临近适应算法（Next Fit）：是为了解决首次适应算法提出的，同样开销较小，一般会排列成一个循环链表

  ![image-20221211202014543](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211202014543.png)

首次适应不仅仅是最简单的，通常也是最好的。

##3.1.6基本分页存储管理的基本概念

 连续分配的方式主要是输入的进程/程序都要连着存在一起，能不能把程序或内存切开一块一块放进去，是不是就可以减少或者是消灭外部碎片。

**非连续分配：**为用户进程分配的可以是一些分散的内存空间

连续分配的缺点：![image-20221211202802419](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211202802419.png)

**基本分页存储管理**：把贮存空间划分为大小相等且固定的块，块相对小，使内部碎片小，内存利用率变高（是固定分区分配的非连续分配版本）

![image-20221211203736955](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211203736955.png)

如何实现：难点在于将进程机制空间分页之后，操作系统如何实现逻辑地址到物理地址的转换。只要知道模块在内存中的`起始地址+目标内存单元相对于起始位置的偏移量`

![image-20221211204740697](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211204740697.png)

 为了方便计算页号和页内偏移量，页面大小一般要为2的整数幂

![image-20221211205016638](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211205016638.png)

如果每个页面大小为2^k^B，则用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。

如果有M位表示页号，则说明在该系统中，一个进程最多允许有2^M^个页面

![image-20221211205954498](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221211205954498.png)

每个页表项的长度是相同的，页号是“隐含”的。

## 3.1.7基本地址变换机构

也是属于基本分页存储管理的一种。

基本地址变化是用于：实现逻辑地址到物理地址转换的一组硬件机构

通常在硬件端：会在系统中设置应该**页表寄存器（PTR）**，存放页表在内存中的**起始地址F和页表长度M**。进程还没有执行的时候，页表其实地址和页表长度会放在PCB中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

![image-20221212185740954](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212185740954.png)

**页表长度**：这个页表中总共有几个页表项（页表项第一部分是页号，第二部分是块号）

**页表项长度：**实质每个页表项占多大的存储空间

**页面大小**：一般指应该页面占多大的存储空间

![image-20221212190446034](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212190446034.png)





![image-20221212190652753](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212190652753.png)

一般在实际中，为了方便页表的查询，常常会让应该页表项占有更多的字节，使得每个页面恰好可以装得下整个页表项。

分页管理方式存在以下两个问题：

- 每次访问都需要逻辑地址---物理地址转换，地址转换过程必须足够快，否则访存速度会降低
- 页表不能太大，否则内存利用率很低



## 3.1.8具有快表的地址变换机构

- **局部性原理**

时间局部性：如果执行了程序中某条指令，那么不久后这条指令很有可能再被执行，数据访问后，有可能再被访问（因为程序中有大量循环）。

空间局部性：一旦访问了某个存储单元，在不久之后，其附近的存储单元耶很有可能被访问。（因为很多数据是连续存放的）

能否利用多次查找可能找到附近内存的结论，来得到多次查找都是同一个页表项这个特性呢？



- **快表（联想存储器TLB）**

是一种访问速度比内存快很多的告诉缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。于此对应，内存中的页表通常称为慢表。

![image-20221212193217104](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212193217104.png)

相当于放了一个快速表。

![image-20221212193909068](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212193909068.png)

![image-20221212194001232](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212194001232.png)

 

## ==3.1.9 两级页表==

- 单级页表存在的问题
  - 页表必须连续存放，当页表很大时，需要大量的连续空间在存放页表
  - 没有必要让页表都常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面
- ![image-20221212194927373](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212194927373.png)

为了知道离散分配的页表的先后顺序，久需要再建立一张表，称为**页目录表**，或称为外层页表，顶层页表。

![image-20221212195206417](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212195206417.png)

![image-20221212195449882](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212195449882.png)

面对第二个问题：可以用虚拟内存技术解决。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。

![image-20221212195807548](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221212195807548.png)

两级页表的访问顺序：

第一次：访问内存中的页目录表

第二次：访问内存中的二级页表

第三次：访问目标内存单元

n级页表访存次数是n+1.

## 3.1.10基本分段存储管理

分段存储和分页存储最大的区别就是——离散分配时所分配地址空间的基本单位不同。（同时段长是不一样的，而页长一定是一样的）

进程的地址空间：按照自身的逻辑关系划分位若干个段，每个段都有一个段名，段从0开始。**内存以段为单位进行分配，每个段在内存中占据连续空间，而且段之间可以不相邻。**

![image-20221213221333186](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213221333186.png)



在分段系统中，逻辑地址结构由：**段号（段名）**和**段内地址（段内偏移量）**所组成：

![image-20221213221628146](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213221628146.png)

如何实现从逻辑内存到物理内存的转换：使用段表来做映射，因为段长不太长，所以需要记录段长。

而每个段表项的长度（大小）是相同的：可以设定段表项长度为6B（6个字节），请按了个代表段长，后四个代表基址，段号是隐藏的。

和页表差不多，在进程没运行时段表的信息：段表始址、段表长度等都是放在系统区中的某些PCB中的，如果进程被调用就会马上把这两个信息放到段表寄存器中，再从段表寄存器中快速通过两个信息找到内存中段表的位置

![image-20221213223922464](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213223922464.png)

与分页最大的不同在于：一定要检查段内地址是否超过段长，如果W>=C 则产生越界中断，否则继续执行。



分页与分段的对比：

 ![image-20221213224525685](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213224525685.png)

- 分段比分页更容易实现信息的共享和保护，进程的同步只需要把段表中某一个段表项的段长和基址改的一样就可以，可以实现同一个段共享。![image-20221213225654319](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221213225654319.png)
- 不能被修改的代码称为纯代码或可冲入代码（不属于临界资源），这样的代码可以共享，可修改的代码不可以共享。
- 也是两次访问，也可以添加快表

## 3.1.11段页式管理方式

分段+分页的结合

分页：

- 优点：内存空间利用率高，不产生外部碎片，只有少量的页内碎片
- 缺点：不方便按照逻辑模块实现信息的共享和保护

分段：

- 优点：很方便按照逻辑模块实现信息保护和共享
- 缺点：如果段长过大，为其分配很大的连续空间会很不方便，另外段式管理会产生外部碎片（也可以紧凑解决，但是时间代价很大）

![image-20221219151050092](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219151050092.png)

先将进程分段后分页。再将内存空间分为大小相同的内存块，进程前将各页面装入内存块中。

![image-20221219151606286](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219151606286.png)

段号的位数决定了每个进程最多可以分几个段、页号的位数决定了每个段最大有多少页、页内偏移量决定了页面大小、内存块的大小是多少。

![image-20221219151723034](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219151723034.png)

每个段对应一个段表项，每个段表项由：段号、页表长度、页表存放块号（页表起始地址）组成。

段表只有一个，页表可能有很多个。

![image-20221219152019064](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219152019064.png)

![image-20221219152138458](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219152138458.png)



**3.1小结**

进行内存管理的目的：在多道批处理系统阶段，如果不对内存进行管理，容易导致内存数据的混乱，以至于限制进程的并发执行，为了更好地支持多道程序并发执行，必须进行内存管理

段式存储管理的方式主要是为了更好地满足用户的一系列要求：方便编程、共享和保护、动态链接和增长

对于主存储器的访问：是以字或字节为单位的。



## 3.2.1虚拟内存的基本概念

在上一节所学的内存空间的分配与回收中可以得知有：

![image-20221219161141904](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219161141904.png)

而针对内存的扩充：

- 覆盖技术
- 交换技术
- 虚拟存储技术

在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且从逻辑上扩充内存容量。



虚拟内存技术是基于之前提到的局部性原理中的告诉缓存技术。

对于传统的存储管理方式的缺点：一次性、驻留性。

![image-20221219161928473](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219161928473.png)

 

高速缓存技术：将近期会频繁访问到的数据放到更告诉的存储器中，暂时用不到的数据放在更低俗存储器中。

![image-20221219162513492](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219162513492.png)



虚拟内存技术：基于局部性原理，在程序装入时，可以将很快可以用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行

![image-20221219163259759](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219163259759.png)

![image-20221219163358429](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221219163358429.png)

虚拟内存有以下几个特征：

- 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
- 对换性：在作业运行时无需一直常驻内存，允许作业运行过程中，将作业换入换出。
- 虚拟性：从逻辑上扩充了内存的容量，用户看到内存容量远大于实际容量



实现方法：离散分配的内存管理

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

主要的区别在于：在程序执行的过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行。如果内存空间不够用，由操作系统负责将内存中暂时用不到的信息换出到外存。==也就是请求调页和页面置换功能==



## 3.2.2请求分页管理方式

是在基础分页存储的基础上建立的，主要还要补充两个功能：

- 请求调页：当访问的信息不在内存中时，由操作系统负责将所需的信息从外存调入内存。

- 页面置换：若内存空间不够用，由操作系统负责将内存中暂时用不到的信息换出到外存。

![image-20221220152340571](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220152340571.png)

新增了四个东西：状态位、访问字段、修改位、外存地址

**缺页中断机构**：

**缺页中断是属于内中断**，一条指令可以会访问多个内存单元，而这些内存单元有可能在多个页表中，所以可能多次缺页中断。 ![image-20221220153146727](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220153146727.png)

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

这一过程中会产生IO操作，此时**缺页的进程阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

![image-20221220152855509](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220152855509.png)

![image-20221220153646503](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220153646503.png)

## 3.2.3 页面置换算法

页面置换算法就是要选择把哪个页面换出去

页面的换入换出需要磁盘的I/O开销，因此需要追求更少的缺页率。

五种页面置换：

- 最佳置换算法（OPT）：每次淘汰的是以后永远不使用，或者在最长时间内不再被访问的页面。要看后面出现的！！ 操作系统根本无法预知未来要访问的是哪个页面，所以最佳置换算法是无法实现的，但是它的性能是最好的。
- 先进先出置换算法（FIFO）：淘汰的页面是最早进入内存的页面。算法性能很差。

![image-20221220160801161](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220160801161.png)

- 最近最久未使用置换算法（LRU）：淘汰最近最久未使用的页面。

实现的方法是：赋予每个页面对应的页表项中，用**访问字段**记录该页面自上次被访问以来所经历的时间t。需要淘汰的时候，选择t最大的淘汰。**虽然算法性能很好，但是实现困难，需要专门的硬件支持，开销很大。**性能最接近OPT

- 时钟置换算法（CLOCK）：性能和开销较为均衡的算法，又称之为最近未用算法（NRU）
  - 简单的时钟算法：![image-20221220162619280](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220162619280.png)
  - 
- 改进型的时钟置换算法
  - 改进的时钟算法：事实上，如果被淘汰的页面没有被修改过，就不许套执行I/O操作写回外存，**因为外存中那个并没有什么变化，只有被修改过的页面被淘汰了才需要写回外存**

![image-20221220163726862](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220163726862.png)

优先级：最近没访问+没修改、最近没访问+修改、最近访问过+没修改、最近访问过且修改过。

![image-20221220164324410](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220164324410.png)

注意点：

1. 缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换

## 3.2.4页面分配策略

**驻留集**：指请求分页存储管理中给进程分配的物理块的集合。

![image-20221220165013244](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220165013244.png)

![image-20221220165047938](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220165047938.png)

 ![image-20221220165330190](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220165330190.png)



1. 固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变，如果缺页，只能从该进程在内存中的页面中选一页换出，再调入需要的页面。
2. 可变分配全局置换： ![image-20221220165634271](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220165634271.png)

锁定的是一些不能被换出外存的数据。

	3. 可变分配局部置换：![image-20221220165842330](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220165842330.png)



那么何时调入页面呢？

- 预调页策略：根据局部性原理，一次调入若干个相邻的页面比一次一个更高效。但是预测成功率不高，主要用于进程的首次调入，由程序员指出应该先调入哪些部分。
- 请求调页策略：进程在运行期间发现缺页的时候才将所缺页面调入内存。每次都要I/O，开销较大。

从何处调入页面？

对换区的读写速度快，采用连续分配方式；读写区的速度慢，采用离散分配的方式。

![image-20221220171238199](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220171238199.png)

**抖动和颠簸现象**：

抖动（颠簸）：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动/颠簸。

产生抖动的主要原因是：进程频繁访问的页面数目高于可用的物理块数（分配给i进程的物理块不够、也可以说是置换算法不合理）

![image-20221220171550463](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221220171550463.png)

驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页。



虚拟内存的特征：多次性、对换性、离散性。

##4.1.1初识文件管理

 操作系统作为系统资源的管理者需要完成：处理机管理、存储器管理、文件管理、设备管理。

而文件就属于是系统资源的一部分。

**文件：**是一组有意义的信息/数据的集合

而不同的文件有不同的属性。

在系统运行的时候，计算机以进程为基本单位进行资源调度和分配，在用户进行的输入、输出中，则以文件为基本单位。



**文件的属性**：

- 文件名
- 标识符：一个系统内的各个文件的标识符唯一
- 类型
- 位置
- 大小
- 创建时间、上次修改时间、文件所有者信息
- 保护信息



**文件的逻辑结构**：

- 无结构文件（比如文本文件），由一些二进制或者字符流组成，又称为流式文件。
- 有结构文件（比如数据库表），由一组相似的记录组成，又称”记录式文件“，而比如excel中每一列就是一个数据项，记录的是一组相关数据项的集合

![image-20221222150303352](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222150303352.png)



**操作系统应该向上提供哪些功能？**

- 在新建文件的时候，实质是使用了操作系统的**create系统调用**这个功能，创建好一个文件之后回放在外存，在系统需要的时候再调入内存。

- 在读文件的时候，要使用read系统调用。

- 写文件---->,write系统调用，将数据从内存写回外存。
- 删除文件，delete系统调用，将文件数据从外存中删除。
- 打开文件，open系统调用
- 关闭文件，close系统调用



**文件应该如何存放在外存中**？

由于外存属于硬件，而OS又是最接近硬件的，所以文件数据的存放到外存基本依靠OS

![image-20221222151748581](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222151748581.png)

## 4.1.2文件的逻辑结构

 所谓的逻辑结构，就是指用户看来，文件内部的数据应该是如何组织的。

而物理结构应该是在操作系统看来，文件中的数据是如何存放在外存中的。

![image-20221222155307804](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222155307804.png)

由此可见，算法的具体实现于逻辑结构和物理结构都有关系

**按照文件是否有结构分类，可以分为无结构文件、有结构文件两种。**

 ![image-20221222155838845](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222155838845.png)

 根据各条记录的长度（占用的存储空间）是否相等，又可以分为定长记录和可变长记录两种

对于有结构文件：

- 顺序文件：文件的记录一个接一个顺序排列，可以定长可以变长

![image-20221222160700732](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222160700732.png)

定长可以实现随机存取，可变长不可以。

- 索引文件：

为了改变可变长记录文件查找慢这一特性，创建一张索引表以加快文件检索的速度，每条记录对应一个索引项

![image-20221222161555141](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222161555141.png)

- 索引顺序文件

针对索引文件的缺点：每个记录对应一个索引表项，因此索引表看你回很大，占用很大的空间

 索引顺序文件也是建立了一张索引表，但是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项

![image-20221222162155859](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222162155859.png)

为了进一步提高检索效率，可以为顺序文件建立多级索引表。

##4.1.3文件目录

文件目录类似树的形式，使得文件之间的组织清晰便于查找。

![image-20221222162821208](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222162821208.png)



1.**文件控制块**：

文件控制块其实就是一个文件目录表中的一个文件记录（FCB），里面每一个目录项其实就是一种有结构的文件，包含了文件的信息

![image-20221222163144349](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222163144349.png)

FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等）

最重要的还是==文件名、文件存放的物理地址。==

**FCB实现了文件名和文件物理地址之间的映射，使用户可以是按按名存取。**

 

2.**目录结构——单级目录结构：**

- 单级目录：整个系统中只建立一张目录表，每个文件占一个目录项，所以不允许文件重名，因为要按名存取。

- 两级目录结构：分为住文件目录（MFD）和用户文件目录（UFD）

![image-20221222165537648](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222165537648.png)

- 多级目录结构

绝对路径：从根目录出发

![image-20221222165754624](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222165754624.png)![image-20221222165755236](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222165755236.png)

如果使用相对路劲的好处就是磁盘的I/O次数减少了，提升了访问文件的效率。

但是树形结构不便于实现文件的共享，为此提出了”无环图目录结构“

- 无环图目录结构

在树形目录结构的基础上，增加一些指向同一节点的有向边

可以用不同文件名指向同一个文件/目录。需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点，用户删除的时候只是删除该用户的FCB，并使共享技术器-1，并不会直接删除共享结点。



**索引结点**：

索引结点是对FCB的一种改进。

![image-20221222171414843](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222171414843.png)

![image-20221222171600954](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221222171600954.png)

存放在外存中的索引结点称为：磁盘索引结点，当索引结点放入内存后称为内存索引结点，==相比之下，内存索引结点中需要增加一些信息，比如：文件是否被修改，有几个进程在访问该文件等。==

目录项中只包含文件名、索引结点指针，因此每个目录项的长度大幅减小

由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O次数就少了很多。

在文件系统中：==口令、存取控制、用户权限表都是常用的文件保护方法==



## 4.1.4文件物理结构

文件的物理结构也称之为文件的分配方式。

也就是==文件数据如何存放在外存中==：

- 连续分配
- 链接分配
  - 隐式链接
  - 显式链接
- 索引分配

关于磁盘块和内存块的知识点补充：

![image-20221224150747257](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224150747257.png)

常常会将磁盘块的大小和内存块、页面的大小设置的相同，方便I/O读写操作。

在内存管理中，进程的逻辑地址空间被分为一个一个页面。那么同样的，在外存管理中，为了方便对文件数据的管理，**文件的逻辑地址空间也被分为了一个一个的文件块**，于是文件的逻辑地址也可以表示为：（逻辑块号，块内地址）的形式。



1. **连续分配**

每个文件可能占多个块，这多个块逻辑上相邻，物理块号上也相邻。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224151709758.png" alt="image-20221224151709758" style="zoom:50%;" />

操作系统要先找到该文件对应的目录项FCB，物理块号=起始块号+逻辑块号

支持顺序访问和随机访问。



在读取某个磁盘块的时候，需要移动磁头，访问的连个磁盘块越远，移动磁头所需要的时间越长。

优点：==所以连续分配的文件在顺序读写的时候速度最快。==

缺点：连续分配不方便文件扩展；物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片，可以使用紧凑来处理碎片，但是需要花费很大的时间代价。



2. **链接分配**：采用离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示链接两种。

隐式链接：![image-20221224153433916](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224153433916.png)

优点：采用隐式链接的链接分配方式，很方便文件拓展，另外所有空闲磁盘块都可以被利用，没有碎片问题，外存利用率很高。

显式链接：

把用于链接文件各物理块的指针显式存在一张文件分配表中（FAT），每个磁盘仅设置一张FAT，开机的时候将FAT读入内存，并常驻内存。FAT的每个表项在物理上连续存储，且每个表项的长度相同。

![image-20221224153923893](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224153923893.png)

支持随机访问和顺序访问，由于块号转化的过程不需要访问磁盘，因此访问速度会快很多。

![image-20221224154116610](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224154116610.png)

不能有效的支持直接分配。

3. **索引分配**

索引分配允许文件离散分配在各个磁盘中，系统为每个文件建一张索引表（之前是一个磁盘一张表），索引表中记录了文件的各个逻辑块对应的物理块，**索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。**

![image-20221224162605885](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224162605885.png)

支持随机访问，方便扩展。但是索引表会占用内存。

为了解决一个文件的磁盘块索引表内存太大的问题：

- 链接方案：分配多个索引块，链接起来存放。在第一个索引表后面放一个指向第二个的块的指针。![image-20221224163107526](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224163107526.png)
- 多层索引：建立多层索引块![image-20221224163740938](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224163740938.png)

采用K层索引结构，且顶级索引表调入内存，则访问一个数据块只需要K+1次读磁盘操作。

- 混合索引

![image-20221224164413725](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224164413725.png)

总结：

![image-20221224164657083](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224164657083.png)



## 4.1.5文件存储空间管理

主要是对空闲磁盘块的管理。

比如windows中必经的步骤就是为磁盘分区。而每个存储空间的划分为一个个文件卷（逻辑卷、逻辑盘）

而每个卷又会被分为：

- 目录区：文件目录信息（FCB）、用于磁盘存储空间管理的信息
- 文件区：存放普通的文件数据

存储空间的管理方法：

1. **空闲表法**：属于连续分配方式，创建一张空闲盘块表，记录连续的空闲块的块起始位置和块数。

![image-20221224184246072](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224184246072.png)

同样可以使用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。

![image-20221224184714832](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224184714832.png)

2. **空闲链表法**：

   - 空闲盘块链：以盘块为单位组成一条空闲链
   - 空闲盘区链：以盘区为单位组成一条空闲链

   ![image-20221224185008218](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224185008218.png)

**空闲盘块链**：系统会保存着链头和链尾的指针，分配的时候会从链头开始一次摘下K各盘块分配，并修改空闲链的链头指针。回收的时候盘块以此挂到链尾，并修改空闲链的链尾指针。

**空闲链表法**：也是保存链头、链尾指针

![image-20221224185748514](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224185748514.png)

 分配多个磁盘块空间的时候效率更高。

3. **位示图法**：

用一个二进制位对应一个盘块，位式图一般用连续的字来表示。可以用字号和位号对应一个盘块号，（字号，位号）=（i，j）的二进制位对应的盘块号b=ni+j，n代表字长。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224190234610.png" alt="image-20221224190234610" style="zoom:80%;" />

![image-20221224190757974](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224190757974.png) 



4. **成组链接法**：

空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或者空闲链表可能过大。所以需要采用成组链接法：

超级块会记录下一组空闲盘块的块数很空闲盘块的块号，每个分组中的块号不一定要连续，每个分组的盘块数有限制。 

![image-20221224191629595](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224191629595.png)

- 每次分配的时候先检查每个分组的内存是否足够，分配第一个分组之后由于第一个分组还存放了下一个分组的信息，所以要把下一个分组的数据赋值到超级块中。超级块相当于一个链头的作用。
- 如何回收：假设没满的分组都可以回收

##4.1.6文件的基本操作

向上的几个基本的功能：

![image-20221224192834797](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224192834797.png)

1.在进行create系统调用的时候，需要先在外存中找到文件所需的空间、其次需要根据文件存放的路径信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。

2.delete调用是找到文件存放路径对应的目录文件，从目录中找到文件名对应的目录项。根据目录项，回收文件占磁盘块，从目录中删除文件对应的目录项。

3.打开文件，open系统调用![image-20221224194033243](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224194033243.png)

复制进内存中的“打开文件表”中，并将对应的表目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件。复制进内存的优点在于：之后用户进程再操作文件就不需要每次都重新查目录了，加快了文件的访问速度

打开文件表有系统的和进程的，进程的打开文件表有很多一个进程一个，系统的只有一张，如果多个进程打开文件表他们会共同指向系统的那个表的那一个打开项。

![image-20221224194523883](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221224194523883.png)



读文件写文件之前都要打开文件，打开问就按需要文件名，后续就不用了。

写文件需要指明文件在打开文件表的位置、还需要指明要写出多少数据、写回外存的数据放在内存中什么位置。

## 4.1.7 文件共享

让多个用户共享的使用同一个文件：

- 基于索引结点的共享方式（硬链接）

索引结点，是文件目录的瘦身策略，由于检索文件时只需要用到文件名，**因此可以将除了文件名之外的其他信息放到索引结点指针中**。这样目录项就只需要包含文件名、索引结点指针。

![image-20221226161221837](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226161221837.png)

让不同用户指向同一个索引结点，同时索引结点内部设置链接技术变量count，用于表示链接到本索引结点上的用户目录项数目。文件名可以不同。

==只有当count为0的时候才能真正删除文件数据和索引结点，否则会导致指针悬空==

- 基于符号链的共享方式（软链接）

先判断文件是否属于Link类型文件，于是会根据其中记录的路径层层查找目录。

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226161731553.png" alt="image-20221226161731553" style="zoom:80%;" />

相当于Windows下的快捷方式，就是一种软链接。如果文件已经被删除了，那么软链接就会失效。

软链接会比硬链接要慢，因为要一层一层进行I/O操作

## 4.1.8文件保护

为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，也就是对文件的读、写、执行的许可问题。

1. 口令保护

​		相当于给文件设置一个口令，用户请求访问的时候必须提供口令。口令一般存放在对应的FCB或者索引结点中。操作系统会负责进行比对。

优点：保存口令的空间开销不多，验证口令的时间开销也很小

缺点：正确的口令存放在系统内部，不够安全

2. 加密保护

​		使用某个密码对文件进行加密，比如异或加密	，保存的是加密后的结果。

![image-20221226163645883](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226163645883.png)优点：保密性强、不需要在系统中存储密码

缺点：编译/编码需要花费一定时间

3. 访问控制

​		在每个文件的FCB（或者索引结点）中增加一个访问控制表（ACL），该表中记录了各个用户可以对该文件执行哪些操作。

![image-20221226164659013](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226164659013.png)

当系统的用户太多的时候，由于长度无法预计并且可能导致复杂的空间管理，可以使用**精简的访问列表**可以解决这个问题。

![image-20221226165044337](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226165044337.png)

**访问控制的安全性较差，但是灵活性较高**

## 4.1.9文件系统的层次结构

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221226170547737.png" alt="image-20221226170547737" style="zoom:67%;" />



**用户接口**--->（提供的是文件存放的路径，因此需要操作系统查找对应的目录项）**文件目录项**--->（检查是否有访问权限）**存取控制模块**--->（把用户提供的记录号转变为逻辑地址）**逻辑文件系统与文件信息缓冲区**--->（把逻辑地址转换成实际的物理地址）**物理文件系统**--->(要删除某条记录，要对磁盘发出请求)**设备管理程序模块**--->(出现空闲盘块，要将盘块回收)**辅助分配模块**



**本节课后题知识点**：

- 文件的物理结构包括连续、链接、索引三种，其中链式结构不能实现随机访问，连续结构文件不易于扩展。索引结构支持随机访问且易于扩展
- 为了实现最快速度的随机访问要采用连续结构。
- 文件的存储空间管理实质上是对外存空间的组织和管理
- 



## 4.2.1磁盘的结构

**磁盘**：磁盘的表面是由一些磁性物质组成，可以用这些磁性物质来记录二进制数据

**磁道**：磁盘的盘面被划分为一个一个的磁道，一个圈就是一个磁道

**扇区**：每个磁道被扇形分隔，每个扇区就是一个磁盘块，每个扇区固定存储大小

![image-20221227141953505](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227141953505.png)



最内侧扇区面积最小，数据密度最大。

**读取数据**：把磁头移动到想要读写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，就可以完成对扇区的读写操作。



![image-20221227142340842](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227142340842.png)

文件的物理地址可以用：柱面号、扇面号、扇区号来决定。



**磁盘的分类**：

- **活动头磁盘**：磁头可以移动，靠磁臂来回伸缩来带动磁头定位磁道
- **固定头磁盘**：磁头不可以移动，每个磁道都有磁头。
- **可换盘磁盘**：盘片是否可以更换。
- **固定盘磁盘**：



## 4.2.2磁盘调度算法

1. 一次磁盘读/写操作需要的时间

- **寻找时间Ts**:在读写/数据之前，将磁头移动到指定磁道所花的时间。
- **延迟时间T~R~**：通过旋转磁盘，使磁头定位到目标扇区需要的时间，平均延迟时间Tr=（1/2）*（1/r）=1/2r，r为磁盘转速。（1/r为旋转一圈所需时间，找到目标扇区平均所需转半圈）
- **传输时间T~t~**：![image-20221227145123559](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227145123559.png)

延迟时间和传输时间都与磁盘的转速有关，且都线性相关，没办法通过软件优化，只能靠硬件。

而操作系统唯一可以优化的就是寻道时间（寻找时间），不同的磁盘调度算法会直接影响寻道时间。



2.　磁盘调度算法：

- 先来先服务![image-20221227145605935](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227145605935.png)

- 最短寻找时间优先　：相当于是贪心，每次选择眼前最优

优点：性能较好，平均寻道时间短

缺点：可能会产生饥饿现象，只要在一个小区域内有源源不断的请求进来，就会一直在这个范围活动

- 扫描算法（电梯算法）：只有磁头移动到最外侧磁道的时候才可以向内移动，移动到最内测磁道的时候才可以向外移动

![image-20221227151147609](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227151147609.png)

- LOOK算法：是扫描算法的第一种改进，如果再磁头移动方向上已经没有别的请求了，就可以立即改变磁头移动方向。
- 循环扫描算法：解决响应频率不平均的问题![image-20221227151942127](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227151942127.png)
- C-LOOK算法：![image-20221227152111376](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227152111376.png)

寻道时间对一次磁盘访问来说影响最大。同一个盘面不同磁道比同一个柱面不同盘面的花费要高。



## 4.2.3 减少延迟时间的方法

延迟时间，是将目标扇区转到磁头下面所花的时间

比如要连续读取2、3、4扇区，读取完2后需要一段时间的处理，无法连续不断的读入3号扇区，必须等盘片继续旋转，再次经过3号扇区的时候才可以完成读入。

- **采用交替编号的策略**，

  让相邻的扇区再物理上有一定间隔

柱面号，盘面号，扇面号，一定要按照这个规则，读取地址连续的磁盘块的时候减少柱头移动时间

- **错位命名**：就是让上下盘面对应的扇区错开一个单位

![image-20221227161120330](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227161120330.png)

## 4.2.3磁盘管理

1. 磁盘初始化：

​		进行低级格式化（物理格式化），磁道划分为扇区，一个扇区可以分为：头、数据区域、尾三个部分，管理扇区的数据结构放在头尾两个部分。

​		将磁盘分区，每个分区由若干柱面构成，分成熟悉的C\D\E盘![image-20221227161916036](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227161916036.png)

​		进行逻辑格式化，创建文件系统。



2. 引导块

​		计算机开机的时候需要进行一系列初始化工作，这些工作通过初始化程序（自举程序）完成。

![image-20221227162148337](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227162148337.png)

但是不能保证自居程序永远不变，所以只在ROM（只读指令块）上放入很小的自举装入程序，完整的自举程序放在磁盘的启动块（引导块）上，启动块位于磁盘的固定位置处。



3. 坏块

​		坏块是硬件故障，操作系统无法修复，能做的就是把它标记出来。

![image-20221227163244636](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227163244636.png)

![image-20221227163332871](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221227163332871.png)



## 5.1.1 I-O设备的概念和分类

I-O 指的就是输入输出input和output。I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件设备。比如典型的鼠标键盘，显示器，USB盘。

对于UNIX系统，将外部设备抽象尾一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。

- Write操作：向外部设备写出数据
- Read操作：向外部设备读入数据

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230153338804.png" alt="image-20221230153338804" style="zoom:50%;" />

人机交互类的速度最慢（每秒几个到几百个字节）、存储类的速度最快（没秒数千字节到数千兆字节）、网络通信类（每秒数千至上万个字节）的介于二者之间。



按照信息交换的单位分类：

- 块设备：如 磁盘，数据传输的基本单位是块。
  - 传输速率高，可寻址，即随机读写任意一块
- 字符设备：鼠标键盘，数据传输的基本单位是字符
  - 传输速度较慢，不可寻址，在输入输出时常采用中断驱动方式。



##5.1.2 I/O控制器

IO设备：

- 机械部件
- 电子部件（IO控制器、设备控制器）

CPU无法直接控制IO设备的机械部件，而是通过IO设备中的一个电子部件作为CPU和IO设备机械部件之间的中介，从而实现CPU对设备的控制。

电子部件就是IO控制器，又称设备控制器

![image-20221230155047372](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230155047372.png)

- 控制寄存器：存放CPU发来的命令和参数
- 状态寄存器：记录IO设备当前状态
- 数据寄存器：输出时，数据寄存器暂存CPU发来的数据，时候再....





**IO控制器的组成**

- CPU与控制器之间的接口（实现控制器与CPU之间的通信）
- IO逻辑（识别CPU发出的命令，并向设备发出命令）
- 控制器与设备之间接口（实现控制器与设备之间的通信 ）

![image-20221230160551481](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230160551481.png)

一个IO控制器可能会对应多个设备，所以需要多个这种数据寄存器、控制寄存器、状态寄存器来记录它们的状态。所以数据、状态、控制寄存器可能有多个。且这些寄存器都要有相应的地址，才方便CPU操作。





而这些寄存器的地址也需要存储方式：

![image-20221230160810900](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230160810900.png)

- 内存映像I/O![image-20221230161319723](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230161319723.png)

控制寄存器中的寄存器与内存地址统一编址。

- 寄存器独立编址

![image-20221230161428409](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230161428409.png)

不会和内存的地址空间连续编址。

缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。



## 5.1.3 I/O控制方式

I/O控制的方式：

- 程序直接控制方式
- 中断驱动方式
- DMA方式
- 通道控制方式



1.**程序直接控制方式**：

完成一次读写操作的流程：==轮询==

- CPU通过控制线向控制器发出读指令，设备启动，状态寄存器设为1
- 轮询检查控制器的状态，一直为1就不行。 

![image-20221230163725211](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230163725211.png)

![image-20221230163812224](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230163812224.png)

CPU干预的频率：由于需要轮询，所以CPU的干预非常频繁

数据的传送单位：每次读写一个字

数据的流向：

- 读操作（数据输入）：I/O设备---CPU---内存
- 写操作（数据输出）：内存---CPU---IO设备

每个字的读写都需要CPU的帮助



程序直接控制方式的优缺点：

优点：实现简单，在读写指令后加上实现循环检查的一系列指令即可

缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查，长期处于忙等，CPU利用率低。



2. **中断驱动方式**：

​		IO设备的速度很慢，因此在CPU发出读写命令后，可以将等待IO的进程阻塞，切换到别的进程执行。当IO完成后，控制器会像CPU发送一个中断信号，CPU检测到中断信号后，会保存当前进程运行环境去处理中断，然后玩出读字的操作。

![image-20221230165815771](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230165815771.png)

优缺点：

优点：通过中断信号主动报告IO完成状态，不需要轮询，CPU和IO设备可以并行工作，CPU利用率明显提高。

缺点：每次传一个字，每个字在IO设备与内存之间的传输需要中断，会消耗较多CPU时间。



3. **DMA方式**

direc memory accss 直接存储器存取，主要用于块设备的IO控制。

- **主要用于块设备的IO控制**，数据的传送单位是块，不再是一个字一个字的传送。

- s护具的流向是从设备直接放入内存，或者从内存直接到设备，不再需要CPU中介
- 只在传输开始结束才需要CPU处理中断。

![image-20221230171042700](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230171042700.png)



DMA控制器结构：

通过系统总线将控制器和内存也相连，从而减少CPU的干预

![image-20221230172558810](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230172558810.png)

每次也是一个字一个字存放在DR中，然后再一整个放回去。

数据流向：

- 读操作：IO设备->内存
- 写操作：内存->IO设备

![image-20221230185202774](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230185202774.png)



4. **通道控制方式**

​		**通道**：是一种硬件，可以理解为弱化的CPU，通道可以识别并执行一系列通道指令。

![image-20221230185920651](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230185920651.png)

可以再进一步降低CPU的干预频率：CPU干预频率极低，可以一次给通道内放很多程序，让他自己慢慢干。

![image-20221230190209730](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230190209730.png)





四种控制方式总结：

![image-20221230190230633](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230190230633.png)

通道与一般处理及的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机内存中的，也就是说通道与CPU共享内存。

![image-20221230191509196](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230191509196.png)

## 5.1.4 IO软件层次结构

![image-20221230192858591](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230192858591.png)

每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，并向高层提供服务。

- 用户层软件：向上**实现与用户的交互接口，库函数**，向下**调用下层的系统调用**，请求操作系统内核服务

- 设备独立性软件（设备无关性软件）：1.提供系统调用 2.设备保护，提供不同的权限 3. 差错处理 4.设备的分配与回收  5.数据缓冲区管理：通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。6.建立逻辑设备名到物理设备名的映射

- 设备驱动程序：主要负责对硬件设备的具体化控制，将上层发出的一系列命令转化成特定设备的操作。包括设置寄存器、检查设备状态等。

![image-20221230221614102](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230221614102.png)

驱动程序一般会以应该独立进程的方式存在。

- 中断处理程序： 

![image-20221230222205181](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221230222205181.png)

只有设备驱动程序、中断处理程序会直接和设备硬件打交道，别的没有涉及硬件。



字节多通路一般用作链接大量的低速或中速IO设备



##5.1.5 IO核心子系统

I/O核心子系统也称I/O系统，属于操作系统内核部分，也就是IO软件层次中的：

- 设备独立性软件
- 设备驱动程序（直接与硬件相关）
- 中断处理程序（直接与硬件相关）

三个部分。

![image-20230101152703052](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101152703052.png)

IO调度算法其实就是：用某种算法确定一个好的顺序来处理各个IO请求

![image-20230101153318127](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101153318127.png)

设备保护：不同的用户对不同的文件有不同的访问权限。UNIX中把设备看成一种特殊的文件，也相当于对设备看成一种文件进行权限设置。



##5.1.6 假脱机技术/**SPOOLing**

SPOOLing技术主要是在用户层软件实现的。

什么是脱机技术：脱离主机的控制进行输入和输出操作

![image-20230101154241469](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101154241469.png)



假脱机技术是利用软件的方式模拟脱机技术，SPOOLing系统的组成如下：

![image-20230101154451624](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101154451624.png)

在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后再转存到输入井中。

同理在输出进程的控制下，输出缓冲区用于暂存从输出井送来的数据，之后再传送到输出设备上。

![image-20230101154900749](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101154900749.png)

先为进程在**磁盘**中申请一个缓冲区，也就是在输出井那里，使每个进程都觉得自己在独占一台打印机



SPOOLing技术可以把一个物理设备**虚拟**成逻辑上的多台设备，**可以将独占式设备改造成共享设备。**



## 5.1.7 设备的分配与回收

设备分配的时候需要考虑的因素

- 设备的固有属性
  - 独占设备：一个时段只能分配给一个进程
  - 共享设备：可以同时分配给多个进程使用
  - 虚拟设备：SPOOLing技术后的虚拟设备
- 设备分配算法：先来先服务、短任务优先....
- 设备分配中的安全性
  - 安全分配方式：为进程分配一个设备后将其阻塞，完成本次IO后才将进程唤醒
  - 不安全分配方式：会一直发送新的IO请求，直到某个IO请求得不到满足才将进程阻塞



静态分配和动态分配：

- 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源
- 动态分配：进程运行过程中动态分配



![image-20230101160422582](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101160422582.png)

设备控制表(DCT)，记录设备的情况，每个设备一张：

![image-20230101160523592](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101160523592.png)

控制器控制表（COCT）：

通道控制表（CHCT）

系统设备表（SDT）：记录了系统中全部设备情况，每个设备对应一个表



设备分配的步骤：

1. 根据进程请求的设备名查找SDT
2. 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。
3. 根据DCT找COCT，找到控制器
4. 找CHCT。分配通道

只有当设备、控制器、通道三者都分配成功的时候，这次设备分配才算成功，之后便可以启动IO设备进行数据传输。



改进后的：用逻辑设备名映射物理设备名

![image-20230101162142960](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101162142960.png)



## 5.1.8 缓冲区管理

**缓冲区**：就是应该存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。

![image-20230101163228028](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101163228028.png)

大部分情况下，还是用内存作为缓冲区，设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区。



缓冲区的作用：![image-20230101163347259](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101163347259.png)

![image-20230101164156559](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101164156559.png) 

缓冲区管理的策略：

- 单缓冲：操作系统会在主存中分配一个缓冲区（一个缓冲区就是一个块）

![image-20230101164452607](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101164452607.png)

结论：采用单缓冲策略，处理一块数据平均耗时Max（C,T）+M

- 双缓冲

![image-20230101164945172](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101164945172.png)

结论：采用单缓冲策略，处理一块数据平均耗时Max（T,M+C）



在两台设备通信的时候也可以用单/双缓冲：

如果只有单缓冲，那么只能同一时间单向通信

配置双缓冲区可以在同一时间实现双向数据传输



管道通信中的管道就是一个缓冲区。



- 循环缓冲区![image-20230101165353312](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101165353312.png)

- 缓冲池：

![image-20230101165425126](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230101165425126.png)
