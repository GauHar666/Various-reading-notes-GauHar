HOT100+随想录复习

![image-20221229105900660](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221229105900660.png)

![image-20221229105917335](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221229105917335.png)

![image-20221229105935497](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221229105935497.png)

![image-20221229105952799](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221229105952799.png)



## 1.两数之和

==对应映射的方法遇到相同元素做不出，下面这个方法要牢记，哈希表取元素是用->不是点==

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            auto iter = mp.find(target-nums[i]);
            if(iter!=mp.end()){
                return {iter->second,i};
            }
            mp.insert(make_pair(nums[i],i));
        }
        return {-1,-1};
    }
};
```

## 2.两数相加

==`||preval>0`==

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* cur1=l1;
        ListNode* cur2=l2;
        ListNode* dummyHead=new ListNode(0);
        ListNode* cur=dummyHead;
        int preVal=0;
        while(cur1!=nullptr || cur2!=nullptr || preVal>0){
            int curSum=preVal;
            if(cur1!=nullptr){
                curSum+=cur1->val;
                cur1=cur1->next;
            }
            if(cur2!=nullptr){
                curSum+=cur2->val;
                cur2=cur2->next;
            }
            preVal=curSum/10;
            curSum=curSum%10;
            cur->next=new ListNode(curSum);
            cur=cur->next;
        }
        return dummyHead->next;
    }
};
```

## 3.无重复字符的最长子串

经典滑动窗口类型题目，两个while，第二个while控制窗口减小。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> mp;
        int left=0,right=0,len=0;
        while(right<s.size()){
            char c=s[right];
            mp[c]++;
            right++;
            while(mp[c]>1){
                char d=s[left];
                mp[d]--;
                left++;
            }
            len=max(len,right-left);
        }
        return len;
    }
};
```

## ==4.寻找两个正序数组的中位数（二分）==

如果时间复杂度没有限定在 O(log(m+n))，我们可以用 O(m+n)的算法解决，用两个指针分别指向两个数组，比较指针下的元素大小，一共移动次数为 (m+n + 1)/2，便是中位数。时间复杂度O(M+N)

```cpp
//并归排序方法
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
           int b=nums1.size(),c=nums2.size();
           if(b==0&&c==0) return 0;
           int l=0,r=0,t=0;
           double num;
           int sum=b+c;
           vector<int>s(sum,0);
           if(b>0 && c>0){
           while(l<=nums1.size()-1 && r<=nums2.size()-1){
               if(nums1[l]<=nums2[r])s[t++]=nums1[l++];
               else s[t++]=nums2[r++];
           }
        }
           if(b>0){
           while(l<=nums1.size()-1) s[t++]=nums1[l++];
           }
           if(c>0){
           while(r<=nums2.size()-1) s[t++]=nums2[r++];
           }
           int a=s.size();
           if(a%2!=0){
                   num=s[a/2];
           }else{
               num=(s[(a-1)/2]+s[(a+1)/2])/2.0;
           }
           return num;
    }
};
```

## 5.最长回文子串

回文子串从中间向两端扩展，然后要去两个中的大值，i和i+1.

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int len=0;
        int start=0,end=0;
        if(s.size()==1) return s;
        for(int i=0;i<s.size();i++){
            int len1=extend(i,i,s);
            int len2=extend(i,i+1,s);
            len=max(len1,len2);
            if (len > end - start)
			{
				start = i - (len - 1) / 2;
				end = i + len / 2;
			}
        }
        return s.substr(start,end-start+1);
    }
    int extend(int left,int right,const string& s){
        while(left>=0 && right<s.size() && s[left]==s[right]){
            left--;
            right++;
        }
        return right-left-1;
    }
};
```



## ==10.正则表达式匹配==

我们先脑补一下，s 和 p 相互匹配的过程大致是，两个指针 i, j 分别在 s 和 p 上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。

![image-20221231111849827](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20221231111849827.png)

看都看不懂....

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};
```



## 11. 盛最多水的容器

双指针，一个左一个右，谁小谁靠过来一个

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left=0;
        int right=height.size()-1;
        int maxWater=0;
        while(left<right){
            int water=min(height[right],height[left])*(right-left);
            maxWater=max(maxWater,water);
            if(height[left]<height[right]){
                left++;
            }
            else right--;
        }
        return maxWater;
    }
};
```





## 15. 三数之和

==去重非常重要==

先排序，一级去重，如果nums[i]==num[i-1] continue

二级去重，在发现相等的时候：

while(left<right && nums[right]==nums[right-1]) right--;

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            if(nums[i]>0) return result;
            if(i>0 && nums[i]==nums[i-1]) continue;
            int left=i+1,right=nums.size()-1;
            while(right>left){
                if(nums[i] + nums[left] + nums[right] == 0) {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
                else if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
            }
        }
        return result;
    }
};
```



## ==17.电话号码的字母组合(回溯)==

排列组合先想到回溯

```cpp
class Solution {
public:
    vector<string> letterMap{
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
        };
    vector<string> result;
    string s;
    void backtracking(string digits,int index){
        if(index==digits.size()){
            result.push_back(s);
            return;
        }
        int digit=digits[index]-'0';
        string letter=letterMap[digit];
        for(int i=0;i<letter.size();i++){
            s.push_back(letter[i]);
            backtracking(digits,index+1);
            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return result;
        backtracking(digits,0);
        return result;
    }
};
```



## 19. 删除链表的倒数第N个结点

对于找到列表中第几个元素，然后做什么操作这类题目，都可以结合双指针，因为不想数组可以直接跳到某个地方，链表找第n个元素的方法是：一个快慢指针都在头，然后比如说快指针向后n+1个，然后快慢一起移到末尾，就可以了，==一般要求只遍历一边。==

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead=new ListNode(-1);
        dummyHead->next=head;
        ListNode* slow=dummyHead;
        ListNode* fast=dummyHead;
        for(int i=0;i<=n;i++){
            fast=fast->next;
        }
        while(fast){
            fast=fast->next;
            slow=slow->next;
        }
        slow->next=slow->next->next;
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```



## 20. 有效括号

先进先出用栈来解决

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(char c: s){
            if(c=='{') st.push('}');
            else if(c=='(') st.push(')');
            else if(c=='[') st.push(']');
            else if(st.empty() || st.top()!=c) return false;
            else st.pop();
        }
        return st.empty();
    }
};
```



## 21.合并两个有序链表

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead=new ListNode(-1);
        ListNode* cur=dummyHead;
        while(list1!=nullptr && list2!=nullptr){
            if(list1->val > list2->val){
                cur->next=list2;
                list2=list2->next;
            }
            else{
                cur->next=list1;
                list1=list1->next;
            }
            cur=cur->next;
        }
        if(list1==nullptr) cur->next=list2;
        else if(list2==nullptr) cur->next=list1;
        return dummyHead->next;
    }
};
```



## ==22. 括号生成==

不用for循环，标准输入输出的感觉。

```cpp
class Solution {
public:
    vector<string> result;
    string path;
    void backtracking(int left,int right){
        if(right<left) return;
        if(left<0 || right<0) return;
        if(left==0 && right==0) {
            result.push_back(path);
            return;
        }
        path.push_back('(');
        backtracking(left-1,right);
        path.pop_back();
        path.push_back(')');
        backtracking(left,right-1);
        path.pop_back();
    }
    vector<string> generateParenthesis(int n) {
        if(n==0) return {};
        backtracking(n,n);
        return result;
    }
};
```



## 23.合并K个升序链表

两两合并升序链表，时间复杂度K*n

```cpp
class Solution {
public:
    ListNode* merge(ListNode* list1, ListNode* list2) {
        ListNode* dummy=new ListNode(0);
        ListNode *p = dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                p->next = list1;
                list1 = list1->next;
            }
            else {
                p->next = list2;
                list2 = list2->next;
            }
            p = p->next;
        }
        if (list1) {
            p->next = list1;
        }
        if (list2) {
            p->next = list2;
        }
        return dummy->next;
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size() == 0) return nullptr;
        ListNode* head = lists[0];
        for(int i = 1; i<lists.size(); ++i){
            if(lists[i]) head = merge(head, lists[i]);
        }
        return head;  
    }
};
```

方法2：建立优先队列，不需要全部元素一次性入队；**只需要让链表头元素入队即可，弹出该元素后，该链表往后移。**

![优先队列](https://pic.leetcode-cn.com/fb973066389b2b2e921601bd404fa29c9eb12cdb0bc877f4253492fbf5b9250a)

空间复杂度 O(k)，时间复杂度 O(**nlog(k)**)；n是所有节点个数，k是链表数

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* cur = dummyHead;
        priority_queue<ListNode*,vector<ListNode*>,cmp> pq;

        for(auto pNode:lists){
            if(pNode){
                pq.push(pNode);
            }
        }

        while(!pq.empty()){
            cur->next=pq.top();
            ListNode* tmp=pq.top();
            pq.pop();
            cur=cur->next;
            if(tmp->next){
                pq.push(tmp->next);
            }
        }
        return dummyHead->next;

    }
    struct cmp{
        bool operator() (ListNode* p1,ListNode* p2){
            return p1->val > p2->val;
        }
    };
};
```



###大顶堆、小顶堆知识补充（优先队列）

**堆**：通常被称之为**优先队列**，是一种特殊的队列，取出元素的顺序是按照元素的优先权（关键字）的大小，而不是按照元素进入队列的先后顺序。优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，**看起来就是一个队列。**

优先级队列内部元素是自动依照元素的权值排列

缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

**堆：就是一棵完全二叉树，树中每个结点值都不小于（不大于）其子树的任意的左右孩子**

在C++中用：`priority_queue<Type, Container, Functional>`,类型、容器（必须用数组实现的容器，vector或者deque），Functional就是比较的方式（最大或最小）

```cpp
//升序队列
priority_queue <int,vector<int>,greater<int> > q;
//降序队列
priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）

```

当数据类型并不是基本数据类型，而是自定义的数据类型时，就不能用greater或less的比较方式了，而是需要自定义比较方式.自定义的方法是重载括号运算符：要用class来定义。

```cpp
//大顶堆
class myComparison
{
	bool operator () (fruit f1,fruit f2)
	{
		return f1.price < f2.price;
	}
};
```



## ==31.下一个排列==

题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数

比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132

如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]

![image-20210528161641666](https://pic.leetcode-cn.com/1622189822-LnnwFv-file_1622189822542)



**从后向前，找到第一个降序位置，没找到说明最大了，直接把nums重新sort一下。找到了，则再从后往前找到第一个比他大的位置，交换这两个位置，再把这一段到最后reverse一下。**





```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int cur=nums.size()-2;

        while(cur>=0&&nums[cur]>=nums[cur+1])//前面大于后面的
        {
            cur--;
        }

        if(cur<0)//已经是最大数组了
            sort(nums.begin(),nums.end());
        else//表示找到了降序的一个位置
        {
            int pos=nums.size()-1;
            while(nums[pos]<=nums[cur])
            {
                pos--;
            }

            swap(nums[cur],nums[pos]);
            reverse(nums.begin()+cur+1,nums.end());
        }
    }
};
```



## 32.最长有效括号

注意这里面的栈记录的是下标

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int result=0;
        for(int i=0,start=0;i<s.size();i++){
            if(s[i]=='(') st.push(i);
            else{
                if(!st.empty()){
                    st.pop();
                    if(st.empty()) result=max(result,i-start+1);
                    else result=max(result,i-st.top());
                }
                else{
                    start=i+1;
                }
            }
        }
        return result;
    }
};
```



## 33.搜索旋转排序数组

但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。

可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。

```yaml
将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. 
```

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        if(n==0) return -1;
        if(n==1){
            return nums[0]==target ? 0 : -1;
        }
        int left=0,right=n-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]==target) return mid;
            if(nums[0]<=nums[mid]){
                if(target>=nums[0] && target<=nums[mid]){
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
            else{
                if(target>=nums[mid] && target<=nums[n-1]){
                    left=mid+1;
                }
                else{
                    right=mid-1;
                }
            }
        }
        return -1;
    }
};
```



## 34.[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        return {leftBound(nums,target),rightBound(nums,target)};
    }
    int leftBound(vector<int>& nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]<target) left=mid+1;
            else if(nums[mid]>target) right=mid-1;
            else if(nums[mid]==target) right=mid-1;
        }
        if(left>=nums.size() || nums[left]!=target){
            return -1;
        }
        return left;
    }
    int rightBound(vector<int>& nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]<target) left=mid+1;
            else if(nums[mid]>target) right=mid-1;
            else if(nums[mid]==target) left=mid+1;
        }
        if(right<0 || nums[right]!=target){
            return -1;
        }
        return right;
    }
};
```



## 39.组合的总和

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracing(vector<int>& candidates,int target,int sum,int start){
        if(sum>target) return;
        if(sum==target) result.push_back(path);
        for(int i=start;i<candidates.size();i++){
            sum+=candidates[i];
            path.push_back(candidates[i]);
            backtracing(candidates,target,sum,i);
            path.pop_back();
            sum-=candidates[i];
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracing(candidates,target,0,0);
        return result;
    }
};
```

### 40.组合的总和Ⅱ

**如果要用unordered_set去重的话，就一定要先排序了**

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates, int target,int sum,int start){
        if(sum>target) return;
        if(sum==target){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i=start;i<candidates.size();i++){
            if(uset.find(candidates[i])!=uset.end()) continue;
            uset.insert(candidates[i]);
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1); 
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtracking(candidates,target,0,0);
        return result;
    }
};
```



## 739.每日温度

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        vector<int> result(temperatures.size(),0);
        st.push(0);
        for(int i=1;i<temperatures.size();i++){
            if(temperatures[i]<=temperatures[st.top()]){
                st.push(i);
            }
            else{
                while(!st.empty() && temperatures[i]>temperatures[st.top()]){
                    result[st.top()]=i-st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```



## ==42.接雨水==

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()<=2) return 0;
        stack<int> st;
        int water=0;
        st.push(0);
        for(int i=1;i<height.size();i++){
            if(height[i]<height[st.top()]) st.push(i);
            else if(height[i]==height[st.top()]){
                st.pop();
                st.push(i);
            }
            else{
                while(!st.empty() && height[i]>height[st.top()]){
                    int mid=st.top();
                    st.pop();
                    if(!st.empty()){
                        int h=min(height[i],height[st.top()])-height[mid];
                        int w=i-st.top()-1;
                        water+=h*w;
                    }
                }
                st.push(i);
            }
        }
        return water;
    }
};
```

## 46.全排列

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracing(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();i++){
            if(used[i]==true) continue;
            used[i]=true;
            path.push_back(nums[i]);
            backtracing(nums,used);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        backtracing(nums,used);
        return result;
    }
};
```



## 48.旋转图像(旋转矩阵)

无非是上下对称，左右对称，主对角线对称，副对角线对称的组合

```cpp
class Solution {
public:
    int n;
    void rotate(vector<vector<int>>& matrix) {
        n=matrix.size();
        upDownSymmetry(matrix);
        mainDiagSymmetry(matrix);
    }
    void upDownSymmetry(vector<vector<int>>& matrix){
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }
    }
    void leftRightSymmetry(vector<vector<int>>& matrix){
        for(int i=0;i<n;i++){
            for(int j=0;j<n/2;j++){
                swap(matrix[i][j],matrix[i][n-j-1]);
            }
        }
    }
    void mainDiagSymmetry(vector<vector<int>>& matrix) {
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
    void subdiagSymmetry(vector<vector<int>>& matrix) {
        for (int i = 0; i < n-1; ++i) {
            for (int j = 0; j < n-i-1; ++j) {
                swap(matrix[i][j], matrix[n-j-1][n-i-1]);
            }
        }
    }
};
```



## 64最小路径和

简单动态规划，注意以下初始化即可

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size(),vector<int>(grid[0].size(),0));
        dp[0][0]=grid[0][0];
        for(int i=1;i<grid.size();i++) dp[i][0]=dp[i-1][0]+grid[i][0];
        for(int j=1;j<grid[0].size();j++) dp[0][j]=dp[0][j-1]+grid[0][j];
        for(int i=1;i<grid.size();i++){
            for(int j=1;j<grid[0].size();j++){
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[grid.size()-1][grid[0].size()-1];
    }
};
```

## 75颜色分类（排序算法）

冒泡：

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        for(int i=0;i<nums.size()-1;i++){
            for(int j=0;j<nums.size()-i-1;j++){
                if(nums[j]>nums[j+1]){
                    swap(nums[j],nums[j+1]);
                }
            }
        }
    }
};
```

快排：

```cpp
class Solution {
public:
void quick_sort(int l,int r,vector<int>& nums){
    if(l>=r)return;
    int i=l-1,j=r+1,mid=nums[(l+r)/2];
    while(i<j){
        do i++; while(nums[i]<mid);
        do j--; while(nums[j]>mid);
        if(i<j) swap(nums[i],nums[j]);
    }
    quick_sort(l,j,nums);
    quick_sort(j+1,r,nums);
}
    void sortColors(vector<int>& nums) {
        quick_sort(0,nums.size()-1,nums);
    }
};
```

双指针一遍遍历：

![image-20230106105929578](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230106105929578.png)

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        int left=0,right=n-1;
        for(int i=0;i<=right;i++){
            while(i<=right && nums[i]==2){
                swap(nums[i],nums[right]);
                right--;
            }
            if(nums[i]==0){
                swap(nums[i],nums[left]);
                left++;
            }
        }
    }
};
```



## ==79单词搜索==

回溯，类似N皇后，

- 1、从搜索过的位置继续搜索下一层时，需要对当前位置进行标识，表示已经搜索
- 2、可以使用偏移数组来简化代码。

![img](https://pic.leetcode-cn.com/1628685636-BmcHAI-file_1628685636009)

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++)
            for(int j = 0; j < board[i].size(); j++)
                if(dfs(board,word,0,i,j)) return true;
        return false;        
    }
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1}; //方向数组
    bool dfs(vector<vector<char>>& board, string& word,int u,int x,int y)
    {
        if(board[x][y] != word[u]) return false;
        if(u == word.size() - 1)   return true;
        char t = board[x][y];
        board[x][y] = '.';
        for(int i = 0; i < 4; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            //出界或者走到已经搜索过的位置
            if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || board[a][b] == '.')  continue;
            if(dfs(board,word,u+1,a,b)) return true;
        }
        board[x][y] = t;
        return false;
    }
};
```

##==85最大矩形==

本题与84很像，84是在一维空间求面积最大，这题是在二维空间，可以把其转化为一维空间，然后单调栈。

==以每一行为x轴，每一行都调用84题的方法，从而得出最大矩形的面积==

![image.png](https://pic.leetcode-cn.com/1659592850-TJNAYn-image.png)

通过暴力解法，时间消耗非常大
那么可以利用递增栈优化暴力暴力求解的过程

当元素大于栈顶元素时，入栈
当元素小于栈顶元素时，维护栈的递增性，将小于当前元素的栈顶元素弹出，并计算面积

在上面递增栈中，我们总是需要判断当前元素是否为最后元素或者为栈顶元素，很麻烦，那么可以在数组前后加上两个哨兵，充当坏点，在实际计算中不影响结果，但是简化我们的逻辑，正如我们高中或者初中学过的辅助线或者凑配法都是差不多的思路

力扣只能过一半...

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty()) return 0;
        int ans = 0;
        vector<int> line(matrix[0].size() + 2, 0);
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                line[j + 1] = (matrix[i][j] == '0') ? 0 : line[j + 1] + 1;
            }
            ans = max(ans, largestRectangleArea(line));
        }
        return ans;
    }
    
    int largestRectangleArea(vector<int>& heights) {
        int ans = 0;
        vector<int> st;
        // heights.insert(heights.begin(), 0);
        // heights.push_back(0);
        for (int i = 0; i < heights.size(); i++) {
            while (!st.empty() && heights[st.back()] > heights[i]) {
                int cur = st.back();
                st.pop_back();
                int left = st.back() + 1;
                int right = i - 1;
                ans = max(ans, (right - left + 1) * heights[cur]);
            }
            st.push_back(i);
        }
        return ans;
    }
};

```



## 114二叉树展开为链表

**给 `flatten` 函数输入一个节点 `root`，那么以 `root` 为根的二叉树就会被拉平为一条链表**。

如何利用这个定义来完成算法？你想想怎么把以 `root` 为根的二叉树拉平为一条链表？

很简单，以下流程：

1、将 `root` 的左子树和右子树拉平。

2、将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。

![img](https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/2.jpeg)

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        if(root==nullptr) return;
        flatten(root->left);
        flatten(root->right);
        TreeNode* left=root->left;
        TreeNode* right=root->right;
        root->left=nullptr;
        root->right=left;
        TreeNode* cur=root;
        while(cur->right!=nullptr){
            cur=cur->right;
        }
        cur->right=right;
    }
};
```

## ==124二叉树中的最大路劲和（非自顶向下）==

就拿一个最简单的最下的子树来说，一般递归都想到最小的那个单元

![image-20230107111556841](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230107111556841.png)

==return ret;绝对！！绝对不能return val==

```cpp
class Solution {
public:
    int maxPathSum(TreeNode* root, int &val)
    {
        if (root == nullptr) return 0;
        int left = maxPathSum(root->left, val);
        int right = maxPathSum(root->right, val);
        int lmr = root->val + max(0, left) + max(0, right);
        int ret = root->val + max(0, max(left, right));
        val = max(val, max(lmr, ret));
        //沿着大分支返回，
        return ret;
    }

    int maxPathSum(TreeNode* root) 
    {
        int val = INT_MIN;
        maxPathSum(root, val);
        return val;
    }
};
```

## 128最长连续序列

时间复杂度为O（NlogN）

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.size()==0) return 0;
        sort(nums.begin(),nums.end());
        int size=1;
        int result=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]==nums[i-1]+1) {
                size++;
                result=max(result,size);
            }
            else if(nums[i]==nums[i-1]){
                continue;
            }
            else{
                size=1;
            }
        }
        return result;
    }
};
```

时间复杂度O(N)，空间换时间，用哈希表

![image-20230109184454245](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230109184454245.png)

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        for(int num:nums){
            hash.insert(num);
        }
        int res=0;
        for(int num:hash){
            //如果前一位不存在，也就是找到最早的第一位。
            if(!hash.count(num-1)){
                int curNum=num;
                int curLen=1;
                while(hash.count(curNum+1)) {
                    curNum++;
                    curLen++;
                }
                res=max(res,curLen);
            }
        }
        return res;
    }
};
```



## ==136 只出现一次的数字==

补充C++位运算的知识：位运算传入是整数，就会直接当成二进制来用

一个数和它本身做异或运算结果为 0，即 `a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即 `a ^ 0 = a`。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素。

**两两会消掉，最后只留下单一的那个**

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=0;
        for(int num:nums){
            res^=num;
        }
        return res;
    }
};
```

如果没有时间复杂度和空间复杂度要求：

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int, int> map1;
        for(int n : nums){
            map1[n]+=1;
        }
        for(auto i=map1.begin(); i!=map1.end(); ++i){
            if(i->second == 1) 
                return i->first;
        }
        return 0;
    }
};
```



## ==146LRU缓存==(设计题)

![image-20230109194715704](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230109194715704.png)

![img](https://pic.leetcode-cn.com/1647580694-NAtygG-4.jpg)

使用一个双链表和一个哈希表：

双链表存储一个节点被使用（get或者put）的时间戳，且按最近使用时间从左到右排好序，最先被使用的节点放在双链表的第一位，因此双链表的最后一位就是最久未被使用的节点；

![image-20220127134000873.png](https://pic.leetcode-cn.com/1643262004-OtWDih-image-20220127134000873.png)

![image-20230109194943131](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230109194943131.png)

![image-20230109195034700](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230109195034700.png)

![image-20230109195043892](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230109195043892.png)

```cpp
class LRUCache {
public:
    struct Node{
        int key,value;
        Node* left;
        Node* right;
        Node(int _key,int _value): key(_key),value(_value),left(NULL),right(NULL){}
    }*L,*R;
    int n;
    unordered_map<int,Node*>hash;
    //删除节点p
    void remove(Node* p){
        p->right->left=p->left;
        p->left->right=p->right;
    }
    void insert(Node* p){
        p->right=L->right;
        p->left=L;
        L->right->left=p;
        L->right=p;
    }
    LRUCache(int capacity) {
        n=capacity;
        L=new Node(-1,-1),R=new Node(-1,-1);
        L->right=R;
        R->left=L;
    }
    
    int get(int key) {
        if(hash.count(key)==0) return -1;
        auto p=hash[key];
        remove(p);
        insert(p);
        return p->value;
    }
    
    void put(int key, int value) {
        if(hash.count(key)){
            auto p=hash[key];
            p->value=value;
            remove(p);
            insert(p);
        }
        else{
            if(hash.size()==n){
                auto p=R->left;
                remove(p);
                hash.erase(p->key);
                delete p;
            }
            auto p=new Node(key,value);
            hash[key]=p;
            insert(p);
        }
    }
};

```

## 148==排序链表==

重新生成一个数组然后快排。

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int> v;
        ListNode* cur=head;
        while(cur){
            v.push_back(cur->val);
            cur=cur->next;
        }
        sort(v.begin(),v.end());
        ListNode* cur1=head;
        for(int i=0;i<v.size();i++){
            cur1->val=v[i];
            cur1=cur1->next;
        }
        return head;
    }
};
```

在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序

**时间复杂度是O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)，其中最适合链表的排序算法是归并排序。**

![image-20230110100625502](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230110100625502.png)

![image-20230110101034891](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230110101034891.png)

主要要记住两个链表的常用操作：

- 双路并归，两条链表的合并

```cpp
ListNode* merge(ListNode* l1, ListNode* l2){
    ListNode dummyHead(0);
        auto p = &dummyHead;
        while (l1 && l2) {
            if (l1->val < l2->val) {
                p->next = l1;
                p = l1;
                l1 = l1->next;       
            } else {
                p->next = l2;
                p = l2;
                l2 = l2->next;
            }
        }
        p->next = l1 ? l1 : l2;
        return dummyHead.next;
}
```

- cut操作：将链表L切掉前n个元素后返回后面的 
  - `while(--n)`这种写法

```cpp
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n && p) {
            p = p->next;
        }
        
        if (!p) return nullptr;
        
        auto next = p->next;
        p->next = nullptr;
        return next;
    }
```

方法二：

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        //计算总长度
        while (p) {
            ++length;
            p = p->next;
        }
        
        for (int size = 1; size < length; size *= 2) {
            auto cur = dummyHead.next;
            auto tail = &dummyHead;
            
            while (cur) {
                auto left = cur;
                auto right = cut(left, size); // left->@->@ right->@->@->@...
                cur = cut(right, size); // left->@->@ right->@->@  cur->@->...
                
                tail->next = merge(left, right);
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
        return dummyHead.next;
    }
    
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n && p) {
            p = p->next;
        }
        
        if (!p) return nullptr;
        
        auto next = p->next;
        p->next = nullptr;
        return next;
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummyHead(0);
        auto p = &dummyHead;
        while (l1 && l2) {
            if (l1->val < l2->val) {
                p->next = l1;
                p = l1;
                l1 = l1->next;       
            } else {
                p->next = l2;
                p = l2;
                l2 = l2->next;
            }
        }
        p->next = l1 ? l1 : l2;
        return dummyHead.next;
    }
};
```



## 152 乘积最大子数组

利用动态规划求解，dp[i]表示以nums[i]结尾的连续子数组乘积的最大值

**状态转移方程为：** `dp[i] = max(nums[i], dp[i - 1] * nums[i])`。

但是nums数组中包含有正数，负数和零，当前的最大值如果乘以一个负数就会变成最小值，当前的最小值如果乘以一个负数就会变成一个最大值，因此我们还需要维护一个最小值。

![image-20230110105425783](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230110105425783.png)

**综上，最大值的状态转移方程为：` f[i] = max(nums[i], max(f[i - 1] * nums[i], g[i - 1] * nums[i]))。`**

**综上，最小值的状态转移方程为：` g[i] = min(nums[i], min(g[i - 1] * nums[i], f[i - 1] * nums[i]))。`**

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n=nums.size(),res=nums[0];
        vector<int> maxValue(n+1,0),minValue(n+1,0);
        maxValue[0]=nums[0],minValue[0]=nums[0];
        for(int i=1;i<n;i++){
            maxValue[i]=max(nums[i],max(maxValue[i-1]*nums[i],minValue[i-1]*nums[i]));
            minValue[i]=min(nums[i],min(minValue[i-1]*nums[i],maxValue[i-1]*nums[i]));
            res=max(res,maxValue[i]);
        }
        return res;
    }
};
```



## 155最小栈（设计题）

和716同理，716要钱。

对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。
因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。
那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。

![image.png](https://pic.leetcode-cn.com/1650469898-solthm-image.png)

```cpp
class MinStack {
public:
    stack<int> st;
    stack<int> minstack;
    MinStack() {
        while(!st.empty()){
            st.pop();
        }
        while(!minstack.empty()) minstack.pop();
        minstack.push(INT_MAX);
    }
    
    void push(int val) {
        st.push(val);
        if(val<minstack.top()) minstack.push(val);
        else minstack.push(minstack.top());
    }
    
    void pop() {
        st.pop();
        minstack.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return minstack.top();
    }
};
```

##169多次元素

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n=nums.size();
        int res=0;
        unordered_map<int,int> mp;
        for(int num:nums){
            mp[num]++;
        }
        for(auto i:mp){
            if(i.second>n/2) res=i.first;
        }
        return res;
    }
};
```

空间复杂度为O（1）的算法:

回到这道题，题目告诉你一定存在一个众数，它出现的次数过半，那么如果你把这个众数元素想象成正电粒子，其他的所有元素都想象成负电粒子，那么它们混合起来就会剩下最后那个元素。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int target=0,count=0;
        for(int i=0;i<nums.size();i++){
            if(count==0){
                target=nums[i];
                count=1;
            }
            else if(nums[i]==target){
                count++;
            }
            else{
                count--;
            }
        }
        return target;
    }
};
```

## 200岛屿数量

图论类题目，DFS

本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。在遇到标记过的陆地节点和海洋节点的时候直接跳过。这样计数器就是最终岛屿的数量。

dfs的作用是把一块陆地相连的所有陆地都标记好。

```cpp
class Solution {
public:
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        if (visited[x][y] || grid[x][y] == '0') return; // 终止条件：访问过的节点 或者 遇到海水
        visited[x][y] = true; // 标记访问过
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            dfs(grid, visited, nextx, nexty);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++; // 遇到没访问过的陆地，+1
                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```

##695 岛屿的最大面积

```cpp
class Solution {
public:
    int n, m;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; //偏移数组
    int dfs(vector<vector<int>>& grid,int x, int y) //搜索函数
    {
        int area = 1;
        grid[x][y] = 0;  //已经搜索过，标记为0
        for(int i = 0; i < 4; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            //当前土地未出界也未被搜索过，继续下一层搜索
            if(a >=0 && a < n && b >=0 && b < m && grid[a][b])
                area += dfs(grid,a, b);
        }      
        return area; 
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int res = 0;
        n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                if(grid[i][j])
                    res = max(res,dfs(grid,i,j));
        return res;                
    }
};
```



## ==207课程表（图图图）==

**判断有向图，是否有环。 有返回false，没有返回true**

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230111144701311.png" alt="image-20230111144701311" style="zoom:50%;" />

不会 直接CV了，后续再补把



## 208实现Trie（前缀树）

Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。

Trie的结点和正常的树的结点不太一样：

```cpp
struct TrieNode {
    bool isEnd; //该结点是否是一个串的结束
    TrieNode* next[26]; //字母映射表
};
```

要想学会 Trie 就得先明白它的结点设计。我们可以看到TrieNode结点中并没有直接保存字符值的数据成员，那它是怎么保存字符的呢？

这时字母映射表next 的妙用就体现了，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：

![实际并非如此，但我们仍可这样理解](https://pic.leetcode-cn.com/3a0be6938b0a5945695fcddd29c74aacc7ac30f040f5078feefab65339176058-file_1575215106942)

- Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。


- 查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。


- Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)。


```cpp
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }
    
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c-'a'] == NULL) {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            //要从根节点的下一个结点开始
            node = node->next[c - 'a'];
            if (node == NULL) {
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            node = node->next[c-'a'];
            if (node == NULL) {
                return false;
            }
        }
        return true;
    }
};
```

memset函数的作用：为指针变量s所指的前n个**字节**的内存单元填充给定的int型数值c，它可以为任何数据进行初始化。**换句话说，就是将数值c以单个字节逐个拷贝的方式放到指针变量s所指的内存中去。**

```cpp
void *memset(void *s,int c,unsigned long n);
```

## 215==数组中第K个最大元素==

方法1：大顶堆（优先队列方法），当k趋近于n的时候时间复杂度为O（NlogN），所以不是那么符合，写着玩

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
       priority_queue<int,vector<int>,less<int>> maxHeap;
       for(int num:nums){
           maxHeap.push(num);
       }
       for(int i=0;i<k-1;i++){
           maxHeap.pop();
       }
       return maxHeap.top();
    }
};
```

方法2：**快排升级版，快速选择：**

**快速选择**：`快排每一趟扫描都会定位一位数字到正确位置，并且其左边元素小于它，右边元素大于它`，因此我们可以根据这个数字只排需要找的区间，不再是两边都要排

```cpp
class Solution {
public: 
    // 关于排序基准，试了三种方法，随机数、首位元素、两端和中间点取中值，结果是随机更快一点
    int partition(vector<int>& nums, int left, int right) {
        // 为了防止第一位元素是最小或者最大的那几个，取随机元素，尽量每次将区间对半分
        int idx = rand() % (right - left + 1) + left;
        swap(nums[left], nums[idx]);
        int base = nums[left];
        // 快速排序，注意是从大到小，因为我们找的是第K 大
        while (left < right) {
            while (left < right && nums[right] <= base) {
                --right;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] >= base) {
                ++left;
            }
            nums[right] = nums[left];
        }
        nums[left] = base;
        return left;
    }

    int findKthLargest(vector<int>& nums, int k) {
        srand(time(NULL));
        int l = 0, r = nums.size() - 1;
        // 迭代法实现，避免递归造成空间开销
        while (l <= r) {
            int pivot = partition(nums, l, r);
            // 元素下标从0开始
            if (pivot + 1 == k) {
                return nums[pivot];
            } else if (pivot + 1 < k) {
                // 如果基准是前K大，第K大元素位于其右边
                l = pivot + 1;
            } else {
                // 与上面相反
                r = pivot - 1;
            }
        }
        return 0;
    }
};
```



## 221最大正方形

动态规划，求边长

以 `matrix[i][j]` 为右下角元素的最大的全为 1 正方形矩阵的边长为 `dp[i][j]`。

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int n=matrix.size(),m=matrix[0].size();
        vector<vector<int>>dp(n,vector<int>(m,0));
        for(int i=0;i<n;i++){
            if(matrix[i][0]=='1') dp[i][0]=1; 
        }
        for(int j=0;j<m;j++){
            if(matrix[0][j]=='1') dp[0][j]=1;
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(matrix[i][j]=='1'){
                    dp[i][j]=min({dp[i][j-1],dp[i-1][j],dp[i-1][j-1]})+1;
                }
                else continue;
            }
        }
        int result=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                result=max(result,dp[i][j]);
            }
        }
        return result*result;
    }
};
```



## 238除自身以外数组的乘积

时间复杂度O（N），空间复杂度O(N)，计算左右数组

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int size=nums.size();
        vector<int> left(size,0);
        vector<int> right(size,0);
        left[0]=1;
        for(int i=1;i<size;i++){
            left[i]=left[i-1]*nums[i-1];
        }
        right[size-1]=1;
        for(int j=size-2;j>=0;j--){
            right[j]=right[j+1]*nums[j+1];
        }
        vector<int> result(size,0);
        for(int i=0;i<size;i++){
            result[i]=left[i]*right[i];
        }
        return result;
    }
};
```

##240搜索二维矩阵

最好的方法是从右上角开始查找，小了往下，大了往左。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size(),n=matrix[0].size();
        int i=0,j=n-1;
        while(i<m && j>=0){
            if(matrix[i][j]>target) j--;
            else if(matrix[i][j]<target) i++;
            else return true;
        }
        return false;
    }
};
```

也可以二分。

## ==287寻找重复数==

题意上看上去和136只出现一次的数字很像，但其实不能做位运算

方法1.二分法：

「二分查找」的思路是先猜一个数（搜索范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 count：

如果 count 严格大于 mid。根据 抽屉原理，重复元素就在区间 [left..mid] 里；
否则，重复元素可以在区间 [mid + 1..right] 里找到

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int len=nums.size();
        int left=1,right=len-1;//在1-n中寻找
        while(left<=right){
            int mid=(left+right)/2;
            int count=0;
            for(auto num:nums){
                if(num<=mid) count++;
            }
            if(count>mid) right=mid-1;
            else left=mid+1;
        }
        return left;
    }
};
```

方法2：类似环形链表是否有环的方法：

<img src="https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png" alt="287.png" style="zoom:50%;" />

关键在于建立数组下标和数的映射关系：

<img src="C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230113111048345.png" alt="image-20230113111048345" style="zoom:50%;" />

142 题中慢指针走一步 slow = slow.next ==> 本题 slow = nums[slow]
142 题中快指针走两步 fast = fast.next.next ==> 本题 fast = nums[nums[fast]]

![image-20230113112600900](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230113112600900.png)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow=0,fast=0;
        slow=nums[slow];
        fast=nums[nums[fast]];
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[nums[fast]];
        }
        int pre1=0;
        int pre2=slow;
        while(pre1!=pre2){
            pre1=nums[pre1];
            pre2=nums[pre2];
        }
        return pre1;
    }
};
```

## 297二叉树的序列化和反序列化

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

BFS层序遍历方法，==重要的是反构造==

本题没说怎么序列化，反正你什么序都可以，能反序列回去就行。

反构造的重点都是建立一个list<string>

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        queue<TreeNode*>q;
        string ans;
        if(root!=nullptr) q.push(root);
        while(!q.empty()){
            int size=q.size();
            for(int i=0;i<size;i++){
                auto node=q.front();
                q.pop();
                if(node==nullptr) ans+="None,";
                else{
                    ans+=to_string(node->val)+",";
                    q.push(node->left);
                    q.push(node->right);
                }
            }
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data.size()==0) return nullptr;
        list<string> dataArray;
        string str;
        for (auto& c : data) {
            if (c == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(c);
            }
        }
        if(str.size()!=0){
            dataArray.push_back(str);
            str.clear();
        }
        queue<TreeNode*> que;
        if(dataArray.front()=="None") return nullptr;
        TreeNode * root = new TreeNode(stoi(dataArray.front()));
        que.push(root);
        dataArray.pop_front();
        while(!que.empty() && !dataArray.empty()){
            int size = que.size();
            for (int i = 0; i < size && !dataArray.empty(); i++) {
                TreeNode* cur = que.front(); // 父节点
                que.pop();
                // 第一个为左节点
                if (dataArray.front() != "None") {
                    TreeNode* node1 = new TreeNode(stoi(dataArray.front()));
                    cur->left = node1;
                    que.push(node1);
                }
                dataArray.pop_front();
                
                // 第二个为右节点
                if (dataArray.front() != "None") {
                    TreeNode* node2 = new TreeNode(stoi(dataArray.front()));
                    cur->right = node2;
                    que.push(node2);
                }
                dataArray.pop_front();
            }
        }
        return root;
    }
};
```



前序遍历DFS方法：

```cpp
class Codec {
public:
    void rserialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += "None,";
        } else {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    string serialize(TreeNode* root) {
        string ret;
        rserialize(root, ret);
        return ret;
    }

    TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "None") {
            //dataArray.erase(dataArray.begin());
            dataArray.pop_front();
            return nullptr;
        }

        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        //dataArray.erase(dataArray.begin());
        dataArray.pop_front();
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }

    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        if (!str.empty()) {
            dataArray.push_back(str);
            str.clear();
        }
        return rdeserialize(dataArray);
    }
};

```



## ==301删除无效的括号==

不会 直接CV了

```cpp
class Solution {
public:
    bool isValid(string str) {
        int count = 0;

        for (char c : str) {
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
                if (count < 0) {
                    return false;
                }
            }
        }

        return count == 0;
    }

    vector<string> removeInvalidParentheses(string s) {
        vector<string> ans;
        unordered_set<string> currSet;

        currSet.insert(s);
        while (true) {
            for (auto & str : currSet) {
                if (isValid(str))
                    ans.emplace_back(str);
            }
            if (ans.size() > 0) {
                return ans;
            }
            unordered_set<string> nextSet;
            for (auto & str : currSet) {
                for (int i = 0; i < str.size(); i++) {
                    if (i > 0 && str[i] == str[i - 1]) {
                        continue;
                    }
                    if (str[i] == '(' || str[i] == ')') {
                        nextSet.insert(str.substr(0, i) + str.substr(i + 1, str.size()));
                    }
                }
            }
            currSet = nextSet;
        }
    }
};

```



## 312戳气球

较难的动态规划问题，我连dp代表什么都没想出来....

**`dp` 数组的含义：`dp[i][j] = x` 表示，戳破气球 `i` 和气球 `j` 之间（开区间，不包括 `i` 和 `j`）的所有气球，可以获得的最高分数为 `x`。**

状态转移方程：

我们假设最后戳破的是第k个气球，则得到的值为:

```c++
dp[i][j]=dp[i][k]+dp[k][j]+nums[i]*num[j]*nums[k]
```

为什么是最后戳破的是第K个呢，因为只有最后戳破第k个才能保证，k的左边和右边的气球不相邻，保证`dp[i][k] 和dp[k][i]`有效

<img src="https://labuladong.github.io/pictures/burstBalloon/1.jpeg" alt="img" style="zoom:67%;" />

初始化dp数组：

![image-20230114121526935](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230114121526935.png)

从下往上，反向赋初值，然后内部还有一个移动的指针，优点像三数之和。

```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n=nums.size()+2;
        nums.insert(nums.begin(),1);
        nums.push_back(1);
        vector<vector<int>>dp(n,vector<int>(n,0));
        for(int start=n-1;start>=0;start--){
            for(int end =start;end<n;end++){
                if(end-start<2) continue;//不包括=2
                for(int i=start+1;i<end;i++){
                    dp[start][end] = max(dp[start][end], dp[start][i] + dp[i][end] + nums[start] * nums[i] * nums[end]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

## ==338比特位计数==

将十进制转化为二进制的方法

```cpp
#include<iostream>
using namespace std;

//十进制转二进制
int main()
{
	int x,i=0,j;
	int a[32];
	cout<<"Please input a decimal base:"<<endl;
	cin>>x;
	
	while((x/2)!=0)//将十进制数不断除2取余数，直到最后除2等于0，循环结束
	{
		a[i]=x%2;//将十进制数除2后的余数存放在数组中
		i++;
		x/=2;//不断改变x的值
		
	}
	
	 a[i]=x;//当x/2=0时，还可能有剩下的数，将剩下的数存放到数组最后一个数中
	cout<<"The binary base is:"<<endl;
	for(j=i;j>=0;j--)//当转成二进制数输出时，需要将数组中的数倒着输出
	cout<<a[j];
	cout<<endl;
	return 0;
}
```

本题实际上要用动态规划实现时间复杂度为O（N）的实现：

- 偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明`dp[i] = dp[i / 2]`
- 奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明`dp[i] = dp[i-1] + 1`，当然也可以写成`dp[i] = dp[i / 2] + 1`

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n+1,0);
        for(int i=0;i<=n;i++){
            if(i%2==0) result[i]=result[i/2];
            else result[i]=result[i/2]+1;
        }
        return result;
    }
};
```

直观的时间复杂度高一点的算法，因此总时间复杂度为O*(*n*log*n)。：

![image-20230115103028714](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230115103028714.png)

```cpp
class Solution {
public:
    int countOnes(int x) {
        int ones = 0;
        while (x > 0) {
            x &= (x - 1);
            ones++;
        }
        return ones;
    }

    vector<int> countBits(int n) {
        vector<int> result(n + 1);
        for (int i = 0; i <= n; i++) {
            result[i] = countOnes(i);
        }
        return result;
    }
};
```



## ==394字符串解码==

两个栈，一个数字一个字母

注意点：`num=num*10+s[i]-'0';`

```cpp
class Solution {
public:
    string decodeString(string s) {
        string res = "";
        stack <int> nums;
        stack <string> strs;
        int num = 0;
        int len = s.size();
        for(int i = 0; i < len; ++ i)
        {
            if(s[i] >= '0' && s[i] <= '9')
            {
                num = num * 10 + s[i] - '0';
            }
            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))
            {
                res = res + s[i];
            }
            else if(s[i] == '[') //将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内
            {
                nums.push(num);
                num = 0;
                strs.push(res); 
                res = "";
            }
            else //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律
            {
                int times = nums.top();
                nums.pop();
                for(int j = 0; j < times; ++ j)
                    strs.top() += res;
                res = strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算
                                  //若是左括号，res会被压入strs栈，作为上一层的运算
                strs.pop();
            }
        }
        return res;
    }
};
```



## 399除法求值（图图图）

图论 先跳过直接CV了

本题可以转化为在一个带权有向图中，判断两个节点之间是否存在路径， 而相除的值即为路径上的边权值的乘积。

![image.png](https://pic.leetcode.cn/1671191352-fBfFVH-image.png)

```cpp
class Solution {
public:
    unordered_map<string,int> visit;  //避免查找的时候重复搜索一个节点
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        //需要把所有的元素存起来  相当于一个图  
        unordered_map<string,vector<pair<string,double>>> mp;  //建立双向图
        for(int i=0;i<equations.size();++i){
            vector<string> strvec=equations[i];
            mp[strvec[0]].push_back({strvec[1],values[i]});
            mp[strvec[1]].push_back({strvec[0],1.0/values[i]});
           
        }

        vector<double> ans(queries.size(),-1);
        for(int i=0;i<queries.size();++i){
            vector<string> strvec=queries[i];
            string a=strvec[0],b=strvec[1];
            double res=-1;
            if(mp.count(a)) {
                visit.clear();  //清理上一次查找过的所有根节点
                res=dfs(mp,a,b,1);    //每一次访问时不能互相干扰。
            }
            ans[i]=res;
        }
        return ans;
    }

    double dfs(unordered_map<string,vector<pair<string,double>>>& mp,string& a,string &b,double res){ //a/b
        //if(mp.count(a)==0) return -1;
        //cout<<a<<endl;
        
        if(a==b) return res;
        double ans=-1;
        if(visit[a]) return ans;   //证明还没以该节点为根进行遍历过
        visit[a]=1;
        for(auto& it:mp[a]){
            ans=dfs(mp,it.first,b,res*it.second);
            if(ans!=-1) break;
        } 
        return ans;
    }
};
```



## ==437路径总和Ⅲ（非自顶向下和双重递归看看）==

[一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析） - 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/)

![image-20230115113059298](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230115113059298.png)

自定向下的模板

```cpp
一般路径：
vector<vector<int>>res;
void dfs(TreeNode*root,vector<int>path)
{
    if(!root) return;  //根节点为空直接返回
    path.push_back(root->val);  //作出选择
    if(!root->left && !root->right) //如果到叶节点  
    {
        res.push_back(path);
        return;
    }
    dfs(root->left,path);  //继续递归
    dfs(root->right,path);
}

# **给定和的路径：**
void dfs(TreeNode*root, int sum, vector<int> path)
{
    if (!root)
        return;
    sum -= root->val;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == 0)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, sum, path);
    dfs(root->right, sum, path);
}
```

4、是否要双重递归(即调用根节点的dfs函数后，继续调用根左右节点的pathsum函数)：看题目要不要求从根节点开始的，还是从任意节点开始

本题就是典型双重递归：

```cpp
class Solution {
public:
    int count=0;
    int pathSum(TreeNode* root, long long targetSum) {
        if(root==nullptr) return 0;
        dfs(root,targetSum);
        pathSum(root->left,targetSum);
        pathSum(root->right,targetSum);
        return count;
    }
    void dfs(TreeNode* root,long long targetSum){
        if(root==nullptr) return;
        targetSum-=root->val;
        if(targetSum==0){
            count++;
        }
        dfs(root->left,targetSum);
        dfs(root->right,targetSum);
    }
};
```

![image-20230115114954421](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230115114954421.png)

## 448找到所有数组中消失的数字

原地的，时间复杂度为O(N)，空间复杂度O（1）

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n=nums.size();
        int i=0;
        while(i<n){//用if不行
            if(nums[i]==i+1){
                i++;
                continue;
            }
            int idex=nums[i]-1;
            if(nums[idex]==nums[i]){
                i++;
                continue;
            }
            swap(nums[i],nums[idex]);
        }
        vector<int> result;
        for(int j=0;j<n;j++){
            if(nums[j]!=j+1) result.push_back(j+1);
        }
        return result;
    }
};
```

用哈希的方法：

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        unordered_set<int> st;
        vector<int> res;
        for(auto num:nums){
            st.insert(num);
        }
        for(int i=1;i<=nums.size();i++){
            if(st.find(i)==st.end()) res.push_back(i);
        }
        return res;
    }
};
```

## ==461汉明距离==

**n & n-1** 的值是 **去掉二进制n最右边1的值**；比如 1000 和 1101 只有两位不同，汉明距离就是2

解题方法就是：两数异或（不同位为1），剩下二进制为1的就是不同的二进制位，统计1个数即汉明距离；

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int ret = x^y;      //异或剩下1的个数就是二进制位不同的位置的数目
        int ans = 0;        //answer 记录1的个数
        while(ret){         //每一次运算消去一个1，直到为0终止循环
            ret&=(ret-1);   // ret= ret & (ret-1); 
            ans++;
        }
        return ans;
    }
};

```

![image-20230117200310030](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230117200310030.png)

## 543二叉树的直径（非自顶向下）

想法1：直径=子树左边最大深度+右边最大深度+1：

```cpp
class Solution {
public:
    int result=0;
    int depth(TreeNode* node){
        if(node==nullptr) return 0;
        int left=depth(node->left);
        int right=depth(node->right);
        result=max(result,left+right+1);
        return max(left,right)+1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return result-1;
    }
};
```



## ==560 和为K的子数组（前缀和+哈希）==

第一个想法，滑动窗口：失败，原因在于：因为`nums[i]`可以小于0，也就是说右指针`i`向后移1位不能保证区间会增大，左指针`j`向后移1位也不能保证区间和会减小。给定`j`，`i`的位置没有二段性

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int left=0,right=0;
        int result=0;
        int sum=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
            if(sum==k) result++;
            while(sum>k){
                sum-=sum=nums[left];
                left++;
            }
        }
        return result;
    }
};
```



正确做法：前缀和

假如存在区间[left,right]，使得在[left,right]这个区间的子数组的和为k。换句话说，就是前right项和减去前left-1项和等于k，即前left-1项和等于前right项和减去k。
可以这样做，在扫描数组的同时，假设当前扫到第i位，记录它的前i项和sum，用该和减去k，即sum-k，判断sum-k是否为某个位置的前n项和，若是，更新统计量。

关键在于理解map映射关系的含义：key是前缀和，value是前缀和出现的次数

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int sum = 0, ans = 0;
        unordered_map<int,int> mp;
        mp[0] = 1;
        for(int i: nums){
            sum += i;
            if(mp.find(sum-k) != mp.end()) ans += mp[sum-k];
            mp[sum] ++;
        }
        return ans;
    }
};
```







前缀和的模板：[前缀和模版 模版给你归纳好了，适用于求长度， 求个数 - 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/solution/qian-zhui-he-by-ren-william-5ppz/)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp={{0,1}};  //初始值， 如果是求个数， 代表个数就是1， 如果是求长度， 代表index 为-1
        int ans=0;
        int sum=0;

        for(auto& a:nums){
            sum+=a;             //根据题意有变化，比如奇数个数的1248题。
            int cur=sum-k;    //cur值根据题意进行改变， 求和是sum-k，求倍数就是 sum % k
            if(mp.count(cur)){
                ans+=mp[cur];
            }
            mp[sum]++;  //mp[cur或者sum]根据题意改变， 求长度就是sum的index， 求个数，一般要变化为cur的old个数++。
        }
        return ans;
    }
};
```



## 581最短无序了连续子数组

要求时间复杂度O（N）：如果要求O（n）的都可以思考以下双指针的解法：

双指针一个指针向右，不断找到无序的右边界，一个向左，找到左边界：

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int n=nums.size();
        int left=-1,right=-1;
        int maxn=INT_MIN,minn=INT_MAX;
        for(int i=0;i<n;i++){
            if(nums[i]>=maxn) maxn=max(nums[i],maxn);
            else right=i;
        }
        for(int j=n-1;j>=0;j--){
            if(nums[j]<=minn) minn=min(nums[j],minn);
            else left=j;
        }
        return right==-1 ? 0 :right-left+1;
    }
};
```

方法2：时间复杂度空间复杂度都为O（nlogn）

==is_sorted函数，判断是否原本就有序==

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if (is_sorted(nums.begin(), nums.end())) {
            return 0;
        }
        vector<int> numsSorted(nums);
        sort(numsSorted.begin(), numsSorted.end());
        int left = 0;
        while (nums[left] == numsSorted[left]) {
            left++;
        }
        int right = nums.size() - 1;
        while (nums[right] == numsSorted[right]) {
            right--;
        }
        return right - left + 1;
    }
};
```





## 621任务调度器

建立大小为 `n+1` 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 `n=2`，A 任务个数 6 个，我们建立 6 桶子，每个容量为 3：

![image-20230118112001964](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230118112001964.png)

![image.png](https://pic.leetcode-cn.com/8993d48fb4109d5d207f135bf73e10fd22c898c25113e5fa09bc91829790f9a0-image.png)

**总排队时间 = (桶个数 - 1) \* (n + 1) + 最后一桶的任务数**

1. 当冷却时间短，任务种类很多时

![image-20230118112056993](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230118112056993.png)

此时我们可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况：

继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。
**也就是说，我们执行任务所需的时间，就是任务的数量**

记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X，计算 NUM1=(N-1)*(n+1)+x
NUM2=tasks.size()
输出其中较大值即可
因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是 NUM2>=NUM1

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char,int> mp;
        for(char task:tasks){
            mp[task]++;
        }
        int maxSize=0,x=0;
        for(auto i:mp){
            if(i.second > maxSize) {
                maxSize=i.second;
                x=1;
            }
            else if(i.second==maxSize) x++;//如果数目相同多执行一次
        }
        int nums1=tasks.size();
        int nums2=(maxSize-1)*(n+1)+x;
        return max(nums1,nums2);
    }
};
```







##面试常考（链表+dp+树+字符串+数组+回溯）

回溯排列组合那几个有空也看看



### ==82 删除排序链表中的重复元素Ⅱ==

多了一个while：

```cpp
while(cur->next!=nullptr && cur->next->next!=nullptr){
            if(cur->next->val==cur->next->next->val){
                int x=cur->next->val;
                while(cur->next && cur->next->val==x){
                    cur->next=cur->next->next;
                }
            }
            else{
                cur=cur->next;
            } 
        }
```



 ```cpp
 class Solution {
 public:
     ListNode* deleteDuplicates(ListNode* head) {
         ListNode* dummyHead=new ListNode(-1);
         dummyHead->next=head;
         ListNode*cur=dummyHead;
         while(cur->next!=nullptr && cur->next->next!=nullptr){
             if(cur->next->val==cur->next->next->val){
                 int x=cur->next->val;
                 while(cur->next && cur->next->val==x){
                     cur->next=cur->next->next;
                 }
             }
             else{
                 cur=cur->next;
             } 
         }
         head=dummyHead->next;
         delete dummyHead;
         return head;
     }
 };
 ```

关键在于相等的去重



### 剑指32 之字形打印二叉树

和层序一模一样，加一个bool类型的flag控制遍历方向即可：

最后面flag=！flag；

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        if(root != nullptr) q.push(root);
        vector<vector<int>> result;
        bool flag=true;
        while(!q.empty()){
            int size=q.size();
            vector<int> v;
            for(int i=0;i<size;i++){
                TreeNode* cur=q.front();
                q.pop();
                v.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            if(flag){
                result.push_back(v); 
            }
            else if(flag==false){
                reverse(v.begin(),v.end());
                result.push_back(v);
            }
            flag = !flag;
        }
        return result;
    }
};
```



### 56.合并区间

先排序！！！,自定义一个排序方法，左边界右边界先定义好，然后去和后面区间比较

```cpp
class Solution {
public:
    static bool cmp(const vector<int>& a,const vector<int>&b){
        return a[0]<b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        sort(intervals.begin(),intervals.end(),cmp);
        int leftBound=intervals[0][0],rightBound=intervals[0][1];
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]>rightBound){
                result.push_back({leftBound,rightBound});
                leftBound=intervals[i][0];
                rightBound=intervals[i][1];
            }
            else{
                leftBound=min(leftBound,intervals[i][0]);
                rightBound=max(rightBound,intervals[i][1]);
            }
        }
        result.push_back({leftBound,rightBound});
        return result;
    }
};
```



### ==763.划分字母区间==

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

![763.划分字母区间](https://img-blog.csdnimg.cn/20201222191924417.png)

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> bound;
        int index=0;
        for(int i=0;i<s.size();i++){
            for(int j=i;j<s.size();j++){
                if(s[i]==s[j]){
                    index=j;
                }
            }
            bound.push_back(index);
        }

        vector<int> result;
        int maxbound=INT_MIN;
        int begin=0;
        for(int i=0;i<s.size();i++){
            maxbound=max(bound[i],maxbound);
            if(i==maxbound){
                result.push_back(maxbound-begin+1);
                begin=i+1;
                maxbound=INT_MIN;
            }
        }
        return result;
    }
};
```





### ==72.编辑距离==

注意点，dp都要比原本数组+1，循环的时候也都要《=

记住是i-1和j-1

递推公式: `dp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1});`



==子数组不等直接变为0，子序列才是二者选大值。==

**如果是最长重复子数组：**

```cpp
if(num1[i-1]==nums2[j-1]){
    dp[i][j]=dp[i-1][j-1]+1;
}
else dp[i][j]=0;
```

**如果是最长公共子序列：**

```cpp
if(text1[i-1]==text2[j-1]){
  dp[i][j]=dp[i-1][j-1]+1;
}
else{
  dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
}
```

**300.最长递增子序列**

```cpp
for (int i=0;i<nums.size();i++){
    for(int j=0;j<i;j++){
        if ....{
            dp[i]=max(dp[i],dp[j]-1);
        }
    }
}
```

###==673.最长递增子序列的个数：==

dp[i]：i之前（包括i）最长递增子序列的长度为dp[i]

count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]

```cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        if(nums.size()==1) return 1;
        int result=0;
        vector<int> dp(nums.size(),1);
        vector<int> count(nums.size(), 1);
        int maxCount=0;
        for(int i=1;i<nums.size();i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    if(dp[j]+1>dp[i]){
                        count[i]=count[j];
                    }
                    else if(dp[j]+1==dp[i]){
                        count[i]+=count[j];
                    }
                    dp[i]=max(dp[i],dp[j]+1);
                }
                if(dp[i]>maxCount) maxCount=dp[i];
            }
        }
        for(int i=0;i<nums.size();i++){
            if(maxCount==dp[i]) result+=count[i];
        }
        return result;
    }
};
```







```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1,vector<int>(word2.size()+1,0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for(int i=1;i<=word1.size();i++){
            for(int j=1;j<=word2.size();j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 111.二叉树的最小深度

重新写一个getDepth。分别递归获得左右长度。

int result=1+min（left，right）；

```cpp
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```

### 114二叉树展开为链表

递归把左子树放到右子树上

### 96 不同的二叉搜素树

动态规划:

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

```cpp
class Solution {
public:
    int numTrees(int n) {
        if(n==1 || n==2) return n;
        vector<int> dp(n+1,0);
        dp[0]=1,dp[1]=1,dp[2]=2;
        for(int i=3;i<=n;i++){
            for(int j=0;j<i;j++){
                dp[i]+=dp[j]*dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

### 92. 反转链表Ⅱ

```cpp
class Solution {
public:
    void reverseList(ListNode* head){
        ListNode* pre=nullptr;
        ListNode*cur=head;
        ListNode* tmp;
        while(cur){
            tmp=cur->next;
            cur->next=pre;
            pre = cur;
            cur=tmp;
        }
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode* pre=dummyHead;
        for(int i=0;i<left-1;i++){
            pre=pre->next;
        }
        ListNode* rightNode=dummyHead;
        for(int i=0;i<right;i++){
            rightNode=rightNode->next;
        }
        auto leftNode=pre->next;
        auto curr=rightNode->next;
        pre->next=nullptr;
        rightNode->next=nullptr;
        reverseList(leftNode);
        pre->next=rightNode;
        leftNode->next=curr;
        return dummyHead->next;
    }
};
```

### 112路劲总和

自定向下的模板

```cpp
一般路径：
vector<vector<int>>res;
void dfs(TreeNode*root,vector<int>path)
{
    if(!root) return;  //根节点为空直接返回
    path.push_back(root->val);  //作出选择
    if(!root->left && !root->right) //如果到叶节点  
    {
        res.push_back(path);
        return;
    }
    dfs(root->left,path);  //继续递归
    dfs(root->right,path);
}

# **给定和的路径：**
void dfs(TreeNode*root, int sum, vector<int> path)
{
    if (!root)
        return;
    sum -= root->val;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == 0)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, sum, path);
    dfs(root->right, sum, path);
}
```

4、是否要双重递归(即调用根节点的dfs函数后，继续调用根左右节点的pathsum函数)：看题目要不要求从根节点开始的，还是从任意节点开始

本题就是典型双重递归：

```cpp
class Solution {
public:
    int count=0;
    int pathSum(TreeNode* root, long long targetSum) {
        if(root==nullptr) return 0;
        dfs(root,targetSum);
        pathSum(root->left,targetSum);
        pathSum(root->right,targetSum);
        return count;
    }
    void dfs(TreeNode* root,long long targetSum){
        if(root==nullptr) return;
        targetSum-=root->val;
        if(targetSum==0){
            count++;
        }
        dfs(root->left,targetSum);
        dfs(root->right,targetSum);
    }
};
```



```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        traversal(root,targetSum);
        return flag;
    }
    bool flag=false;
    void traversal(TreeNode* cur,int targetSum){
        if(cur==nullptr) return;
        else{
            targetSum-=cur->val;
            if(cur->left==nullptr && cur->right==nullptr && targetSum==0){
                flag=true;
            }
            traversal(cur->left,targetSum);
            traversal(cur->right,targetSum);
        }
    }
};
```

###113路径总和Ⅱ

traversal要带上path就可以。

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return {};
        traversal(root,targetSum,path);
        return result;
    }
    vector<int> path;
    vector<vector<int>> result;
    void traversal(TreeNode* root,int targetSum,vector<int>path){
        if(root==nullptr) return;
        targetSum-=root->val;
        path.push_back(root->val);
        if(root->left==nullptr && root->right==nullptr && targetSum==0){
            result.push_back(path);
        }
        traversal(root->left,targetSum,path);
        traversal(root->right,targetSum,path);
    }
};
```



### ==437路劲总和三==

非自顶向下

双重递归，让自己递归，让左右孩子递归！！！

```cpp
class Solution {
public:
    int pathSum(TreeNode* root, long long targetSum) {
        if(root==nullptr) return 0;
        traversal(root,targetSum);
        pathSum(root->left,targetSum);
        pathSum(root->right,targetSum);
        return count;
    }
    int count=0;
    void traversal(TreeNode* cur,long long sum){
        if(cur==nullptr) return;
        sum-=cur->val;
        if(sum==0){
            count++;
        }
        traversal(cur->left,sum);
        traversal(cur->right,sum);
    }
};
```

### ==538 把二叉搜索树变为累加树==

中序遍历的反遍历，先右后左

```cpp
class Solution {
public:
    int preValue=0;
    void traversal(TreeNode* cur){
        if(cur==nullptr) return;
        traversal(cur->right);
        cur->val+=preValue;
        preValue=cur->val;
        traversal(cur->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        traversal(root);
        return root;
    }
};
```

### ==236二叉树的最近公共祖先==

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==nullptr) return nullptr;
        if(root==q||root==p) return root;
        TreeNode* left=lowestCommonAncestor(root->left,p,q);
        TreeNode* right=lowestCommonAncestor(root->right,p,q);
        if(left!=nullptr && right!=nullptr) return root;
        if(left!=nullptr && right==nullptr) return left;
        else if(left==nullptr && right!=nullptr) return right;
        else{
            return nullptr;
        }
    }
};
```

###221.最大正方形：

动态规划，求边长,求完边长求面积

以 `matrix[i][j]` 为右下角元素的最大的全为 1 正方形矩阵的边长为 `dp[i][j]`。

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int n=matrix.size(),m=matrix[0].size();
        vector<vector<int>>dp(n,vector<int>(m,0));
        for(int i=0;i<n;i++){
            if(matrix[i][0]=='1') dp[i][0]=1; 
        }
        for(int j=0;j<m;j++){
            if(matrix[0][j]=='1') dp[0][j]=1;
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(matrix[i][j]=='1'){
                    dp[i][j]=min({dp[i][j-1],dp[i-1][j],dp[i-1][j-1]})+1;
                }
                else continue;
            }
        }
        int result=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                result=max(result,dp[i][j]);
            }
        }
        return result*result;
    }
};
```

###3最长无重复字符子串

滑动窗口，2while+一个哈希

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> mp;
        int left=0,right=0,len;
        while(right<s.size()){
            char c=s[right];
            mp[c]++;
            right++;
            while(mp[c]>1){
                char d=s[left];
                left++;
                mp[d]--;
            }
            len=max(len,right-left);
        }
        return len;
    }
};
```



###==25.K个一组反转链表==

while循环用的while（1）

```c
class Solution {
public:
    //实现反转部分链表（指定起点和终点）
    //hair，tail分别为该部分链表的前一个和后一个结点，方便在函数内将该部分链表与整体链表链接起来
    void reverseList(ListNode* hair,ListNode* tail){
        ListNode* pre=tail;         //链接链表后面
        ListNode* cur=hair->next;
        ListNode* tmp=NULL;
        while(cur!=tail){
            tmp=cur->next;          //暂存下一个结点
            cur->next=pre;          //反转
            //更新指针
            pre=cur;
            cur=tmp;
        }
        hair->next=pre;             //链接链表前面
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummyHead=new ListNode(0);//虚拟头结点
        dummyHead->next=head;
        ListNode* tail=head;//只是一开始先定义，后面会变
        ListNode* hair=dummyHead;
        while(1){
            //定位本轮反转的部分链表的后一个结点
            for(int i=0;i<k;i++){
                if(tail==NULL)          //如果在定位的过程中，已遍历完整个链表
                    return dummyHead->next;
                tail=tail->next;
            }
            reverseList(hair,tail);
            //定位下一轮反转的部分链表的前一个结点
            for(int i=0;i<k;i++)
                hair=hair->next;
        }
        return dummyHead->next; 
    }
};
```





###136只出现过一次的数

一个数和它本身做异或运算结果为 0，即 `a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即 `a ^ 0 = a`。

满足交换率：`a^b^c^d^c^b^a=d`

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=0;
        for(int num:nums){ 
            res=res^num;
        }
        return res;
    }
};
```

#### 540有序数组中的单一元素（二分+异或）

考虑数组中任意偶数下标x的元素；如果x之前，没有出现过 target； 显然 x和x+1 对应的元素应该是一样的，因为没有出现target则意味着所有元素都是成对出现。

直至某个位置有了第一个落单的元素 target； 则之后的所有偶数下标 x 的元素应该和 x - 1 是一样的。

while中left<right  不可用小于等于

一定要加mid==0 ||

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int left=0,right=nums.size()-1;
        while(left<right){
            int mid=(left+right)/2;
            if(mid%2==0){
                if(nums[mid]==nums[mid+1]){
                    left=mid+1;
                }
                else{
                    if (mid == 0 || nums[mid-1] != nums[mid]) return nums[mid];
                    right=mid-1;
                }
            }
            else {
                if (nums[mid] == nums[mid-1]) {
                    left = mid + 1;
                } else {
                    if (nums[mid] != nums[mid+1]) return nums[mid];
                    right = mid - 1;
                }
            }
        }
        return nums[right];
    }
};
```







### 53 最大子序列和

动态规划：`dp[i]=max(dp[i-1]+nums[i],nums[i]);`

贪心：

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxValue=INT_MIN;
        int count=0;
        for(int num:nums){
            count+=num;
            maxValue=max(maxValue,count);
            if(count<0){
                count=0;
            }
        }
        return maxValue;
    }
};


//动态规划
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(),INT_MIN);
        dp[0]=nums[0];
        int maxValue=dp[0];
        for(int i=1;i<nums.size();i++){
            dp[i]=max(nums[i],dp[i-1]+nums[i]);
            maxValue=max(dp[i],maxValue);
        }
        return maxValue;
    }
};
```

或者动态规划：dp[i]为以nums[i]结尾的最大子数组和。

dp[i]=max(nums[i],nums[i]+dp[i-1]);

### 121买卖股票

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(),vector<int>(2));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.size();i++){
            dp[i][0]=max(dp[i-1][0],-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```

股票含冷冻期那个题:

```cpp
dp[i][0]=max(dp[i-1][0],((i-2<0) ? 0 : dp[i-2][1]) - prices[i]);
```



###232栈实现队列

一个保存进，一个保存出。

```cpp
class MyQueue {
public:
    stack<int> st1;
    stack<int> st2;
    MyQueue() {

    }
    
    void push(int x) {
        st1.push(x);
    }
    
    int pop() {
        if(st2.empty()){
            while(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }
        int result=st2.top();
        st2.pop();
        return result;
    }
    
    int peek() {
        int res=this->pop();
        st2.push(res);
        return res;
    }
    
    bool empty() {
        return st2.empty() && st1.empty();
    }
};
```

###==415字符串相加==

while(i>=0 || j>=0 || add>0)

c好过了用0补齐。

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i=num1.size()-1,j=num2.size()-1,add=0;
        string ans="";
        while(i>=0 || j>=0 || add!=0){
            int x=i >=0 ?num1[i]-'0' :0;
            int y=j >=0 ?num2[j]-'0' :0;
            int result=x+y+add;
            ans.push_back('0'+result%10);
            add=result/10;
            i--;
            j--;
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```

### ==560.和为K的子数组（前缀和）==

前缀和+哈希表

假如存在区间[left,right]，使得在[left,right]这个区间的子数组的和为k。换句话说，就是前right项和减去前left-1项和等于k，即前left-1项和等于前right项和减去k。
可以这样做，在扫描数组的同时，假设当前扫到第i位，记录它的前i项和sum，用该和减去k，即sum-k，判断sum-k是否为某个位置的前n项和，若是，更新统计量。

关键在于理解map映射关系的含义：key是前缀和，value是前缀和出现的次数

**mp[0]初始化为1，找完find再把mp[sum]++;**

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        mp[0]=1;
        int res=0;
        int sum=0;
        for(int num:nums){
            sum+=num;
            if(mp.find(sum-k)!=mp.end()) res+=mp[sum-k];
            mp[sum]++; 
        }
        return res;
    }
};
```



###200岛屿数量

```cpp
class Solution {
public:
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        if (visited[x][y] || grid[x][y] == '0') return; // 终止条件：访问过的节点 或者 遇到海水
        visited[x][y] = true; // 标记访问过
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            dfs(grid, visited, nextx, nexty);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++; // 遇到没访问过的陆地，+1
                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```



### 31下一个排列

从后往前，找到第一个前面小于后面位置，保存。

然后从后往前找到第一个比这个位置大的值，交换二者，之后反转这个位置之后的值。

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int cur=nums.size()-2;

        while(cur>=0&&nums[cur]>=nums[cur+1])//前面大于等于后面的
        {
            cur--;
        }

        if(cur<0)//已经是最大数组了
            sort(nums.begin(),nums.end());
        else//表示找到了降序的一个位置
        {
            int pos=nums.size()-1;
            while(nums[pos]<=nums[cur])
            {
                pos--;
            }

            swap(nums[cur],nums[pos]);
            reverse(nums.begin()+cur+1,nums.end());
        }
    }
};
```



### 300最长上升子序列

要和前面的每一个都比，所以要+一个for(int j=0,j<nums.size();j++)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size()+1,1);
        int result=0;
        for(int i=0;i<nums.size();i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i]=max(dp[j]+1,dp[i]);
                }
            }
            result=max(result,dp[i]);
        }
        return result;
    }
};
```



### 20.有效括号

**return st.empty（）**

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(') st.push(')');
            else if(s[i]=='{') st.push('}');
            else if(s[i]=='[') st.push(']');
            else if(st.empty() || st.top()!=s[i]) return false;
            else st.pop();
        }
        return st.empty();
    }
};
```



###==143 重排链表==

把链表结点放到数组中，然后新建一个cur，轮流往里放

```cpp
class Solution {
public:

    void travelList(ListNode* cur,vector<ListNode*>& v){
        while(cur){
            v.push_back(cur);
            cur=cur->next;
        }
    }
    void reorderList(ListNode* head) {
        if(head==nullptr) return;
        vector<ListNode*> path;
        travelList(head,path);
        ListNode* cur=head;
        int i=1,j=path.size()-1,count=0;
        while(i<=j){
            if(count%2==0){
                cur->next=path[j];
                j--;
            }
            else{
                cur->next=path[i];
                i++;
            }
            cur=cur->next;
            count++;
        }
        cur->next=nullptr;
    }
};
```

或者快慢指针将链表一分为二，然后后半条链表反转，然后两个链表拼成一个链表。



###69 x的平方根

二分，right=x/2+1；

```cpp
class Solution {
public:
    int mySqrt(int x) {
        long left = 1;
        long right = x/2+1;
        long mid;
        while(left<=right){
            mid = left+(right-left)/2;
            if(mid*mid<x) left=mid+1;
            else if(mid*mid>x) right=mid-1;
            else if(mid*mid == x) return mid;
        }
        if(x==0) return 0;
        if(x==1) return 1;
        return right;
    }
};
```



###2.两数相加

和415字符串相加很像，创建一个preValue，循环条件为`while(cur1!=nullptr || cur2!=nullptr || preValue>0)`

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* cur1=l1;
        ListNode* cur2=l2;
        ListNode* dummyHead=new ListNode(0);
        ListNode* cur=dummyHead;
        int preVal=0;
        while(cur1!=nullptr || cur2!=nullptr || preVal>0){
            int curSum=preVal;
            if(cur1!=nullptr){
                curSum+=cur1->val;
                cur1=cur1->next;
            }
            if(cur2!=nullptr){
                curSum+=cur2->val;
                cur2=cur2->next;
            }
            preVal=curSum/10;
            curSum=curSum%10;
            cur->next=new ListNode(curSum);
            cur=cur->next;
        }
        ListNode* head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```



###162.寻找峰值

要求时间复杂度O（logn），二分的时间复杂度为O（logN），

如果`nums[mid] > nums[mid + 1]`，那么在`[l, mid]`这个区间内一定存在一个峰值。

如果`nums[mid] < nums[mid + 1]`，那么在`[mid+1, r]`这个区间内一定存在一个峰值。

加个条件：mid<nums.size()-1;

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(right+left)/2;
            if(mid<nums.size()-1 && nums[mid]<nums[mid+1]) left=mid+1;
            else{
                right=mid-1;
            }
        }
        return left;
    }
};
```



### ==42.接雨水+其他思路==

双指针思路：**每一列的雨水数目=左右最高列中的小值-自身的列高(力扣会超时)**，时间复杂度O（n^2^）,空间复杂度为O（1）

要用while反复接雨水：`while(!st.empty() && height[i]>height[st.top()])`

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()<=2) return 0;
        stack<int> st;
        st.push(0);
        int water=0;
        for(int i=1;i<height.size();i++){
            if(height[i]<height[i-1]) st.push(i);
            else if(height[i]==height[i-1]){
                st.pop();
                st.push(i);
            }
            else{
                while(!st.empty() && height[i]>height[st.top()]){
                    int mid=height[st.top()];
                    st.pop();
                    if(!st.empty()){
                        int h=min(height[st.top()],height[i])-mid;
                        int w=i-st.top()-1;
                        water+=h*w;
                    }
                }   
            }
            st.push(i);
        }
        return water;
    }
};
```

### 每日温度

小于的时候：`result[st.top()]=i-st.top();`

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        st.push(0);
        vector<int> result(temperatures.size(),0);
        for(int i=1;i<temperatures.size();i++){
            if(temperatures[i]<=temperatures[st.top()]) st.push(i);
            else{
                while(!st.empty() && temperatures[i]>temperatures[st.top()]){
                    result[st.top()]=i-st.top();
                    st.pop();
                }
            }
            st.push(i);
        }
        return result;
    }
};
```



### 1046 最后一块石头的重量和

大顶堆

```cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int,vector<int>> pq;
        for(int stone:stones){
            pq.push(stone);
        }
        while(pq.size()>1){
            int a=pq.top();
            pq.pop();
            int b=pq.top();
            pq.pop();
            if(abs(a-b)>0) pq.push(abs(a-b));
        }
        if(pq.empty()) return 0;
        return pq.top();
    }
};
```



### 155最小栈

![image.png](https://pic.leetcode-cn.com/1650469898-solthm-image.png)

两个栈，一个存最小值。

```cpp
class MinStack {
public:
    stack<int> st;
    stack<int> minst;

    MinStack() {
        while(!st.empty()){
            st.pop();
        }
        while(!minst.empty()){
            minst.pop();
        }
        minst.push(INT_MAX);
    }
    
    void push(int val) {
        st.push(val);
        if(minst.top()>val) minst.push(val);
        else{
            minst.push(minst.top());
        }
    }
    
    void pop() {
        st.pop();
        minst.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return minst.top();
    }
};
```

### 三数之和

先排序，然后for循环，left=i+1，right=nums.size()-1

一级去重`if(i>0 && nums[i]==num[i-1]) continue;`

二级去重：找到相等的之后：

```cpp
while(left<right && nums[left]==nums[left+1]) left++;
while(left<right && nums[right]==nums[right-1]) right--;
```



```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        if(nums[0]>0) return result;
        for(int i=0;i<nums.size();i++){
            if(nums[i]>0) return result;
            if(i>0 && nums[i]==nums[i-1]) continue;
            int left=i+1,right=nums.size()-1;
            while(left<right){
                if(nums[i]+nums[left]+nums[right]<0) left++;
                else if(nums[i]+nums[left]+nums[right]>0) right--;
                else{
                    result.push_back({nums[i],nums[left],nums[right]});
                    while(right>left && nums[right]==nums[right-1]) right--;
                    while(right>left && nums[left]==nums[left+1]) left++;
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
};
```



###回文：5，131，132，647，516

### 5.最长回文子串(回文的判断+边界处理)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int start=0,end=0,len=0;
        if(s.size()==1) return s;
        for(int i=0;i<s.size();i++){
            int len1=isPal(s,i,i);
            int len2=isPal(s,i,i+1);
            len=max(len1,len2);
            if(len>end-start){
                start=i-(len-1)/2;
                end=i+len/2;
            }
        }
        return s.substr(start,end-start+1);
    }

    int isPal(const string& s,int left,int right){
        while(left>=0 && right<s.size() && s[left]==s[right]){
            right++;
            left--;
        }
        return right-left-1;
    }
};
```

动态规划解法：

第一次遍历要从后往前,数组要用bool类型数组

```cpp
vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false);
for(int i=s.size()-1;i>=0;i--){
    for(int j=i;j<s.size();j++){
         if(s[i]==s[j]){
              if(j-i<=1) dp[i][j]=true;
              else if(dp[i+1][j-1]) dp[i][j]=true;
         }
}
```



```cpp
//动态规划
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(),false));
        int maxlenghth=0;
        int left=0,right=0;
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i;j<s.size();j++){
                if(s[i]==s[j]){
                    if(j-i<=1) dp[i][j]=true;
                    else if(dp[i+1][j-1]) dp[i][j]=true;
                }
                if(dp[i][j] && j-i+1>maxlenghth){
                    maxlenghth=j-i+1;
                    left=i;
                    right=j;
                }
            }
        }
        return s.substr(left,maxlenghth);
    }
};
```



### 131分割回文串（回溯+回文）

==bool类型的判断回文，这里的判断回文要从两端向中心，因为后面要用一个start和for i循环。==

else的时候continue

**回溯传入数据不可用引用方式，要不然数据生成不了。**

```cpp
class Solution {
public:
    bool issamestring(const string& s,int left,int right){
        for(int i=left,j=right;i<j;i++,j--){
            if(s[i]!=s[j]) return false;
        }
        return true;
    }
    vector<string> path;
    vector<vector<string>> result;
    void backtracking(string s,int start){
        if(start>=s.size()){
            result.push_back(path);
            return;
        }
        for(int i=start;i<s.size();i++){
            if(issamestring(s,start,i)){
                path.push_back(s.substr(start,i-start+1));
            }
            else{
                continue;
            }
            backtracking(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        backtracking(s,0);
        return result;
    }
};
```

### 132.分割回文串Ⅱ（hard+动态规划）

```cpp
```



### ==115 不同子序列==

递推公式：`if(s[i-1]==t[i-1]) dp[i][j]=dp[i-1][j-1]+dp[i-1][j];`

`else dp[i][j]=dp[i-1][j]`

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size()+1,vector<uint64_t>(t.size()+1,0));
        for(int i=0;i<s.size();i++) dp[i][0]=1;
        for(int j=1;j<t.size();j++) dp[0][j]=0;
        for(int i=1;i<=s.size();i++){
            for(int j=1;j<=t.size();j++){
                if(s[i-1]==t[j-1]){
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
                }
                else{
                    dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```



###647回文子串

最简单的判断回文就可以，统计个数

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int result=0;
        for(int i=0;i<s.size();i++){
            result+=count(s,i,i);
            result+=count(s,i,i+1);
        }
        return result;       
    }

    int count(const string&s, int left,int right){
        int result=0;
        while(left>=0 && right<s.size() && s[left]==s[right]){
            left--;
            right++;
            result++;
        }
        return result;
    }
};
```

### ==516最长回文子序列（动态规划）==

i代表左边，j代表右边

初始化：`for(int i=0;i<s.size();i++) dp[i][i]=1;`

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        for(int i=s.size()-1;i>=0;i--){
            for(int j=i+1;j<s.size();j++){
                if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2;
                else{
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][s.size()-1];
    }
};
```







### 背包问题的DP

dp[j]表示什么？==表示的是价值，[i]表示目前放的物品个数，下标数目，[j]表示的是目前背包的总容量。**从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。**==

背包问题的标准dp公式：

vector<int> dp(bagWeight + 1, 0);，因为也要计算=bagesize的时候的情况，所以数组大小要设置为bagsize+1.

**同时内层循环要是大于等于**

```cpp
1、最值问题: dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);
2、存在问题(bool)：dp[i]=dp[i]||dp[i-num];
3、组合问题：dp[i]+=dp[i-num];

1、0/1背包：外循环nums,内循环target,target倒序且target>=nums[i];
2、完全背包：外循环nums,内循环target,target正序且target>=nums[i];
```

```cpp
0-1背包：每个物品只能拿一次
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
```



0-1背包：

416分割等子集:还是用最大可以拿到多少的策略，看看拿到的和背包大小是否相同，

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        
        if(sum%2 == 1) return false; 
        int bagsize=sum/2;
        vector<int> dp(bagsize+1,0);
        for(int i=0;i<nums.size();i++){
            for(int j=bagsize;j>=nums[i];j--){
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        if(dp[bagsize]==bagsize) return true;
        return false;
    }
};
```

1049最后一块石头重量和Ⅱ

也是一个取一半的01背包问题，最后剩多少就是：sum-2*dp[bagsize]

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum=0;
        for(int stone:stones){
            sum+=stone;
        }
        int bagsize=sum/2;
        vector<int>dp (bagsize+1,0);
        for(int i=0;i<stones.size();i++){
            for(int j=bagsize;j>=stones[i];j--){
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-2*dp[bagsize];
    }
};
```



### 494.目标和

dp的大小是bagsize（）+1

很巧妙：假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target，x=（sum+target）/2

这里的X就代表的背包容量。

无解条件要加上：`if((target+sum)%2==1) return 0;`

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(abs(target)>sum) return 0;
        if((target+sum)%2==1) return 0;
        int bagSize=(target+sum)/2;
        vector<int> dp(bagSize+1,0);
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=bagSize;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

完全背包问题：

322 518零钱兑换1+2



完全背包的内层是从j=weight[i];j<=bagsize;j++ 开始的

```cpp
for(int i=0;i<weight.size();i++){
    for(int j=weight[i];j<=bagsize();j++){
        
    }
}
```







**完全背包内层是从j=coins[i];j<amount;j++的**

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1,0);
        dp[0]=1;
        for(int i=0;i<coins.size();i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
```



322零钱兑换2 

最小值问题一般dp数组要初始化为INT_MAX

dp公式在推到的时候记得加一个判断：

`if(dp[j-coins[i]]!=INT_MAX)`不然会越界。

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<coins.size();i++){
            for(int j=coins[i];j<=amount;j++){
                if(dp[j-coins[i]]!=INT_MAX){
                    dp[j]=min(dp[j],dp[j-coins[i]]+1);
                }                
            }
        }
        if(dp[amount]==INT_MAX) return -1;
        return dp[amount];
    }
};
```



### 279.完全平方数

用i*i来做第一层循环。

这里的n相当于之前的coins.size（）-1；

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1,INT_MAX);
        dp[0]=0;
        for(int i=1;i*i<=n;i++){
            for(int j=i*i;j<=n;j++){
                if(dp[j-i*i]!=INT_MAX){
                    dp[j]=min(dp[j],dp[j-i*i]+1);
                }             
            }
        }
        return dp[n];
    }
};
```



###==139.单词拆分（背一下）==

先背包后物体，定义为bool类型的dp数组

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size()+1,false);
        dp[0]=true;
        for(int i=0;i<=s.size();i++){
            for(auto word:wordDict){
                int size=word.size();
                if(i-size>=0 && s.substr(i-size,size)==word){
                    dp[i]=dp[i]||dp[i-size];
                }
            }
        }
        return dp[s.size()];
    }
};
```





### 打家劫舍类问题1和2

198.打家劫舍1

不难，记得地推公式。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        vector<int> dp(nums.size(),0);
        dp[0]=nums[0];
        dp[1]=max(nums[0],nums[1]);
        for(int i=2;i<nums.size();i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.size()-1];
    }
};
```



打家劫舍Ⅱ

自己再写一个rob函数

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int value1=robRoom(nums,0,nums.size()-2);
        int value2=robRoom(nums,1,nums.size()-1);
        int value=max(value1,value2);
        return value;
    }
    int robRoom(vector<int>& nums,int left,int right){
        if(left==right) return nums[left];
        vector<int> dp(nums.size(),0);
        dp[left]=nums[left];
        dp[left+1]=max(nums[left],nums[left+1]);
        for(int i=left+2;i<=right;i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[right];
    }
};
```





### 全排列、全组合问题

### 77.组合

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(int n,int k,int start){
        if(path.size()==k){
            result.push_back(path);
            return;
        }
        for(int i=start;i<=n;i++){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();
        }
    }
};
```

40.组合的总和Ⅱ

注意点：==unordered_set去重要注意排序。然后终止条件有两个，一个刚刚好等于，一个大于==

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates,int target,int sum,int start){
        if(sum>target) return;
        if(sum==target){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i=start;i<candidates.size();i++){
            if(uset.find(candidates[i]) != uset.end()){
                continue;
            }
            uset.insert(candidates[i]);
            sum+=candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates,target,sum,i+1);
            path.pop_back();
            sum-=candidates[i];
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtracking(candidates,target,0,0);
        return result;
    }
};
```

### ==46.全排列==

==只有排列问题要用used去重，used数组一开始默认全false==

`if(used[i]==true) continue;`

==used也参与回溯的过程。==

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();i++){
            if(used[i]==true) continue;
            used[i]=true;
            path.push_back(nums[i]);
            backtracking(nums,used);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        backtracking(nums,used);
        return result;
    }
};
```

全排列Ⅱ：set搭配used

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtrackint(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        unordered_set<int> uset;
        for(int i=0;i<nums.size();i++){
            if(uset.find(nums[i])!=uset.end()) continue;
            if(used[i]==false){
                uset.insert(nums[i]);
                used[i]=true;
                path.push_back(nums[i]);
                backtrackint(nums,used);
                path.pop_back();
                used[i]=false;
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<bool> used(nums.size(),false);
        backtrackint(nums,used);
        return result;
    }
};
```



### 78.子集

每次都push_back

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return result;
    }
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums,int start){
        if(start>nums.size()) return;
        for(int i=start;i<nums.size();i++){
            path.push_back(nums[i]);
            backtracking(nums,i+1);
            path.pop_back();
        }
        result.push_back(path);
    }
};
```

子集二：有重复值但不能包含重复的子集：用set去重即可。



### 260 137只出现过一次的数字

==137只出现过一次的数字Ⅱ==(137背一背，260算了)

如果把每一个数字都看成二进制，那么一个十进制数nums[i]对应一个32位的二进制数。将所有nums[i]对应的二进制数的对应位求和，将每一对应位的和值与3进行取模运算，得到的余数就是答案的对应二进制位的数值。这是因为除了答案本身，其它元素都是三个三个为一组的。

`sum += ((num >> i) & 1); // 提取从右往左数第i位的数值，将所有nums[i]// 二进制下的第i位数值进行求和`

==`res |= (1<<i)`==

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < 32; i++) { // 因为nums[i]是32位整数，
        // 所以针对每一位的对应二进制数值求和
            int sum = 0;
            for (int num : nums) {
                sum += ((num >> i) & 1); // 提取从右往左数第i位的数值，将所有nums[i]
                // 二进制下的第i位数值进行求和
            }
            if (sum % 3 == 1) { // 如果没办法被3整除，那么说明落单的那个数的第i位是1不是0
                res |= (1 << i);
            }
        }
        return res; // 输出结果
    }
};
```

260.只出现一次的数字Ⅲ

现在假设两个只出现一次的数字是x,y，那么对全部数组数据进行异或后的结果就是x^y
1.分组异或的目的：要从x^y中分离出x和y，让x在一个组nums1中，y在另一个组nums2中
 2.如何分组：
1）x,y一定是两个不同的数字，那么他们的二进制表达下就至少有一个位置数字不相同，而考虑一个事情：同一位置上01不同异或结果为1
 2）分组依据：x^y中任意一个为1的位置，这个代表了x,y在这个位置上数字不同，这里为了方便我们就取低至高的第一个为1的位置
3.nums1全部异或结果 = x,nums2全部异或结果 = y
原因：两个相同的数字一定在同一组中，异或结果为0，自然两个分组全部异或的结果就是一个为x,一个为y

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        //sumXOR:全部数组数据的异或和，也就是x^y
        int sumXOR = 0;
        for(int& n : nums){
            sumXOR ^= n;
        }
        //寻找x^y中低至高的第一个为1的位置
        int index = 1;
        while(((sumXOR & index) == 0)){
            index <<= 1;
        }
        //根据index把nums数组分成两个部分，也就是满足index & nums[i] == 1的是一组，否则就是另一组
        int sumXOR1 = 0,sumXOR0 = 0;
        for(int& num : nums){
            if(index & num){
                sumXOR1 ^= num;
            }
            else{
                sumXOR0 ^= num;
            }
        }
        return {sumXOR0,sumXOR1};
    }
};
```







### 151反转字符串中的单词

先用erase删除空格，分为前面后面，中间。用erase的时候，删除中间的迭代器要i--；

```cpp
class Solution {
public:
    void removeExtraSpace(string& s){
        for(int i=0;i<s.size()-1;i++){
            if(s[i]==' ' && s[i]==s[i+1]) {
                s.erase(s.begin()+i);
                i--;
            }
            if(s.size()>0 && s[0]==' ') s.erase(s.begin());
            if(s.size()>0 && s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);
        }
    }
    string reverseWords(string s) {
        removeExtraSpace(s);
        reverse(s.begin(),s.end());
        int start=0;
        for(int i=0;i<s.size();i++){
            if(s[i]==' '){
                reverse(s.begin()+start,s.begin()+i);
                start=i+1;
            }
            if(i==s.size()-1){
                reverse(s.begin()+start,s.end());
            }
        }
        return s;
    }
};
```

对erase的用法解释：



### 27移除元素

等于那个元素就先跳过，然后一个一个往前覆盖。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow=0,fast=0;
        while(fast<nums.size()){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```



### 912.排序数组

双路并归

```cpp
class Solution {
    vector<int> tmp;
    void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) / 2 ;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[cnt++] = nums[i++];
            }
            else {
                tmp[cnt++] = nums[j++];
            }
        }
        while (i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while (j <= r) {
            tmp[cnt++] = nums[j++];
        }
        for (int i = 0; i < r - l + 1; ++i) {
            nums[i + l] = tmp[i];
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize((int)nums.size(), 0);
        mergeSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```



### 88 合并两个有序数组

指针指向最后，从后向前生成。

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1,j=n-1,p=nums1.size()-1;
        while(i>=0 && j>=0){
            if(nums1[i]>nums2[j]){
                nums1[p]=nums1[i];
                i--;
            }
            else{
                nums1[p]=nums2[j];
                j--;
            }
            p--;
        }
        while(j>=0){
            nums1[p]=nums2[j];
            j--;
            p--;
        }
    }
};
```



###33.搜素旋转排序数组

二分

### 120.三角形最小路劲和

动态规划问题。`dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]`，腰上的也要初始化，很简单，别紧张。

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int m=triangle.size();
        vector<vector<int>> dp(m,vector<int>(m,0));
        //if(triangle.size()==1) return triangle[0][0];
        dp[0][0]=triangle[0][0];
        for(int i=1;i<m;i++){
            dp[i][0]=dp[i-1][0]+triangle[i][0];
            dp[i][i]=dp[i-1][i-1]+triangle[i][i];
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<i;j++){
                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];
            }     
        }
        int minSum=dp[m-1][0];
        for(auto e:dp[m-1]){
            if(minSum>e) minSum=e;
        }
        return minSum;
    }
};
```



### ==895.最大频率栈==

vector<stack<int>> stacks,容器里面放的是栈

![image-20230305140412053](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230305140412053.png)

出现两次的时候就要重新创建一个栈来保存二次出现的，相当于一个频率创建一个栈

`vector<stack<int>> stacks`

```cpp
class FreqStack {
    unordered_map<int, int> cnt;
    vector<stack<int>> stacks;
public:
    void push(int val) {
        if (cnt[val] == stacks.size()) // 这个元素的频率已经是目前最多的，现在又出现了一次
            stacks.push_back({}); // 那么必须创建一个新栈
        stacks[cnt[val]].push(val);
        ++cnt[val]; // 更新频率
    }

    int pop() {
        int val = stacks.back().top(); // 弹出最右侧栈的栈顶
        stacks.back().pop();
        if (stacks.back().empty()) // 栈为空
            stacks.pop_back(); // 删除
        --cnt[val]; // 更新频率
        return val;
    }
};

class FreqStack {
public:
    unordered_map<int,int> mp;
    vector<stack<int>> stacks;
    FreqStack() {

    }
    
    void push(int val) {
        if(mp[val]==stacks.size()) stacks.push_back({});
        stacks[mp[val]].push(val);
        mp[val]++;
    }
    
    int pop() {
        int val=stacks.back().top();
        stacks.back().pop();
        if(stacks.back().empty()){
            stacks.pop_back();
        }
        mp[val]--;
        return val;
    }
};
```



### 手写线程池

- 工作队列
- 任务队列
- 线程池的池
- `pthread_create`中的回调函数

```cpp
class ThreadPool{
private:
    //工作队列
    struct NWORKER{
        pthread_t threadid;//线程ID
        bool terminate;//是否需要结束该worker的标志
        int isWorking;//该worker是否在工作
        ThreadPool *pool;//隶属于的线程池
    } *m_workers;
	//任务队列
    struct NJOB{
        void (*func)(void *arg);     //任务函数
        void *user_data;	//函数参数
    };
public:
    //线程池初始化
    //numWorkers:线程数量
    ThreadPool(int numWorkers, int max_jobs);
    //销毁线程池
    ~ThreadPool();
    //面向用户的添加任务
    //int pushJob(void (*func)(void *data), void *arg, int len);

private:
    //向线程池中添加任务
    bool _addJob(NJOB* job);
    //回调函数
    static void* _run(void *arg);
    void _threadLoop(void *arg);

private:
    std::list<NJOB*> m_jobs_list;
    int m_max_jobs;							//任务队列中的最大任务数
    int m_sum_thread;						//worker总数
    int m_free_thread;						//空闲worker数
    pthread_cond_t m_jobs_cond;           //线程条件等待
    pthread_mutex_t m_jobs_mutex;         //为任务加锁防止一个任务被两个线程执行等其他情况
};

```

添加任务：



### 小顶堆的实现：

```cpp
vector<int> heap;
void top() {
    return heap[0];
}
void push(int k) {
    heap.push_back(k);
    swim(heap.size() - 1);
}

void swim(int pos) {
    while (pos > 0 && heap[(pos-1)/2] > heap[pos])) {
        swap(heap[(pos-1)/2], heap[pos]);
        pos = (pos-1)/2;
    }
}
void pop() {
    heap[0] = heap.back();
    heap.pop_back();
    sink(0);
}
void sink(int pos) {
    while (2 * pos + 1 < heap.size()) {
        int i = 2 * pos + 1;
        if (i+1 < heap.size() && heap[i] > heap[i+1]) ++i;//如果有两个子节点，找到较小的那个交换
        if (heap[pos] <= heap[i]) break;
        swap(heap[pos], heap[i]);
        pos = i;
    }
}
```



### 54.螺旋矩阵

设置四个点，加加减减搞清楚就可以。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int left=0,right=matrix[0].size()-1,up=0,down=matrix.size()-1;
        vector<int> result;
        while(1){
            for(int i=left;i<=right;i++){
                result.push_back(matrix[up][i]);
            }
            up++;
            if(up>down) break;
            for(int i=up;i<=down;i++){
                result.push_back(matrix[i][right]);
            }
            right--;
            if(right<left) break;
            for(int i=right;i>=left;i--){
                result.push_back(matrix[down][i]);
            }
            down--;
            if(down<up) break;
            for(int i=down;i>=up;i--){
                result.push_back(matrix[i][left]);
            }
            left++;
            if(left>right) break;
        }
        return result;
    }
};
```





###59.螺旋矩阵Ⅱ

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> result(n,vector<int>(n,0));
        int left=0,right=n-1,up=0,down=n-1;
        int num=1;
        while(1){
            for(int i=left;i<=right;i++){
                result[up][i]=num;
                num++;
            }
            up++;
            if(up>down) break;
            for(int i=up;i<=down;i++){
                result[i][right]=num;
                num++;
            }
            right--;
            if(right<left) break;
            for(int i=right;i>=left;i--){
                result[down][i]=num;
                num++;
            }
            down--;
            if(down<up) break;
            for(int i=down;i>=up;i--){
                result[i][left]=num;
                num++;
            }
            left++;
            if(left>right) break;
        }
        return result;
    }
};
```







###148.排序链表 （双路并归排序链表）

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        while (p) {
            ++length;
            p = p->next;
        }
        
        for (int size = 1; size < length; size *= 2) {
            auto cur = dummyHead.next;
            auto tail = &dummyHead;
            
            while (cur) {
                auto left = cur;
                auto right = cut(left, size); // left->@->@ right->@->@->@...
                cur = cut(right, size); // left->@->@ right->@->@  cur->@->...
                
                tail->next = merge(left, right);
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
        return dummyHead.next;
    }
    
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n && p) {
            p = p->next;
        }
        
        if (!p) return nullptr;
        
        auto next = p->next;
        p->next = nullptr;
        return next;
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummyHead(0);
        auto p = &dummyHead;
        while (l1 && l2) {
            if (l1->val < l2->val) {
                p->next = l1;
                p = l1;
                l1 = l1->next;       
            } else {
                p->next = l2;
                p = l2;
                l2 = l2->next;
            }
        }
        p->next = l1 ? l1 : l2;
        return dummyHead.next;
    }
};
```





### 7.整数反转

```cpp
class Solution {
public:
    int reverse(int x) {
        int y = 0; // y用来承接翻转后的整数
        while (x != 0) {
            if (y > 214748364 || y < -214748364) return 0; // 溢出，那么输出为0(这是题目要求)
            y = y * 10 + x % 10; // y在变化的同时x也在变化，效率高
            // x % 10的目的是得到个位的数值
            x = x / 10;   // x / 10相当于“右移移位运算”，是地板除。
        }
        return y; // 得到结果
    }
};
```



### 16.最接近的三数之和

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        if(nums.size() == 3) return nums[0]+nums[1]+nums[2];
        //int closestNum=INT_MAX;
        int res=nums[0]+nums[1]+nums[2];
        for(int i=0;i<nums.size()-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            int left=i+1,right=nums.size()-1;
            while(left<right){
                int sum=nums[left]+nums[right]+nums[i];
                if(sum<target){
                    if(abs(sum-target)<abs(res-target)) res=sum;      
                    left++;
                }
                if(sum>target){
                    if(abs(sum-target)<abs(res-target)) res=sum;
                    right--;
                }
                if(sum ==target) return target;
            }         
        }
        return res;
    }
};
```

### 6.N字形变换

![img](https://pic.leetcode-cn.com/d610b140dd0789204efe699672dc72a83e7b826da0165bbf083d24fc97ecdea7-image.png)



遇到行号为0或者行号为n-1的时候就改变箭头遍历的方向。设置一个标志位，遇到就改变标志位方向，然后打印。先把N字形的每一行放到一个vector<string>中

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1) return s;
        int size=s.size();
        vector<string> rows(min(numRows,size));
        bool goingDown=false;
        int curRow=0;
        for(char c:s){
            rows[curRow]+=c;
            if(curRow==0 || curRow==numRows-1){
                goingDown = !goingDown;      
            }
            curRow+= goingDown ? 1: -1;
        }
        string result;
        for(string str:rows){
            result+=str;
        }
        return result;
    }
};
```



### ==8.字符串转换整数（atoi）==

用while比用for好的多。

```cpp
class Solution {
public:
    int myAtoi(string s) {
        int n=s.size();
        bool signal=true;
        long result=0;
        int i=0;
        while(i<n && s[i]==' '){
            i++;
        }
        if(i==n) return 0;
        if(s[i] == '-'){
            signal=false;
            i++;
        }
        else if(s[i]=='+'){
            i++;
        }
        if(i==n) return 0;
        while(i<n && s[i]>='0' && s[i]<= '9'){
            result=result*10+s[i]-'0';
            if(result>INT_MAX){
                break;
            }
            i++;
        }
        if((int)result != result){
            return signal ? INT_MAX : INT_MIN;
        }
        return signal ? result : result*-1;
    }
};
```

### 12.整数转罗马数字

贪心算法：每次选最大的数，先弄一张对应的哈希表，然后按高位到低位比下来

![image-20230310134948525](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230310134948525.png)

```cpp
for(int i=.;i<13;i++){
    while(num>=value[i]){
        num-=value[i];
        result+=reps[i];
    }
}
```



```cpp
class Solution {
public:
    string intToRoman(int num) {
        string result;
        if(num == 0) return "";
        int value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
        string reps[]={"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        for(int i=0;i<13;i++){
            while(num>=value[i]){
                num-=value[i];
                result+=reps[i];
            }
        }
        return result;
    }
};
```





###13.罗马数字转整数

同样用到哈希表，判断前一位是否比下一位小，如果比下一位小就加上负号

```cpp
class Solution {
public:
    int romanToInt(string s) {
        int n=s.size();
        int result=0;
        unordered_map<char,int> mp;
        mp['I']=1;
        mp['V']=5;
        mp['X']=10;
        mp['L']=50;
        mp['C'] = 100;
        mp['D'] = 500;
        mp['M'] = 1000;

        for(int i=0;i<n-1;i++){
            if(mp[s[i]]<mp[s[i+1]]){
                result-=mp[s[i]];
            }
            else{
                result+=mp[s[i]];
            }
        }
        result+=mp[s[n-1]];
        return result;
    }
};
```





### 14.最长公共前缀



自己的写法：过了88%

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size()==1) return strs[0];
        string result;
        int start=0;
        int minsize=INT_MAX;
        for(auto str:strs){
            minsize=min(minsize,(int)str.size());
        }
        if(minsize==0) return "";
        while(start<=minsize){
            for(int i=1;i<strs.size();i++){
                char s=strs[0][start];
                if(strs[i][start]==s) continue;
                else{
                    return result;
                }
            }
            result+=strs[0][start];
            start++;
        }
        return result;
    }
};
```



能过得，思路差不多，写法不同

先找最短，然后最短的那个拿出来设置成min数组，然后从这个数组从小到大开始比较。

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string ans = "";
        if(strs.empty())    return ans; //输入为空，输出空ans
        int arr = strs.size();
        string min = strs[0];
        for(int i = 1; i < arr; ++ i) //找到最短字符串
        {
            if(strs[i].size() < min.size())
                min = strs[i];
        }
        for(int j = 0; j < min.size(); ++ j)
        {
            for(int m = 0; m < arr; ++m)
            {
                if(min[j] != strs[m][j])
                    return ans;
            }
            ans = ans + min[j];
        }
        return ans;
    }
};
```



### ==29.两数相除==

不能使用乘法，除法，取余，实现除法操作。

不会，是一个递归的思想：举个例子：11 除以 3 。
首先11比3大，结果至少是1， 然后我让3翻倍，就是6，发现11比3翻倍后还要大，那么结果就至少是2了，那我让这个6再翻倍，得12，11不比12大，吓死我了，差点让就让刚才的最小解2也翻倍得到4了。但是我知道最终结果肯定在2和4之间。也就是说2再加上某个数，这个数是多少呢？我让11减去刚才最后一次的结果6，剩下5，我们计算5是3的几倍，也就是除法，看，递归出现了。

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1){
            if(dividend>INT_MIN) return -dividend;// 只要不是最小的那个整数，都是直接返回相反数就好啦
            return INT_MAX;// 是最小的那个，那就返回最大的整数啦
        }
        long a = dividend;
        long b = divisor;
        int sign = 1; 
        if((a>0&&b<0) || (a<0&&b>0)){
            sign = -1;
        }
        a = a>0?a:-a;
        b = b>0?b:-b;
        long res = div(a,b);
        if(sign>0)return res>INT_MAX?INT_MAX:res;
        return -res;
    }
    int div(long a, long b){  // 似乎精髓和难点就在于下面这几句
        if(a<b) return 0;
        long count = 1;
        long tb = b; // 在后面的代码中不更新b
        while((tb+tb)<=a){
            count = count + count; // 最小解翻倍
            tb = tb+tb; // 当前测试的值也翻倍
        }
        return count + div(a-tb,b);
    }
};
```

### 36.有效数独

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int ans[10]={0};//用来记录1到9在该行，该列，该box有没有出现多次
        for(int i=0;i<9;i++){//判断行的情况
            for(int j=0;j<9;j++){
                if(board[i][j]!='.'){
                    ans[(int)(board[i][j]-48)]++;
                    if(ans[(int)(board[i][j]-48)]>1) return false;
                } 
            }
            for(int f=0;f<10;f++){
                ans[f]=0;
            }//每一次用来记录的数组都要清零
        }
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[j][i]!='.'){
                    ans[(int)(board[j][i]-48)]++;
                    if(ans[(int)(board[j][i]-48)]>1) return false;
                } 
            }
            for(int f=0;f<10;f++){
                ans[f]=0;
            }
        }
        int n=0;
        while(n<9){
            for(int i=n/3*3;i<n/3*3+3;i++){
                for(int j=n%3*3;j<n%3*3+3;j++){
                    if(board[i][j]!='.'){
                        ans[(int)(board[i][j]-48)]++;
                        if(ans[(int)(board[i][j]-48)]>1) return false;
                    } 
                }
            }
            for(int f=0;f<10;f++){
                ans[f]=0;
            }
            n++;//一共有9个box，每一次循环检查一个box的情况。
        }
        return true;
    }
};

```



### 38 外观数列

```cpp
class Solution {
public:
    string countAndSay(int n) {
        if(n==1) return "1";
        string result;    
        string str=countAndSay(n-1);
        int size=str.size();
        int count=1;
        for(int i=1;i<=size;i++){
            if(str[i]!=str[i-1]){
                result += count+'0';
                result += str[i-1];
                count=0;
            }
            count++;
        }
        return result;
    }
};
```



### 43.字符串相乘

不管怎么用整数的除法都会溢出，所以要模拟

计算 `123 × 5`，再计算 `123 × 4`，最后错一位相加。

<img src="https://labuladong.github.io/algo/images/%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b9%98%e6%b3%95/4.gif" alt="img" style="zoom: 50%;" />

**`num1[i]` 和 `num2[j]` 的乘积对应的就是 `res[i+j]` 和 `res[i+j+1]` 这两个位置**。

![image-20230323100024421](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230323100024421.png)

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
    int m = num1.size(), n = num2.size();
    // 结果最多为 m + n 位数
    vector<int> res(m + n, 0);
    // 从个位数开始逐位相乘
    for (int i = m - 1; i >= 0; i--)
        for (int j = n - 1; j >= 0; j--) {
            int mul = (num1[i]-'0') * (num2[j]-'0');
            // 乘积在 res 对应的索引位置
            int p1 = i + j, p2 = i + j + 1;
            // 叠加到 res 上
            int sum = mul + res[p2];
            res[p2] = sum % 10;
            res[p1] += sum / 10;
        }
    // 结果前缀可能存的 0（未使用的位）
    int i = 0;
    while (i < res.size() && res[i] == 0)
        i++;
    // 将计算结果转化成字符串
    string str;
    for (; i < res.size(); i++)
        str.push_back('0' + res[i]);
    
    return str.size() == 0 ? "0" : str;
    }
};
```







### 50.Pow(x,n)

递归实现，唯一问题在于数太大可能会溢出，要做溢出处理

要用快速幂的思想：比如计算X的64次方：

![image-20230312100309144](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230312100309144.png)

从右往左看就是把次数二分之后，然后向下取整的过程。

![image-20230312100439153](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230312100439153.png)

所以底层因为是二分，所以复杂度为：O（logn）

负数的情况要特殊考虑，附属要变成1/pow

```cpp
class Solution {
public:
    double quickMul(double x,long long n){
        if(n==0) return 1;
        double y=quickMul(x,n/2);
        return n%2==0 ? y*y : y*y*x;
    }
    double myPow(double x, long long n) {
        return n>=0 ? quickMul(x,n) : 1/quickMul(x,-n);
    }
};
```

### 57.插入区间

就是插入一个区间之后合并区间的问题

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<vector<int>> merge(vector<vector<int>> & intervals){
        int low=intervals[0][0],high=intervals[0][1];
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]>high){
                result.push_back({low,high});
                low=intervals[i][0];
                high=intervals[i][1];
            }
            else{
                low=min(low,intervals[i][0]);
                high=max(high,intervals[i][1]);
            }
        }
        result.push_back({low,high});
        return result;
    }


    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        intervals.push_back(newInterval);
        sort(intervals.begin(),intervals.end());
        result=merge(intervals);
        return result;
    }
};
```







### 58.最后一个单词的长度

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        if(s.empty()) return 0;
        int len=s.size();
        vector<string> res;
        string str="";
        for(int i=0;i<len;i++){
            if(s[i] == ' '){
                if(!str.empty()){
                    res.push_back(str);
                    str="";
                } 
            }
            else{
                str+=s[i];
            }
        }
        if(!str.empty()){
            res.push_back(str);
        }
        return res[(int)res.size()-1].size();
    }
};
```



### ==60.排列序列==

需要剪枝的dfs

```cpp
class Solution {
public:
    string tmp,ans;
    //表示当前搜索到第几个排列了
    int index=0;

    //计算阶乘，以求得某个子树下的排列个数
    int factorial(int n) {
        if(n==1||n==0)
            return 1;
        return n * factorial(n-1);
    }

    void backtracking(vector<int>& used,int n,int k,int diff){
        //剪枝2：当index==k+1时，说明第k个排列已经找到，因此接下来的每次递归调用都直接return。
        if(index==k+1) return;
        if(tmp.size()==n){   //一个排列已经找到
            index++;         //更新值
            if(index==k)     //判断当前这个排列是否是第k个
                ans=tmp;         
            return;
        }
        for(int i=1;i<=n;++i){
            int cur=factorial(n-tmp.size()-1);   //这个结点下能产生的排列数量，一个阶乘运算就能算出来
            //剪枝1：判断第k个排列是否在这个结点下，若不是，则直接跳过这个对这个子树的搜索，相当于已经搜索过这些被跳过的排列了
            if(diff>cur) {   
                //既然“搜索”过了，别忘了更新数据
                diff-=cur;
                index+=cur;
                continue;
            }
            //能够执行到这里，说明第k个排列就在以当前结点为根的树里，搜索这个树
            if(used[i-1]==0){ 
                //更新数据，此后的每次搜索diff都<=0<cur，从而能够保证搜索到这个子树下的每一个排列，直到找到第k个
                diff-=cur;
                used[i-1]=1;
                tmp+=to_string(i);
                backtracking(used,n,k,diff);
                tmp.pop_back();
                used[i-1]=0;
            }
        }
    }
    string getPermutation(int n, int k) {
        vector<int> used(n);
        backtracking(used,n,k,k);
        return ans;
    }
};
```







### 61.旋转链表

![image-20230318103456679](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230318103456679.png)

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode* cur=head;
        int len=0;
        while(cur){
            cur=cur->next;
            len++;
        }
        if(len==0) return nullptr;
        k=k%len;
        auto first=head,second=head;
        while(k--){
            first=first->next;
        }
        while(first->next){
            first=first->next;
            second=second->next;
        }
        first->next=head;
        head=second->next;
        second->next=nullptr;
        return head;    
    }
};
```



### 66.加一

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int len=digits.size();
        for(int i=len-1;i>=0;i--){
            if(i==len-1) digits[i]+=1;
            if(digits[i]<10){
                break;
            }
            else{
                digits[i]=0;
                if(i>=1){
                    digits[i-1]+=1;
                }
                else{
                    digits.insert(digits.begin(),1);
                }
            }
        }
        return digits;
    }
};
```



### ==67.二进制求和==

类似题目

![image-20230320100202431](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230320100202431.png)

这类题目的巧妙之处都是那个：`while (i >= 0 || j >= 0 || carry != 0)`

```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int pre=0;
        int i=a.size()-1;
        int j=b.size()-1;
        while(i>=0 || j>=0 || pre!=0){
            int digitA= i>=0 ? a[i]-'0' : 0;
            int digitB= j>=0 ? b[j]-'0' : 0;
            int sum=digitA+digitB+pre;
            pre=sum/2;
            sum=sum%2;
            res+=to_string(sum);
            i--;
            j--;
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

### 71.简化路径

栈中只存目录名，不存'/'。

用数组模拟栈：每个分割部分用string保存，遇到.什么都不做，遇到..pop一个出来。

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> st;
        int n=path.size(),i=0;
        while(i<n){
            if(path[i]=='/') i++;
            else{
                string str="";
                while(path[i]!='/' && i<n){
                    str+=path[i];
                    i++;
                }
                if(str==".");
                else if(str==".."){
                    if(!st.empty()){
                        st.pop_back();
                    }
                }
                else{
                    st.push_back(str);
                }
                str="";
            }
        }
        if(st.empty()) return "/";
        string res="";
        for(auto s:st){
            res+=("/"+s);
        }
        return res;
    }
};
```



### 73.矩阵置零

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        vector<vector<int>> records;
        int m=matrix.size(),n=matrix[0].size();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]==0){
                    records.push_back({i,j});
                }
            }
        }
        for(auto & record:records){
            for(int i=0;i<m;i++) matrix[i][record[1]]=0;
            for(int j=0;j<n;j++) matrix[record[0]][j]=0;
        }
    }
};
```



### 80.删除有序数组中的重复项Ⅱ

这种要求原地删除的题目，都可以使用双指针。遇到相同的让快指针向前走，遇到不同的让慢指针：`nums[++ptr2]=ptr1`

这里是出现两次，所以需要加一个count来计数出现的次数。

**count<2,也是做覆盖。**

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==1) return 1;
        int slow=0,fast=0;
        int count=0;
        while(fast<nums.size()){
            if(nums[fast]!=nums[slow]){
                nums[++slow]=nums[fast];
            }
            else if(slow<fast && count<2){
                nums[++slow]=nums[fast];
            }
            fast++;
            count++;
            if(fast<nums.size() && nums[fast]!=nums[fast-1]){
                count=0;
            }
        }
        return slow+1;
    }
};
```



### 81. 搜索旋转数组Ⅱ

这种题目都是二分，如果要求时间复杂度O（logN），和33不同的是有重复的数字，所以需要去重

```cpp
while(left<right&&nums[left]==nums[left+1]) ++left;
while(left<right&&nums[right]==nums[right-1]) --right;
```



```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if(nums.size()==1) return nums[0]==target ? true :false;
        int left=0,right=nums.size()-1;
        while(left<=right){
            while(left<right&&nums[left]==nums[left+1]) ++left;
            while(left<right&&nums[right]==nums[right-1]) --right;
            int mid=(left+right)/2;
            if(nums[mid]==target) return true;
            else if(nums[mid]>=nums[0]){
                if(target>=nums[0] && target<nums[mid]){
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
            else{
                if(target>nums[mid] && target<=nums[nums.size()-1]){
                    left=mid+1;
                }
                else{
                    right=mid-1;
                }
            }
        }
        return false;
    }
};
```



### ==91.解码方法==

动态规划问题

状态转移关系：

**==定义：dp[i] 表示 s[0..i-1] 的解码方式数量==**

1. `s[i]` 本身可能表示一个字母，这种情况下解码数量为 `numDecodings(s[0..i-1])`
2. `s[i]` 可能和 `s[i - 1]` 结合起来表示一个字母，这种情况下解码数量为 `numDecodings(s[0..i-2])`

状态转移方程：

```cpp
numDecodings(s) = numDecodings(s[0:-1]) + numDecodings(s[0:-2])
```



```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.length();
        if (n < 1) {
            return 0;
        }
        // 定义：dp[i] 表示 s[0..i-1] 的解码方式数量
        vector<int> dp(n + 1, 0);
        // base case: s 为空或者 s 只有一个字符的情况
        dp[0] = 1;
        dp[1] = s[0] == '0' ? 0 : 1;

        // 注意 dp 数组和 s 之间的索引偏移一位
        for (int i = 2; i <= n; i++) {
            char c = s[i-1], d = s[i-2];
            if ('1' <= c && c <= '9') {
                // 1. s[i] 本身可以作为一个字母
                dp[i] += dp[i - 1];
            }
            if (d == '1' || d == '2' && c <= '6') {
                // 2. s[i] 和 s[i - 1] 结合起来表示一个字母
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
};
```





### 99.恢复二叉搜索树

方法1：转化成数组之后排序，排序完再中序遍历改一下结点值。时间复杂度`O(n)` ,空间复杂度：`O(n)`

```cpp
class Solution {
public:
    vector<int> vec;
    void traversal(TreeNode* root){
        if(root==nullptr) return;
        traversal(root->left);
        vec.push_back(root->val);
        traversal(root->right);
    }

    int index=0;
    void inorderTree(TreeNode* root){
        if(root==nullptr) return;
        inorderTree(root->left);
        root->val=vec[index];
        index++;
        inorderTree(root->right);
    }

    void recoverTree(TreeNode* root) {
        traversal(root);
        sort(vec.begin(),vec.end());
        inorderTree(root);
    }
};
```



方法二：时间复杂度低一点的，利用指针存储

```cpp
class Solution {
public:
    TreeNode *t1, *t2, *pre;
    void recoverTree(TreeNode* root) {
        inorder(root);
        int temp = t1->val;
        t1->val = t2->val;
        t2->val = temp;
    }
    void inorder(TreeNode *root){ //一次违反是两次违反的问题
        if (root == NULL) return ;
        inorder(root->left);
        if (pre != NULL && pre->val > root->val) {
            if (t1 == NULL) t1 = pre; //保证只给t1赋值一次
            t2 = root;
        }
        pre = root;
        inorder(root->right);
    }
};
```



### ==153.寻找旋转排序数组中的最小值==

==mid与right比较==

- 左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界

- 左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界

- 左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界

- 左值 > 中值, 中值 > 右值 ：单调递减，不可能出现

为什么比较mid与right而不比较mid与left？
具体原因前面已经分析过了，简单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int right=nums.size()-1;
        int left=0;
        while(left<right){
            int mid=(right+left)/2;
            if(nums[mid]>nums[right]){
                left=mid+1;          
            }
            else {
                right=mid;
            }
        }
        return nums[left];
    }
};
```





### 154.寻找旋转排序数组中的最小值Ⅱ

在遇到相同元素时，既然无法确定最小值所在区间，==那么干脆去掉末尾元素，继续二分==。对应到代码上，==就是*right* 减一==。

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int right=nums.size()-1;
        int left=0;
        while(left<right){
            int mid=(right+left)/2;
            if(nums[mid]>nums[right]){
                left=mid+1;          
            }
            else if(nums[mid]<nums[right]){
                right=mid;
            }
            else{
                right--;
            }
        }
        return nums[left];
    }
};
```



### ==174.地下城游戏==

如果从左上角走到又虾饺，那么有可能中间是加血的，就不满足动态规划特性。

最小路径和的变种，但是不可以正向dp，要反向。

![image-20230405104834635](C:\Users\gaohan\AppData\Roaming\Typora\typora-user-images\image-20230405104834635.png)

状态转移方程：`dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],0);`

解释：因为dp代表的是从这里到右下角的最小能量，又因为只能往下或者往右，所以先选择一个往下或者往右的路里面最小的：`min(dp[i+1][j],dp[i][j+1]);`,然后再减去本身这一格，如果为负的减去之后就说明能量要变大了，如果小于0了，说明这里过去一开始不要能量，初始化为0.

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m=dungeon.size(),n=dungeon[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[m-1][n-1]=max(-dungeon[m-1][n-1],0);
        for(int i=m-2;i>=0;i--){
            dp[i][n-1]=max(dp[i+1][n-1]-dungeon[i][n-1],0);
        }
        for(int i=n-2;i>=0;i--){
            dp[m-1][i]=max(dp[m-1][i+1]-dungeon[m-1][i],0);
        }
        for(int i=m-2;i>=0;i--){
            for(int j=n-2;j>=0;j--){
                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],0);
            }
        }
        return dp[0][0]+1;
    }
};
```







### 179.最大数

有一个结论性的东西，需要数学推导，记住就好：`bool cmp(string s1, string s2){s1+s2 > s2+s1};`

```cpp
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> vs;
        for(int num:nums) vs.push_back(to_string(num));
        auto cmp=[](const string&A,const string& B){
            return A+B > B+A;
        };
        sort(vs.begin(),vs.end(),cmp);
        string result;
        for(const auto& x:vs) result+=x;
        return result[0]=='0' ? "0" : result;
    }
};
```







### 224.基本计算器

创建两个栈，一个保存括号外面已经算过的值，一个保存符号的正负号。

遇到左括号：将括号外面已经算过的结果result以及左括号前面的符号分别存入两个栈中，然后重置result和符号。

遇到数字要显判断是一位数还是多位数，然后判断数字前面的符号，计算result值。

遇到右括号的时候，将栈顶的值以及括号外面已经算过的值和括号内的值相加。

```cpp
class Solution {
public:
    int calculate(string s) {
        stack<int> numStk;
        stack<int> signStk;
        int result=0;
        int sign=1;
        int n=s.size();
        for(int i=0;i<n;i++){
            if(s[i]==' ') continue;
            else if(s[i]=='+' || s[i]=='-'){
                if(s[i]=='+') sign=1;
                else sign=-1;
            }
            else if(isdigit(s[i])){
                long num=s[i]-'0';
                while(i<n-1 && isdigit(s[i+1])){
                    num=num*10+s[++i]-'0';
                }
                result+=num*sign;
            }
            else if(s[i]=='('){
                numStk.push(result);
                signStk.push(sign);
                result=0;
                sign=1;
            }
            else {
                result=result*signStk.top()+numStk.top();
                signStk.pop();
                numStk.pop();
            }
        }
        return result;
    }
};
```











### 227.基本计算器Ⅱ

实现加减乘除功能，括号优先级最高，其次是乘除。除法无论怎样都向0取整：（5/2=2，-5/2=-2）

首先要考虑字符串如何转成整型的问题？多位数？这里`c-‘0’`一定要加括号，否则可能会造成整型溢出。因为c是ASCII码，不加括号就先加后减，就会尝试溢出。

```cpp
string s="456";
int n=0;
for(int i=0;i<s.size();i++){
    char c=s[i];
    n=n*10+(c-'0');
}
```



处理只有加减法：

```cpp
int calculate(string s) {
    stack<int> stk;
    // 记录算式中的数字
    int num = 0;
    // 记录 num 前的符号，初始化为 +
    char sign = '+';
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        // 如果是数字，连续读取到 num
        if (isdigit(c)) 
            num = 10 * num + (c - '0');
        // 如果不是数字，就是遇到了下一个符号，
        // 之前的数字和符号就要存进栈中
        if (!isdigit(c) || i == s.size() - 1) {
            switch (sign) {
                case '+':
                    stk.push(num); break;
                case '-':
                    stk.push(-num); break;
            }
            // 更新符号为当前符号，数字清零
            sign = c;
            num = 0;
        }
    }
    // 将栈中所有结果求和就是答案
    int res = 0;
    while (!stk.empty()) {
        res += stk.top();
        stk.pop();
    }
    return res;
}
```



加上乘除法：

比如上述例子就可以分解为`+2`，`-3`，`*4`，`+5`几对儿，我们刚才不是没有处理乘除号吗，很简单，**其他部分都不用变**，在`switch`部分加上对应的 case 就行了：

```cpp
for (int i = 0; i < s.size(); i++) {
    char c = s[i];
    if (isdigit(c)) 
        num = 10 * num + (c - '0');

    if (!isdigit(c) || i == s.size() - 1) {
        switch (sign) {
            int pre;
            case '+':
                stk.push(num); break;
            case '-':
                stk.push(-num); break;
            // 只要拿出前一个数字做对应运算即可
            case '*':
                pre = stk.top();
                stk.pop();
                stk.push(pre * num);
                break;
            case '/':
                pre = stk.top();
                stk.pop();
                stk.push(pre / num);
                break;
        }
        // 更新符号为当前符号，数字清零
        sign = c;
        num = 0;
    }
}
```



**因为括号具有递归性质**。我们拿字符串`3*(4-5/2)-6`举例：

calculate(`3*(4-5/2)-6`)
= 3 * calculate(`4-5/2`) - 6
= 3 * 2 - 6
= 0

现在的问题是，递归的开始条件和结束条件是什么？**遇到`(`开始递归，遇到`)`结束递归**：



简单一点还是两个栈，一个栈维护数字，一个栈维护操作符。

可以直接判断字符是不是数字的函数：`isdigit(c)`，返回true或者false



==一定要有个`i--`==

```cpp
class Solution {
public:
    stack<int> num;
        stack<char> op;
        
        void eval(){
            int b=num.top();
            num.pop();
            int a=num.top();
            num.pop();
            char c=op.top();op.pop();
            int r;
            if(c=='+') r=a+b;
            else if(c=='-') r=a-b;
            else if(c=='*') r=a*b;
            else if(c=='/') r=a/b;
            num.push(r);
        }

    int calculate(string s) {
        s='0'+s;//对负数进行处理
        unordered_map<char,int> mp;
        mp['+']=mp['-']=1;
        mp['*']=mp['/']=2;
        for(int i=0;i<s.size();i++){
            if(s[i]==' ') continue;
            if(isdigit(s[i])){
                int x=0;
                while(i<s.size() && s[i] >= '0' && s[i] <= '9'){
                    x=x*10+(s[i++]-'0');
                }
                num.push(x);
                i--;
            }
            else{
            //op栈非空并且栈顶操作符优先级大于等于当前操作符c的优先级，进行eval()计算
                while(!op.empty() && mp[op.top()]>=mp[s[i]]){
                    eval();
                }
                op.push(s[i]);
            }
        }
        while(!op.empty()) eval();
        return num.top();
    }
};
```













### ==1408.数组中的字符串匹配==

这里都是指string.后面那个函数find

**关键就是要知道字符串的find，找到的是npos**

find() 正向查找要匹配字符串的第一个字符出现的位置

rfind()反向查找要匹配的字符串的第一个字符出现的位置

对于上面两个函数，若查找失败 则会返回一个==**特殊标记npos，一般写做string::npos**==

find_first_of()正向查找要匹配的字符串的第一个字符出现的位置

find_last_of() 反向查找要匹配的字符串的**最后一个字符**出现的位置

![QQ截图20220806094755.jpg](https://pic.leetcode-cn.com/1659750494-LzrHog-QQ%E6%88%AA%E5%9B%BE20220806094755.jpg)

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> result;
        for(auto &word1:words){
            int len1=word1.size();
            for(auto &word2:words){
                int len2=word2.size();
                //auto it=find(word2.begin(),word2.end(),word1);
                if(len2>len1 && word2.find(word1) != string::npos){
                    result.push_back(word1);
                    break;
                } 
            }
        }
        return result;
    }
};
```





补充：C++中的find函数：

 ```cpp
 InputIterator find (InputIterator first, InputIterator last, const T& val);
 ```

first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。

```cpp
#include <iostream>     // std::cout
#include <algorithm>    // std::find
#include <vector>       // std::vector
using namespace std;
int main() {
    //find() 函数作用于普通数组
    char stl[] ="http://c.biancheng.net/stl/";
    //调用 find() 查找第一个字符 'c'
    char * p = find(stl, stl + strlen(stl), 'c');
    //判断是否查找成功
    if (p != stl + strlen(stl)) {
        cout << p << endl;
    }
    //find() 函数作用于容器
    std::vector<int> myvector{ 10,20,30,40,50 };
    std::vector<int>::iterator it;
    it = find(myvector.begin(), myvector.end(), 30);
    if (it != myvector.end())
        cout << "查找成功：" << *it;
    else
        cout << "查找失败";
    return 0;
}
```

